=== Project Analysis File ===\nGenerated on: 08/30/2025 09:55:41\nProject Root: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\n\n=== File Structure (Tree View) ===\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\babel.config.cjs\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combined_project.txt\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files.bat\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files_utf8.bat\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\DEPLOYMENT.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\index.html\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\metadata.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package-lock.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\QWEN.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\README.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\social-sync-pro-afa76-firebase-adminsdk-fbsvc-3b5d1b4378.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\temp_ps.ps1\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\tsconfig.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\types.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\update_function.cjs\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\vite.config.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.gemini\GEMINI.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\project.json\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\README.txt\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini-generate.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\health.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\index.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudflare\generate-image.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudinary\upload.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\facebook\publish.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini\[action].js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\airtable.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\cors.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\mongodb.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\affiliate-vault.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\initial-load.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\list-media-plan-groups.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-affiliate-vault.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts-with-pagination.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-personas.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-strategy-hub.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\media-plan-posts.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\personas.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\strategy-hub.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\[action].js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\openrouter\[action].js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\AI_ADMIN_IMPLEMENTATION.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\BFF_IMPLEMENTATION.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Clean-Up-and-Remove-All-Testing-Components-from-a-Vite-Project.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\e2e-testing-plan.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\improve-initial-load-times-and-resource-management.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\intergrate-mongodb.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\openrouter_gemini_bff_refactoring_plan.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\pass-Error-No-more-than-12-Serverless-Functions-can-be-added-to-a-Deployment-on-the-Hobby-plan.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Prompt Refactor a Full-Stack Project for Vercel Deployment.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Refactor-a-Vite-Project-for-Vercel-Compatibility.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Sales-Funnel-Campaign-Generator.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\scalability_and_performance_improvements.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\settings-management-flow.txt\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Business_Requirements_Document.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Project_Plan.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] SocialSync_Pro_Feature_Descriptions.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] System_Architecture_Document.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Test_Plan_and_Strategy.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] User_Manual.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\check-migration-status.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\init-mongodb-database.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\migrate-airtable-to-mongodb.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\MIGRATION_COMPLETE_GUIDE.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\README.md\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-connection.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-implementation.js\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\App.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.css\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\polyfills.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\sampleAIServices.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AdminPage.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AffiliateVaultDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableLoadModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AssetDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BrandProfiler.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BulkScheduleModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\CalendarView.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ContentPackageWizardModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FacebookPageSelectionModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelCampaignWizard.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelStage.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\GuidedWizard.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Header.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\IdeaProfiler.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\KhongMinhSuggestion.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Loader.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MainDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanWizardModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonaConnectModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonasDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PlanSelectionModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostCard.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostDetailModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductCard.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductSelector.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ScheduleModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\SettingsModal.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\StrategyDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Toast.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\TrendHubDisplay.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ui.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\FunnelIcon.tsx\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\index.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useInfiniteScroll.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useMediaPlanPagination.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\bffService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudflareService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudinaryService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\configService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\databaseService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\exportService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\facebookService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts.temp\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\khongminhService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\lazyLoadService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\openrouterService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialAccountService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialApiService.ts\nC:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\textGenerationService.ts\n\n=== File Contents ===\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\babel.config.cjs ---\nmodule.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    '@babel/preset-typescript',
    ['@babel/preset-react', { runtime: 'automatic' }],
  ],
  plugins: ['babel-plugin-transform-vite-meta-env'],
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\babel.config.cjs ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combined_project.txt ---\n^
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combined_project.txt ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files.bat ---\n@echo off
setlocal EnableDelayedExpansion

:: Script to combine all project files into one UTF-8 encoded output file (combined_project.txt).
:: Handles Vietnamese characters by using PowerShell for robust UTF-8 encoding.
:: Usage:
:: 1. Save this as combine_project_files_utf8.bat in your project root (e.g., social-sync-pro).
:: 2. Open VS Code, go to Terminal > New Terminal, and run: combine_project_files_utf8.bat
:: 3. The script creates combined_project.txt in UTF-8 encoding.
:: 4. Open combined_project.txt in VS Code, verify encoding (UTF-8 in bottom-right corner), remove sensitive data (e.g., API keys), and upload to Grok or paste contents.
:: Note: Excludes node_modules, .git, .env, .env.local, dist, build, and *.log files for security and brevity.

:: Set Command Prompt to UTF-8 encoding
chcp 65001 >nul

:: Create a temporary PowerShell script to handle file output with proper UTF-8 encoding
echo $output = "=== Project Analysis File ===\n" > temp_ps.ps1
echo $output += "Generated on: $(Get-Date)\n" >> temp_ps.ps1
echo $output += "Project Root: $PWD\n\n" >> temp_ps.ps1
echo $output += "=== File Structure (Tree View) ===\n" >> temp_ps.ps1
echo $output += (dir -Recurse -File ^| Where-Object { $_.FullName -notmatch '\\node_modules\\|^\\\.git\\|^\\dist\\|^\\build\\|\.env|\.log$' } ^| Select-Object -ExpandProperty FullName ^| ForEach-Object { $_ }) -join "\n" >> temp_ps.ps1
echo $output += "\n\n=== File Contents ===\n" >> temp_ps.ps1
echo dir -Recurse -File ^| Where-Object { $_.FullName -notmatch '\\node_modules\\|^\\\.git\\|^\\dist\\|^\\build\\|\.env|\.log$' } ^| ForEach-Object { >> temp_ps.ps1
echo     $file = $_.FullName >> temp_ps.ps1
echo     $output += "\n--- File: $file ---\n" >> temp_ps.ps1
echo     if ($file -match '\.env') { >> temp_ps.ps1
echo         $output += "[Sensitive file: Contents omitted for security. Manually review if needed.]\n" >> temp_ps.ps1
echo     } else { >> temp_ps.ps1
echo         try { >> temp_ps.ps1
echo             $content = Get-Content -Path $file -Raw -Encoding UTF8 >> temp_ps.ps1
echo             $output += $content + "\n" >> temp_ps.ps1
echo         } catch { >> temp_ps.ps1
echo             $output += "[Binary or unreadable file: Contents omitted.]\n" >> temp_ps.ps1
echo         } >> temp_ps.ps1
echo     } >> temp_ps.ps1
echo     $output += "--- End of File: $file ---\n" >> temp_ps.ps1
echo } >> temp_ps.ps1
echo $output += "\n=== End of Project Analysis File ===\n" >> temp_ps.ps1
echo $output += "Upload this file to Grok. If sensitive data (e.g., API keys) appears, edit it out before uploading.\n" >> temp_ps.ps1
echo $output ^| Out-File -FilePath combined_project.txt -Encoding utf8 >> temp_ps.ps1

:: Run the PowerShell script
powershell -ExecutionPolicy Bypass -File temp_ps.ps1

:: Clean up temporary PowerShell script
del temp_ps.ps1

echo.
echo Script completed. Check combined_project.txt in your project root.
echo 1. Open combined_project.txt in VS Code and verify encoding (UTF-8 in bottom-right corner).
echo 2. Remove any sensitive data (e.g., API keys) before uploading.
echo 3. Upload to Grok or paste contents into your conversation with Grok.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files.bat ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files_utf8.bat ---\n@echo off
setlocal EnableDelayedExpansion

:: Script to combine all project files into one UTF-8 encoded output file (combined_project.txt).
:: Handles Vietnamese characters using PowerShell for robust UTF-8 encoding.
:: Usage:
:: 1. Save this as combine_project_files_utf8.bat in your project root (e.g., social-sync-pro).
:: 2. Open VS Code, go to Terminal > New Terminal, and run: combine_project_files_utf8.bat
:: 3. The script creates combined_project.txt in UTF-8 encoding.
:: 4. Open combined_project.txt in VS Code, verify encoding (UTF-8 in bottom-right corner), remove sensitive data (e.g., API keys), and upload to Grok or paste contents.
:: Note: Excludes node_modules, .git, .env, .env.local, dist, build, and *.log files for security and brevity.

:: Set Command Prompt to UTF-8 encoding
chcp 65001 >nul

:: Create a temporary PowerShell script with simplified filtering
echo $output = "=== Project Analysis File ===\n" > temp_ps.ps1
echo $output += "Generated on: $(Get-Date)\n" >> temp_ps.ps1
echo $output += "Project Root: $PWD\n\n" >> temp_ps.ps1
echo $output += "=== File Structure (Tree View) ===\n" >> temp_ps.ps1
echo $output += (Get-ChildItem -Recurse -File ^| Where-Object { $_.FullName -notlike '*node_modules*' -and $_.FullName -notlike '*.git*' -and $_.FullName -notlike '*dist*' -and $_.FullName -notlike '*build*' -and $_.FullName -notlike '*.env*' -and $_.FullName -notlike '*.log' } ^| Select-Object -ExpandProperty FullName ^| ForEach-Object { $_ }) -join "\n" >> temp_ps.ps1
echo $output += "\n\n=== File Contents ===\n" >> temp_ps.ps1
echo Get-ChildItem -Recurse -File ^| Where-Object { $_.FullName -notlike '*node_modules*' -and $_.FullName -notlike '*.git*' -and $_.FullName -notlike '*dist*' -and $_.FullName -notlike '*build*' -and $_.FullName -notlike '*.env*' -and $_.FullName -notlike '*.log' } ^| ForEach-Object { >> temp_ps.ps1
echo     $file = $_.FullName >> temp_ps.ps1
echo     $output += "\n--- File: $file ---\n" >> temp_ps.ps1
echo     if ($file -like '*.env*') { >> temp_ps.ps1
echo         $output += "[Sensitive file: Contents omitted for security. Manually review if needed.]\n" >> temp_ps.ps1
echo     } else { >> temp_ps.ps1
echo         try { >> temp_ps.ps1
echo             $content = Get-Content -Path $file -Raw -Encoding UTF8 >> temp_ps.ps1
echo             $output += $content + "\n" >> temp_ps.ps1
echo         } catch { >> temp_ps.ps1
echo             $output += "[Binary or unreadable file: Contents omitted.]\n" >> temp_ps.ps1
echo         } >> temp_ps.ps1
echo     } >> temp_ps.ps1
echo     $output += "--- End of File: $file ---\n" >> temp_ps.ps1
echo } >> temp_ps.ps1
echo $output += "\n=== End of Project Analysis File ===\n" >> temp_ps.ps1
echo $output += "Upload this file to Grok. If sensitive data (e.g., API keys) appears, edit it out before uploading.\n" >> temp_ps.ps1
echo $output ^| Out-File -FilePath combined_project.txt -Encoding utf8 >> temp_ps.ps1

:: Run the PowerShell script
powershell -ExecutionPolicy Bypass -File temp_ps.ps1

:: Clean up temporary PowerShell script
del temp_ps.ps1

echo.
echo Script completed. Check combined_project.txt in your project root.
echo 1. Open combined_project.txt in VS Code and verify encoding (UTF-8 in bottom-right corner).
echo 2. Remove any sensitive data (e.g., API keys) before uploading.
echo 3. Upload to Grok or paste contents into your conversation with Grok.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\combine_project_files_utf8.bat ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\DEPLOYMENT.md ---\n# Deployment Guide for SocialSync Pro

## Overview

SocialSync Pro consists of two main components:
1. **Frontend**: React application (this repository)
2. **Backend-for-Frontend (BFF)**: Serverless functions that act as a secure proxy for external APIs

## **Local Development Setup (Vercel)**

### **1. Prerequisites**

  * Node.js (version 16 or higher)
  * npm (comes with Node.js)
  * **Vercel CLI**

### **2. Initial Setup**

1.  **Clone the repository** (if you haven't already).
2.  **Navigate into the project directory**.
3.  **Install dependencies**:
    ```bash
    npm install
    ```
4.  **Install Vercel CLI** (if you don't have it):
    ```bash
    npm install -g vercel
    ```
5.  **Link your local project to Vercel**:
    ```bash
    vercel link
    ```
    This will connect your local codebase to the corresponding project on your Vercel dashboard.

-----

### **3. Environment Variables**

For local development, `vercel dev` uses a `.env.local` file. This filename is standard and is automatically ignored by Git.

**Option A: Create the file manually**

1.  Create a file named `.env.local` in the project's root directory.
2.  Add your secret keys to this file:
    ```
    VITE_GEMINI_API_KEY="your_gemini_key"
    VITE_AIRTABLE_PAT="your_airtable_token"
    VITE_AIRTABLE_BASE_ID="your_airtable_base_id"
    VITE_CLOUDINARY_CLOUD_NAME="your_cloudinary_name"
    VITE_CLOUDINARY_UPLOAD_PRESET="your_cloudinary_preset"
    ...
    ```

**Option B: Pull from Vercel**
If you've already added the variables to your project settings on the Vercel dashboard, you can sync them with this command:

```bash
vercel env pull .env.local
```

-----

### 4. Running the Development Server

Before running the development server, ensure all dependencies are installed:
```bash
npm install
```

Then start the development server using Vite:
```bash
npm run dev
```

Alternatively, if you have Vercel CLI installed, you can use:
```bash
vercel dev
```

Note: If you encounter an error like `'vite' is not recognized as an internal or external command`, make sure you've run `npm install` to install all dependencies including Vite.

The application will be available at `http://localhost:5173`

## Deploying to Vercel

### 1. Prerequisites

Before deploying, you need to set up your environment variables in Vercel:
- Other environment variables for external services (see below)

### 2. Deploying the Complete Application to Vercel

This project is configured to deploy both frontend and backend (as serverless functions) to Vercel.

1. Push your code to a GitHub repository
2. Connect the repository to Vercel
3. Configure the build settings:
   - Build Command: `npm run build`
   - Output Directory: `dist`
   - Install Command: `npm install`

4. Add environment variables in the Vercel dashboard:
   - `GEMINI_API_KEY` - Your Gemini API key
   - `AIRTABLE_PAT` - Your Airtable Personal Access Token
   - `AIRTABLE_BASE_ID` - Your Airtable Base ID
   - `CLOUDINARY_CLOUD_NAME` - Your Cloudinary cloud name
   - `CLOUDINARY_UPLOAD_PRESET` - Your Cloudinary upload preset
   - `OPENROUTER_API_KEY` - Your OpenRouter API key (optional)
   - `FACEBOOK_APP_ID` - Your Facebook App ID (optional)

### 3. How It Works

Vercel automatically detects files in the `api/` directory and deploys them as serverless functions:
- `api/health.js` becomes `https://your-app.vercel.app/api/health`
- `api/gemini-generate.js` becomes `https://your-app.vercel.app/api/gemini/generate`

The frontend makes requests to these endpoints, and Vercel routes them to the appropriate serverless functions.

### 4. Local Development vs Production

In local development:
- The frontend runs on Vite's development server (port 5173)
- API calls to `/api` endpoints are handled by the same development server
- During local development, you'll need to run both the frontend and backend services

In production:
- The frontend is built and served statically
- API calls are made directly to the Vercel serverless functions
- Vercel automatically routes `/api/*` requests to the corresponding functions

## Project Structure

After cleaning up testing components, the project structure is now:

```
├── api/                 # Serverless functions (BFF)
├── src/                 # Frontend React application
├── index.html           # Main HTML file
├── vite.config.ts       # Vite configuration
├── package.json         # Project dependencies and scripts
└── .env                 # Environment variables (not committed)
```

## Troubleshooting

### Common Issues

1. **CORS errors**: Serverless functions should be configured to accept requests from your frontend domain.

2. **404 errors for API endpoints**: Ensure your functions are in the correct directory (`api/`) and have the correct export format.

3. **Missing environment variables**: Check that all required environment variables are set in the Vercel dashboard.

4. **Function timeout errors**: Vercel has execution time limits for serverless functions. Complex operations might exceed these limits.

5. **'vite' is not recognized as an internal or external command**: Run `npm install` to ensure all dependencies including Vite are properly installed.

### Testing Your Deployment

1. Visit your frontend URL
2. Check the browser console for any errors
3. Verify that API calls are being made to your Vercel deployment
4. Confirm that all environment variables are properly set

## Additional Notes

- Never expose API keys in the frontend code
- The BFF pattern ensures all sensitive credentials are accessed only by serverless functions
- Make sure to use HTTPS for all production deployments (Vercel provides this automatically)\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\DEPLOYMENT.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\index.html ---\n<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SocialSync Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Lora:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              serif: ['Lora', 'serif'],
            },
            colors: {
               brand: {
                green: '#1a8917',
                'green-dark': '#156f12',
                'light': '#f8fafc',
               },
               dark: {
                text: '#111827',
                subtle: '#4b5563',
               }
            }
          }
        }
      }
    </script>
    <style>
      .bg-grid-gray-200\/50 {
          background-image: linear-gradient(to right, rgba(229, 231, 235, 0.5) 1px, transparent 1px), linear-gradient(to bottom, rgba(229, 231, 235, 0.5) 1px, transparent 1px);
          background-size: 2rem 2rem;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.1.0",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/",
    "@google/genai": "https://esm.sh/@google/genai@^1.10.0",
    "jszip": "https://esm.sh/jszip@3.10.1",
    "file-saver": "https://esm.sh/file-saver@2.0.5",
    "docx": "https://esm.sh/docx@8.5.0",
    "exceljs": "https://esm.sh/exceljs@4.4.0",
    "@aws-sdk/client-s3": "https://esm.sh/@aws-sdk/client-s3@3.614.0",
    "@testing-library/jest-dom": "https://esm.sh/@testing-library/jest-dom@^6.6.4",
    "@testing-library/react": "https://esm.sh/@testing-library/react@^16.3.0",
    "@jest/globals": "https://esm.sh/@jest/globals@^30.0.5",
    "@testing-library/dom": "https://esm.sh/@testing-library/dom@^10.4.1"
  }
}
</script>
<link rel="stylesheet" href="/src/index.css">
</head>
  <body>
    <div id="root"></div>
    <script>
      window.fbAsyncInit = function() {
        FB.init({
          appId            : '1187424996737343',
          cookie           : true,
          xfbml            : true,
          version          : 'v23.0'
        });
        console.log("Facebook SDK initialized from index.html");
      };
    </script>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js"></script>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\index.html ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\metadata.json ---\n{
  "name": "SocialSync Pro 2.0",
  "description": "An AI-powered brand launch assistant that generates a complete and professional set of branding and social media assets based on user input.",
  "requestFramePermissions": [],
  "prompt": ""
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\metadata.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package-lock.json ---\n{
  "name": "socialsync-pro-2.0",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "socialsync-pro-2.0",
      "version": "0.0.0",
      "dependencies": {
        "@aws-sdk/client-s3": "3.614.0",
        "@google/genai": "^1.10.0",
        "@google/generative-ai": "^0.24.1",
        "@tanstack/react-virtual": "^3.8.0",
        "@vitejs/plugin-react": "^4.0.0",
        "airtable": "^0.12.2",
        "docx": "8.5.0",
        "exceljs": "4.4.0",
        "file-saver": "2.0.5",
        "form-data": "^4.0.0",
        "formdata-node": "^6.0.3",
        "jszip": "3.10.1",
        "mongodb": "^6.19.0",
        "node-fetch": "^3.3.2",
        "react": "^19.1.1",
        "react-dom": "^19.1.1",
        "selfsigned": "^3.0.1",
        "uuid": "^11.1.0"
      },
      "devDependencies": {
        "@babel/core": "^7.28.0",
        "@babel/preset-env": "^7.28.0",
        "@babel/preset-react": "^7.27.1",
        "@babel/preset-typescript": "^7.27.1",
        "@types/uuid": "^10.0.0",
        "babel-plugin-transform-import-meta": "^2.3.3",
        "babel-plugin-transform-vite-meta-env": "^1.0.3",
        "dotenv": "^17.2.1",
        "typescript": "~5.8.2",
        "vite": "^5.2.0",
        "vite-plugin-environment": "^1.1.3"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@aws-crypto/crc32": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/crc32/-/crc32-5.2.0.tgz",
      "integrity": "sha512-nLbCWqQNgUiwwtFsen1AdzAtvuLRsQS8rYgMuxCrdKf9kOssamGLuPwyTY9wyYblNr9+1XM8v6zoDTPPSIeANg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-crypto/crc32c": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/crc32c/-/crc32c-5.2.0.tgz",
      "integrity": "sha512-+iWb8qaHLYKrNvGRbiYRHSdKRWhto5XlZUEBwDjYNf+ly5SVYG6zEoYIdxvf5R3zyeP16w4PLBn3rH1xc74Rag==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/sha1-browser": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/sha1-browser/-/sha1-browser-5.2.0.tgz",
      "integrity": "sha512-OH6lveCFfcDjX4dbAvCFSYUjJZjDr/3XJ3xHtjn3Oj5b9RjojQo8npoLeA/bNwkOkrSQ0wgrHzXk4tDRxGKJeg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/supports-web-crypto": "^5.2.0",
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "@aws-sdk/util-locate-window": "^3.0.0",
        "@smithy/util-utf8": "^2.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/is-array-buffer": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-2.2.0.tgz",
      "integrity": "sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-buffer-from": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-2.2.0.tgz",
      "integrity": "sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-2.3.0.tgz",
      "integrity": "sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-browser": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/sha256-browser/-/sha256-browser-5.2.0.tgz",
      "integrity": "sha512-AXfN/lGotSQwu6HNcEsIASo7kWXZ5HYWvfOmSNKDsEqC4OashTp8alTmaz+F7TC2L083SFv5RdB+qU3Vs1kZqw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-js": "^5.2.0",
        "@aws-crypto/supports-web-crypto": "^5.2.0",
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "@aws-sdk/util-locate-window": "^3.0.0",
        "@smithy/util-utf8": "^2.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/is-array-buffer": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-2.2.0.tgz",
      "integrity": "sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-buffer-from": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-2.2.0.tgz",
      "integrity": "sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-2.3.0.tgz",
      "integrity": "sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/sha256-js/-/sha256-js-5.2.0.tgz",
      "integrity": "sha512-FFQQyu7edu4ufvIZ+OadFpHHOt+eSTBaYaki44c+akjg7qZg9oOQeLlk77F6tSYqjDAFClrHJk9tMf0HdVyOvA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-crypto/supports-web-crypto": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/supports-web-crypto/-/supports-web-crypto-5.2.0.tgz",
      "integrity": "sha512-iAvUotm021kM33eCdNfwIN//F77/IADDSs58i+MDaOqFrVjZo9bAal0NK7HurRuWLLpF1iLX7gbWrjHjeo+YFg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/util": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/util/-/util-5.2.0.tgz",
      "integrity": "sha512-4RkU9EsI6ZpBve5fseQlGNUWKMa1RLPQ1dnjnQoe07ldfIzcsGb5hC5W0Dm7u423KWzawlrpbjXBrXCEv9zazQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "^3.222.0",
        "@smithy/util-utf8": "^2.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/is-array-buffer": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-2.2.0.tgz",
      "integrity": "sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/util-buffer-from": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-2.2.0.tgz",
      "integrity": "sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-2.3.0.tgz",
      "integrity": "sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-sdk/client-s3": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-s3/-/client-s3-3.614.0.tgz",
      "integrity": "sha512-9BlhfeBegvyjOqHtcr9kvrT80wiy7EVUiqYyTFiiDv/hJIcG88XHQCZdLU7658XBkQ7aFrr5b8rF2HRD1oroxw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha1-browser": "5.2.0",
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/client-sso-oidc": "3.614.0",
        "@aws-sdk/client-sts": "3.614.0",
        "@aws-sdk/core": "3.614.0",
        "@aws-sdk/credential-provider-node": "3.614.0",
        "@aws-sdk/middleware-bucket-endpoint": "3.614.0",
        "@aws-sdk/middleware-expect-continue": "3.609.0",
        "@aws-sdk/middleware-flexible-checksums": "3.614.0",
        "@aws-sdk/middleware-host-header": "3.609.0",
        "@aws-sdk/middleware-location-constraint": "3.609.0",
        "@aws-sdk/middleware-logger": "3.609.0",
        "@aws-sdk/middleware-recursion-detection": "3.609.0",
        "@aws-sdk/middleware-sdk-s3": "3.614.0",
        "@aws-sdk/middleware-signing": "3.609.0",
        "@aws-sdk/middleware-ssec": "3.609.0",
        "@aws-sdk/middleware-user-agent": "3.614.0",
        "@aws-sdk/region-config-resolver": "3.614.0",
        "@aws-sdk/signature-v4-multi-region": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-endpoints": "3.614.0",
        "@aws-sdk/util-user-agent-browser": "3.609.0",
        "@aws-sdk/util-user-agent-node": "3.614.0",
        "@aws-sdk/xml-builder": "3.609.0",
        "@smithy/config-resolver": "^3.0.5",
        "@smithy/core": "^2.2.6",
        "@smithy/eventstream-serde-browser": "^3.0.4",
        "@smithy/eventstream-serde-config-resolver": "^3.0.3",
        "@smithy/eventstream-serde-node": "^3.0.4",
        "@smithy/fetch-http-handler": "^3.2.1",
        "@smithy/hash-blob-browser": "^3.1.2",
        "@smithy/hash-node": "^3.0.3",
        "@smithy/hash-stream-node": "^3.1.2",
        "@smithy/invalid-dependency": "^3.0.3",
        "@smithy/md5-js": "^3.0.3",
        "@smithy/middleware-content-length": "^3.0.3",
        "@smithy/middleware-endpoint": "^3.0.5",
        "@smithy/middleware-retry": "^3.0.9",
        "@smithy/middleware-serde": "^3.0.3",
        "@smithy/middleware-stack": "^3.0.3",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/node-http-handler": "^3.1.2",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/url-parser": "^3.0.3",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-body-length-node": "^3.0.0",
        "@smithy/util-defaults-mode-browser": "^3.0.9",
        "@smithy/util-defaults-mode-node": "^3.0.9",
        "@smithy/util-endpoints": "^2.0.5",
        "@smithy/util-retry": "^3.0.3",
        "@smithy/util-stream": "^3.0.6",
        "@smithy/util-utf8": "^3.0.0",
        "@smithy/util-waiter": "^3.1.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/client-sso": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-sso/-/client-sso-3.614.0.tgz",
      "integrity": "sha512-p5pyYaxRzBttjBkqfc8i3K7DzBdTg3ECdVgBo6INIUxfvDy0J8QUE8vNtCgvFIkq+uPw/8M+Eo4zzln7anuO0Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.614.0",
        "@aws-sdk/middleware-host-header": "3.609.0",
        "@aws-sdk/middleware-logger": "3.609.0",
        "@aws-sdk/middleware-recursion-detection": "3.609.0",
        "@aws-sdk/middleware-user-agent": "3.614.0",
        "@aws-sdk/region-config-resolver": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-endpoints": "3.614.0",
        "@aws-sdk/util-user-agent-browser": "3.609.0",
        "@aws-sdk/util-user-agent-node": "3.614.0",
        "@smithy/config-resolver": "^3.0.5",
        "@smithy/core": "^2.2.6",
        "@smithy/fetch-http-handler": "^3.2.1",
        "@smithy/hash-node": "^3.0.3",
        "@smithy/invalid-dependency": "^3.0.3",
        "@smithy/middleware-content-length": "^3.0.3",
        "@smithy/middleware-endpoint": "^3.0.5",
        "@smithy/middleware-retry": "^3.0.9",
        "@smithy/middleware-serde": "^3.0.3",
        "@smithy/middleware-stack": "^3.0.3",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/node-http-handler": "^3.1.2",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/url-parser": "^3.0.3",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-body-length-node": "^3.0.0",
        "@smithy/util-defaults-mode-browser": "^3.0.9",
        "@smithy/util-defaults-mode-node": "^3.0.9",
        "@smithy/util-endpoints": "^2.0.5",
        "@smithy/util-middleware": "^3.0.3",
        "@smithy/util-retry": "^3.0.3",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/client-sso-oidc": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-sso-oidc/-/client-sso-oidc-3.614.0.tgz",
      "integrity": "sha512-BI1NWcpppbHg/28zbUg54dZeckork8BItZIcjls12vxasy+p3iEzrJVG60jcbUTTsk3Qc1tyxNfrdcVqx0y7Ww==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.614.0",
        "@aws-sdk/credential-provider-node": "3.614.0",
        "@aws-sdk/middleware-host-header": "3.609.0",
        "@aws-sdk/middleware-logger": "3.609.0",
        "@aws-sdk/middleware-recursion-detection": "3.609.0",
        "@aws-sdk/middleware-user-agent": "3.614.0",
        "@aws-sdk/region-config-resolver": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-endpoints": "3.614.0",
        "@aws-sdk/util-user-agent-browser": "3.609.0",
        "@aws-sdk/util-user-agent-node": "3.614.0",
        "@smithy/config-resolver": "^3.0.5",
        "@smithy/core": "^2.2.6",
        "@smithy/fetch-http-handler": "^3.2.1",
        "@smithy/hash-node": "^3.0.3",
        "@smithy/invalid-dependency": "^3.0.3",
        "@smithy/middleware-content-length": "^3.0.3",
        "@smithy/middleware-endpoint": "^3.0.5",
        "@smithy/middleware-retry": "^3.0.9",
        "@smithy/middleware-serde": "^3.0.3",
        "@smithy/middleware-stack": "^3.0.3",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/node-http-handler": "^3.1.2",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/url-parser": "^3.0.3",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-body-length-node": "^3.0.0",
        "@smithy/util-defaults-mode-browser": "^3.0.9",
        "@smithy/util-defaults-mode-node": "^3.0.9",
        "@smithy/util-endpoints": "^2.0.5",
        "@smithy/util-middleware": "^3.0.3",
        "@smithy/util-retry": "^3.0.3",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "peerDependencies": {
        "@aws-sdk/client-sts": "^3.614.0"
      }
    },
    "node_modules/@aws-sdk/client-sts": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-sts/-/client-sts-3.614.0.tgz",
      "integrity": "sha512-i6QmaVA1KHHYNnI2VYQy/sc31rLm4+jSp8b/YbQpFnD0w3aXsrEEHHlxek45uSkHb4Nrj1omFBVy/xp1WVYx2Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/client-sso-oidc": "3.614.0",
        "@aws-sdk/core": "3.614.0",
        "@aws-sdk/credential-provider-node": "3.614.0",
        "@aws-sdk/middleware-host-header": "3.609.0",
        "@aws-sdk/middleware-logger": "3.609.0",
        "@aws-sdk/middleware-recursion-detection": "3.609.0",
        "@aws-sdk/middleware-user-agent": "3.614.0",
        "@aws-sdk/region-config-resolver": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-endpoints": "3.614.0",
        "@aws-sdk/util-user-agent-browser": "3.609.0",
        "@aws-sdk/util-user-agent-node": "3.614.0",
        "@smithy/config-resolver": "^3.0.5",
        "@smithy/core": "^2.2.6",
        "@smithy/fetch-http-handler": "^3.2.1",
        "@smithy/hash-node": "^3.0.3",
        "@smithy/invalid-dependency": "^3.0.3",
        "@smithy/middleware-content-length": "^3.0.3",
        "@smithy/middleware-endpoint": "^3.0.5",
        "@smithy/middleware-retry": "^3.0.9",
        "@smithy/middleware-serde": "^3.0.3",
        "@smithy/middleware-stack": "^3.0.3",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/node-http-handler": "^3.1.2",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/url-parser": "^3.0.3",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-body-length-node": "^3.0.0",
        "@smithy/util-defaults-mode-browser": "^3.0.9",
        "@smithy/util-defaults-mode-node": "^3.0.9",
        "@smithy/util-endpoints": "^2.0.5",
        "@smithy/util-middleware": "^3.0.3",
        "@smithy/util-retry": "^3.0.3",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/core": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/core/-/core-3.614.0.tgz",
      "integrity": "sha512-BUuS5/1YkgmKc4J0bg83XEtMyDHVyqG2QDzfmhYe8gbOIZabUl1FlrFVwhCAthtrrI6MPGTQcERB4BtJKUSplw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/core": "^2.2.6",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/signature-v4": "^3.1.2",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "fast-xml-parser": "4.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-env": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-env/-/credential-provider-env-3.609.0.tgz",
      "integrity": "sha512-v69ZCWcec2iuV9vLVJMa6fAb5xwkzN4jYIT8yjo2c4Ia/j976Q+TPf35Pnz5My48Xr94EFcaBazrWedF+kwfuQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-http": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-http/-/credential-provider-http-3.614.0.tgz",
      "integrity": "sha512-YIEjlNUKb3Vo/iTnGAPdsiDC3FUUnNoex2OwU8LmR7AkYZiWdB8nx99DfgkkY+OFMUpw7nKD2PCOtuFONelfGA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/fetch-http-handler": "^3.2.1",
        "@smithy/node-http-handler": "^3.1.2",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/util-stream": "^3.0.6",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-ini": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-ini/-/credential-provider-ini-3.614.0.tgz",
      "integrity": "sha512-KfLuLFGwlvFSZ2MuzYwWGPb1y5TeiwX5okIDe0aQ1h10oD3924FXbN+mabOnUHQ8EFcGAtCaWbrC86mI7ktC6A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/credential-provider-env": "3.609.0",
        "@aws-sdk/credential-provider-http": "3.614.0",
        "@aws-sdk/credential-provider-process": "3.614.0",
        "@aws-sdk/credential-provider-sso": "3.614.0",
        "@aws-sdk/credential-provider-web-identity": "3.609.0",
        "@aws-sdk/types": "3.609.0",
        "@smithy/credential-provider-imds": "^3.1.4",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/shared-ini-file-loader": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "peerDependencies": {
        "@aws-sdk/client-sts": "^3.614.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-node": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-node/-/credential-provider-node-3.614.0.tgz",
      "integrity": "sha512-4J6gPEuFZP0mkWq5E//oMS1vrmMM88iNNcv7TEljYnsc6JTAlKejCyFwx6CN+nkIhmIZsl06SXIhBemzBdBPfg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/credential-provider-env": "3.609.0",
        "@aws-sdk/credential-provider-http": "3.614.0",
        "@aws-sdk/credential-provider-ini": "3.614.0",
        "@aws-sdk/credential-provider-process": "3.614.0",
        "@aws-sdk/credential-provider-sso": "3.614.0",
        "@aws-sdk/credential-provider-web-identity": "3.609.0",
        "@aws-sdk/types": "3.609.0",
        "@smithy/credential-provider-imds": "^3.1.4",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/shared-ini-file-loader": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-process": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-process/-/credential-provider-process-3.614.0.tgz",
      "integrity": "sha512-Q0SI0sTRwi8iNODLs5+bbv8vgz8Qy2QdxbCHnPk/6Cx6LMf7i3dqmWquFbspqFRd8QiqxStrblwxrUYZi09tkA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/shared-ini-file-loader": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-sso": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-sso/-/credential-provider-sso-3.614.0.tgz",
      "integrity": "sha512-55+gp0JY4451cWI1qXmVMFM0GQaBKiQpXv2P0xmd9P3qLDyeFUSEW8XPh0d2lb1ICr6x4s47ynXVdGCIv2mXMg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/client-sso": "3.614.0",
        "@aws-sdk/token-providers": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/shared-ini-file-loader": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-web-identity": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-web-identity/-/credential-provider-web-identity-3.609.0.tgz",
      "integrity": "sha512-U+PG8NhlYYF45zbr1km3ROtBMYqyyj/oK8NRp++UHHeuavgrP+4wJ4wQnlEaKvJBjevfo3+dlIBcaeQ7NYejWg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "peerDependencies": {
        "@aws-sdk/client-sts": "^3.609.0"
      }
    },
    "node_modules/@aws-sdk/middleware-bucket-endpoint": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-bucket-endpoint/-/middleware-bucket-endpoint-3.614.0.tgz",
      "integrity": "sha512-TqEY8KcZeZ0LIxXaqG9RSSNnDHvD8RAFP4Xenwsxqnyad0Yn7LgCoFwRByelJ0t54ROYL1/ETJleWE4U4TOXdg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-arn-parser": "3.568.0",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "@smithy/util-config-provider": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-expect-continue": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-expect-continue/-/middleware-expect-continue-3.609.0.tgz",
      "integrity": "sha512-+zeg//mSer4JZRxOB/4mUOMUJyuYPwATnIC5moBB8P8Xe+mJaVRFy8qlCtzYNj2TycnlsBPzTK0j7P1yvDh97w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-flexible-checksums": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-flexible-checksums/-/middleware-flexible-checksums-3.614.0.tgz",
      "integrity": "sha512-ZLpxVXMboDeMT7p2Kdp5m1uLVKOktkZoMgLvvbe3zbrU4Ji5IU5xVE0aa4X7H28BtuODCs6SLESnPs19bhMKlA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/crc32": "5.2.0",
        "@aws-crypto/crc32c": "5.2.0",
        "@aws-sdk/types": "3.609.0",
        "@smithy/is-array-buffer": "^3.0.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-host-header": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-host-header/-/middleware-host-header-3.609.0.tgz",
      "integrity": "sha512-iTKfo158lc4jLDfYeZmYMIBHsn8m6zX+XB6birCSNZ/rrlzAkPbGE43CNdKfvjyWdqgLMRXF+B+OcZRvqhMXPQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-location-constraint": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-location-constraint/-/middleware-location-constraint-3.609.0.tgz",
      "integrity": "sha512-xzsdoTkszGVqGVPjUmgoP7TORiByLueMHieI1fhQL888WPdqctwAx3ES6d/bA9Q/i8jnc6hs+Fjhy8UvBTkE9A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-logger": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-logger/-/middleware-logger-3.609.0.tgz",
      "integrity": "sha512-S62U2dy4jMDhDFDK5gZ4VxFdWzCtLzwbYyFZx2uvPYTECkepLUfzLic2BHg2Qvtu4QjX+oGE3P/7fwaGIsGNuQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-recursion-detection": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-recursion-detection/-/middleware-recursion-detection-3.609.0.tgz",
      "integrity": "sha512-6sewsYB7/o/nbUfA99Aa/LokM+a/u4Wpm/X2o0RxOsDtSB795ObebLJe2BxY5UssbGaWkn7LswyfvrdZNXNj1w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-sdk-s3": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-sdk-s3/-/middleware-sdk-s3-3.614.0.tgz",
      "integrity": "sha512-9fJTaiuuOfFV4FqmUEhPYzrtv7JOfYpB7q65oG3uayVH4ngWHIJkjnnX79zRhNZKdPGta+XIsnZzjEghg82ngA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-arn-parser": "3.568.0",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/signature-v4": "^3.1.2",
        "@smithy/smithy-client": "^3.1.7",
        "@smithy/types": "^3.3.0",
        "@smithy/util-config-provider": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-signing": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-signing/-/middleware-signing-3.609.0.tgz",
      "integrity": "sha512-2w3dBLjQVKIajYzokO4hduq8/0hSMUYHHmIo1Kdl+MSY8uwRBt12bLL6pyreobTcRMxizvn2ph/CQ9I1ST/WGQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/signature-v4": "^3.1.2",
        "@smithy/types": "^3.3.0",
        "@smithy/util-middleware": "^3.0.3",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-ssec": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-ssec/-/middleware-ssec-3.609.0.tgz",
      "integrity": "sha512-GZSD1s7+JswWOTamVap79QiDaIV7byJFssBW68GYjyRS5EBjNfwA/8s+6uE6g39R3ojyTbYOmvcANoZEhSULXg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-user-agent": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-user-agent/-/middleware-user-agent-3.614.0.tgz",
      "integrity": "sha512-xUxh0UPQiMTG6E31Yvu6zVYlikrIcFDKljM11CaatInzvZubGTGiX0DjpqRlfGzUNsuPc/zNrKwRP2+wypgqIw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@aws-sdk/util-endpoints": "3.614.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/region-config-resolver": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/region-config-resolver/-/region-config-resolver-3.614.0.tgz",
      "integrity": "sha512-vDCeMXvic/LU0KFIUjpC3RiSTIkkvESsEfbVHiHH0YINfl8HnEqR5rj+L8+phsCeVg2+LmYwYxd5NRz4PHxt5g==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "@smithy/util-config-provider": "^3.0.0",
        "@smithy/util-middleware": "^3.0.3",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/signature-v4-multi-region": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/signature-v4-multi-region/-/signature-v4-multi-region-3.614.0.tgz",
      "integrity": "sha512-6mW3ONW4oLzxrePznYhz7sNT9ji9Am9ufLeV722tbOVS5lArBOZ6E1oPz0uYBhisUPznWKhcLRMggt7vIJWMng==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/middleware-sdk-s3": "3.614.0",
        "@aws-sdk/types": "3.609.0",
        "@smithy/protocol-http": "^4.0.3",
        "@smithy/signature-v4": "^3.1.2",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/token-providers": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/token-providers/-/token-providers-3.614.0.tgz",
      "integrity": "sha512-okItqyY6L9IHdxqs+Z116y5/nda7rHxLvROxtAJdLavWTYDydxrZstImNgGWTeVdmc0xX2gJCI77UYUTQWnhRw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/property-provider": "^3.1.3",
        "@smithy/shared-ini-file-loader": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "peerDependencies": {
        "@aws-sdk/client-sso-oidc": "^3.614.0"
      }
    },
    "node_modules/@aws-sdk/types": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/types/-/types-3.609.0.tgz",
      "integrity": "sha512-+Tqnh9w0h2LcrUsdXyT1F8mNhXz+tVYBtP19LpeEGntmvHwa2XzvLUCWpoIAIVsHp5+HdB2X9Sn0KAtmbFXc2Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/util-arn-parser": {
      "version": "3.568.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-arn-parser/-/util-arn-parser-3.568.0.tgz",
      "integrity": "sha512-XUKJWWo+KOB7fbnPP0+g/o5Ulku/X53t7i/h+sPHr5xxYTJJ9CYnbToo95mzxe7xWvkLrsNtJ8L+MnNn9INs2w==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/util-endpoints": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-endpoints/-/util-endpoints-3.614.0.tgz",
      "integrity": "sha512-wK2cdrXHH4oz4IomV/yrGkftU9A+ITB6nFL+rxxyO78is2ifHJpFdV4aqk4LSkXYPi6CXWNru/Dqc7yiKXgJPw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/types": "^3.3.0",
        "@smithy/util-endpoints": "^2.0.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-sdk/util-locate-window": {
      "version": "3.873.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-locate-window/-/util-locate-window-3.873.0.tgz",
      "integrity": "sha512-xcVhZF6svjM5Rj89T1WzkjQmrTF6dpR2UvIHPMTnSZoNe6CixejPZ6f0JJ2kAhO8H+dUHwNBlsUgOTIKiK/Syg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/util-user-agent-browser": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-user-agent-browser/-/util-user-agent-browser-3.609.0.tgz",
      "integrity": "sha512-fojPU+mNahzQ0YHYBsx0ZIhmMA96H+ZIZ665ObU9tl+SGdbLneVZVikGve+NmHTQwHzwkFsZYYnVKAkreJLAtA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/types": "^3.3.0",
        "bowser": "^2.11.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-sdk/util-user-agent-node": {
      "version": "3.614.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-user-agent-node/-/util-user-agent-node-3.614.0.tgz",
      "integrity": "sha512-15ElZT88peoHnq5TEoEtZwoXTXRxNrk60TZNdpl/TUBJ5oNJ9Dqb5Z4ryb8ofN6nm9aFf59GVAerFDz8iUoHBA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.609.0",
        "@smithy/node-config-provider": "^3.1.4",
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "peerDependencies": {
        "aws-crt": ">=1.0.0"
      },
      "peerDependenciesMeta": {
        "aws-crt": {
          "optional": true
        }
      }
    },
    "node_modules/@aws-sdk/xml-builder": {
      "version": "3.609.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/xml-builder/-/xml-builder-3.609.0.tgz",
      "integrity": "sha512-l9XxNcA4HX98rwCC2/KoiWcmEiRfZe4G+mYwDbCFT87JIMj6GBhLDkAzr/W8KAaA2IDr8Vc6J8fZPgVulxxfMA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.0.tgz",
      "integrity": "sha512-60X7qkglvrap8mn1lh2ebxXdZYtUcpd7gsmy9kLaBJ4i/WdY8PqTSdxyA8qraikqKQK5C1KRBKXqznrVapyNaw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.3.tgz",
      "integrity": "sha512-yDBHV9kQNcr2/sUr9jghVyz9C3Y5G2zUM2H2lo+9mKv4sFgbA8s8Z9t8D1jiTkGoO/NoIfKMyKWr4s6CN23ZwQ==",
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helpers": "^7.28.3",
        "@babel/parser": "^7.28.3",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.3",
        "@babel/types": "^7.28.2",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.3.tgz",
      "integrity": "sha512-3lSpxGgvnmZznmBkCRnVREPUFJv2wrv9iAoFDvADJc0ypmdOxdUtcLeBgBJ6zE0PMeTKnxeQzyk0xTBq4Ep7zw==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.3",
        "@babel/types": "^7.28.2",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-annotate-as-pure": {
      "version": "7.27.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.27.3.tgz",
      "integrity": "sha512-fXSwMQqitTGeHLBC08Eq5yXz2m37E4pJX1qAU1+2cNedz/ifv/bVXft90VeSav5nFO61EcNgwr0aJxbyPaWBPg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.3"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-create-class-features-plugin": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.28.3.tgz",
      "integrity": "sha512-V9f6ZFIYSLNEbuGA/92uOvYsGCJNsuA8ESZ4ldc09bWk/j8H8TKiPw8Mk1eG6olpnO0ALHJmYfZvF4MEE4gajg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "@babel/helper-member-expression-to-functions": "^7.27.1",
        "@babel/helper-optimise-call-expression": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
        "@babel/traverse": "^7.28.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-create-regexp-features-plugin": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.27.1.tgz",
      "integrity": "sha512-uVDC72XVf8UbrH5qQTc18Agb8emwjTiZrQE11Nv3CuBEZmVvTwwE9CBUEvHku06gQCAyYf8Nv6ja1IN+6LMbxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "regexpu-core": "^6.2.0",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-define-polyfill-provider": {
      "version": "0.6.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.6.5.tgz",
      "integrity": "sha512-uJnGFcPsWQK8fvjgGP5LZUZZsYGIoPeRjSF5PGwrelYgq7Q15/Ft9NGFp1zglwgIv//W0uG4BevRuSJRyylZPg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "debug": "^4.4.1",
        "lodash.debounce": "^4.0.8",
        "resolve": "^1.22.10"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-member-expression-to-functions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.27.1.tgz",
      "integrity": "sha512-E5chM8eWjTp/aNoVpcbfM7mLxu9XGLWYise2eBKGQomAk/Mb4XoxyqXTZbuTohbsl8EKqdlMhnDI2CCLfcs9wA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.3.tgz",
      "integrity": "sha512-gytXUbs8k2sXS9PnQptz5o0QnpLL51SwASIORY6XaBKF88nsOT0Zw9szLqlSGQDP/4TljBAD5y98p2U1fqkdsw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-optimise-call-expression": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.27.1.tgz",
      "integrity": "sha512-URMGH08NzYFhubNSGJrpUEphGKQwMQYBySzat5cAByY1/YgIRkULnIy3tAMeszlL/so2HbeilYloUmSpd7GdVw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-remap-async-to-generator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.27.1.tgz",
      "integrity": "sha512-7fiA521aVw8lSPeI4ZOD3vRFkoqkJcS+z4hFo82bFSH/2tNd6eJ5qCVMS5OzDmZh/kaHQeBaeyxK6wljcPtveA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-wrap-function": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-replace-supers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.27.1.tgz",
      "integrity": "sha512-7EHz6qDZc8RYS5ElPoShMheWvEgERonFCs7IAonWLLUTXW59DP14bCZt89/GKyreYn8g3S83m21FelHKbeDCKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-member-expression-to-functions": "^7.27.1",
        "@babel/helper-optimise-call-expression": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-skip-transparent-expression-wrappers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-skip-transparent-expression-wrappers/-/helper-skip-transparent-expression-wrappers-7.27.1.tgz",
      "integrity": "sha512-Tub4ZKEXqbPjXgWLl2+3JpQAYBJ8+ikpQ2Ocj/q/r0LwE3UhENh7EUabyHjz2kCEsrRY83ew2DQdHluuiDQFzg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-wrap-function": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.28.3.tgz",
      "integrity": "sha512-zdf983tNfLZFletc0RRXYrHrucBEg95NIFMkn6K9dbeMYnsgHaSBGcQqdsCSStG2PYwRre0Qc2NNSCXbG+xc6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.3",
        "@babel/types": "^7.28.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.3.tgz",
      "integrity": "sha512-PTNtvUQihsAsDHMOP5pfobP8C6CM4JWXmP8DrEIt46c3r2bf87Ua1zoqevsMo9g+tWDwgWrFP5EIxuBx5RudAw==",
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.3.tgz",
      "integrity": "sha512-7+Ey1mAgYqFAx2h0RuoxcQT5+MlG3GTV0TQrgr7/ZliKsm/MNDxVVutlWaziMq7wJNAz8MTqz55XLpWvva6StA==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-firefox-class-in-computed-class-key": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-firefox-class-in-computed-class-key/-/plugin-bugfix-firefox-class-in-computed-class-key-7.27.1.tgz",
      "integrity": "sha512-QPG3C9cCVRQLxAVwmefEmwdTanECuUBMQZ/ym5kiw3XKCGA7qkuQLcjWWHcrD/GKbn/WmJwaezfuuAOcyKlRPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-safari-class-field-initializer-scope": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-class-field-initializer-scope/-/plugin-bugfix-safari-class-field-initializer-scope-7.27.1.tgz",
      "integrity": "sha512-qNeq3bCKnGgLkEXUuFry6dPlGfCdQNZbn7yUAPCInwAJHMU7THJfrBSozkcWq5sNM6RcF3S8XyQL2A52KNR9IA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.27.1.tgz",
      "integrity": "sha512-g4L7OYun04N1WyqMNjldFwlfPCLVkgB54A/YCXICZYBsvJJE3kByKv9c9+R/nAfmIfjl2rKYLNyMHboYbZaWaA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.27.1.tgz",
      "integrity": "sha512-oO02gcONcD5O1iTLi/6frMJBIwWEHceWGSGqrpCmEL8nogiS6J9PBlE48CaK20/Jx1LuRml9aDftLgdjXT8+Cw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
        "@babel/plugin-transform-optional-chaining": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.13.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/-/plugin-bugfix-v8-static-class-fields-redefine-readonly-7.28.3.tgz",
      "integrity": "sha512-b6YTX108evsvE4YgWyQ921ZAFFQm3Bn+CA3+ZXlNVnPhx+UfsVURoPjfGAPCjBgrqo30yX/C2nZGX96DxvR9Iw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-proposal-private-property-in-object": {
      "version": "7.21.0-placeholder-for-preset-env.2",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-property-in-object/-/plugin-proposal-private-property-in-object-7.21.0-placeholder-for-preset-env.2.tgz",
      "integrity": "sha512-SOSkfJDddaM7mak6cPEpswyTRnuRltl429hMraQEglW+OkovnCzsiszTmsrlY//qLFjCpQDFRvjdm2wA5pPm9w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-assertions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.27.1.tgz",
      "integrity": "sha512-UT/Jrhw57xg4ILHLFnzFpPDlMbcdEicaAtjPQpbj9wa8T4r5KVWCimHcL/460g8Ht0DMxDyjsLgiWSkVjnwPFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-attributes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.27.1.tgz",
      "integrity": "sha512-oFT0FrKHgF53f4vOsZGi2Hh3I35PfSmVs4IBFLFj4dnafP+hIWDLg3VyKmUHfLoLHlyxY4C7DGtmHuJgn+IGww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-jsx": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-jsx/-/plugin-syntax-jsx-7.27.1.tgz",
      "integrity": "sha512-y8YTNIeKoyhGd9O0Jiyzyyqk8gdjnumGTQPsz0xOZOQ2RmkVJeZ1vmmfIvFEKqucBG6axJGBZDE/7iI5suUI/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-typescript": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.27.1.tgz",
      "integrity": "sha512-xfYCBMxveHrRMnAWl1ZlPXOZjzkN82THFvLhQhFXFt81Z5HnN+EtUkZhv/zcKpmT3fzmWZB0ywiBrbC3vogbwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-unicode-sets-regex": {
      "version": "7.18.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-unicode-sets-regex/-/plugin-syntax-unicode-sets-regex-7.18.6.tgz",
      "integrity": "sha512-727YkEAPwSIQTv5im8QHz3upqp92JTWhidIC81Tdx4VJYIte/VndKf1qKrfnnhPLiPghStWfvC/iFaMCQu7Nqg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
        "@babel/helper-plugin-utils": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-arrow-functions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.27.1.tgz",
      "integrity": "sha512-8Z4TGic6xW70FKThA5HYEKKyBpOOsucTOD1DjU3fZxDg+K3zBJcXMFnt/4yQiZnf5+MiOMSXQ9PaEK/Ilh1DeA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-async-generator-functions": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-generator-functions/-/plugin-transform-async-generator-functions-7.28.0.tgz",
      "integrity": "sha512-BEOdvX4+M765icNPZeidyADIvQ1m1gmunXufXxvRESy/jNNyfovIqUyE7MVgGBjWktCoJlzvFA1To2O4ymIO3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-remap-async-to-generator": "^7.27.1",
        "@babel/traverse": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-async-to-generator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.27.1.tgz",
      "integrity": "sha512-NREkZsZVJS4xmTr8qzE5y8AfIPqsdQfRuUiLRTEzb7Qii8iFWCyDKaUV2c0rCuh4ljDZ98ALHP/PetiBV2nddA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-remap-async-to-generator": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-block-scoped-functions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.27.1.tgz",
      "integrity": "sha512-cnqkuOtZLapWYZUYM5rVIdv1nXYuFVIltZ6ZJ7nIj585QsjKM5dhL2Fu/lICXZ1OyIAFc7Qy+bvDAtTXqGrlhg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-block-scoping": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.28.0.tgz",
      "integrity": "sha512-gKKnwjpdx5sER/wl0WN0efUBFzF/56YZO0RJrSYP4CljXnP31ByY7fol89AzomdlLNzI36AvOTmYHsnZTCkq8Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-class-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-properties/-/plugin-transform-class-properties-7.27.1.tgz",
      "integrity": "sha512-D0VcalChDMtuRvJIu3U/fwWjf8ZMykz5iZsg77Nuj821vCKI3zCyRLwRdWbsuJ/uRwZhZ002QtCqIkwC/ZkvbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-class-static-block": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-static-block/-/plugin-transform-class-static-block-7.28.3.tgz",
      "integrity": "sha512-LtPXlBbRoc4Njl/oh1CeD/3jC+atytbnf/UqLoqTDcEYGUPj022+rvfkbDYieUrSj3CaV4yHDByPE+T2HwfsJg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.28.3",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.12.0"
      }
    },
    "node_modules/@babel/plugin-transform-classes": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.28.3.tgz",
      "integrity": "sha512-DoEWC5SuxuARF2KdKmGUq3ghfPMO6ZzR12Dnp5gubwbeWJo4dbNWXJPVlwvh4Zlq6Z7YVvL8VFxeSOJgjsx4Sg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-globals": "^7.28.0",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-computed-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.27.1.tgz",
      "integrity": "sha512-lj9PGWvMTVksbWiDT2tW68zGS/cyo4AkZ/QTp0sQT0mjPopCmrSkzxeXkznjqBxzDI6TclZhOJbBmbBLjuOZUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/template": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-destructuring": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.28.0.tgz",
      "integrity": "sha512-v1nrSMBiKcodhsyJ4Gf+Z0U/yawmJDBOTpEB3mcQY52r9RIyPneGyAS/yM6seP/8I+mWI3elOMtT5dB8GJVs+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-dotall-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.27.1.tgz",
      "integrity": "sha512-gEbkDVGRvjj7+T1ivxrfgygpT7GUd4vmODtYpbs0gZATdkX8/iSnOtZSxiZnsgm1YjTgjI6VKBGSJJevkrclzw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-duplicate-keys": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.27.1.tgz",
      "integrity": "sha512-MTyJk98sHvSs+cvZ4nOauwTTG1JeonDjSGvGGUNHreGQns+Mpt6WX/dVzWBHgg+dYZhkC4X+zTDfkTU+Vy9y7Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-duplicate-named-capturing-groups-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-named-capturing-groups-regex/-/plugin-transform-duplicate-named-capturing-groups-regex-7.27.1.tgz",
      "integrity": "sha512-hkGcueTEzuhB30B3eJCbCYeCaaEQOmQR0AdvzpD4LoN0GXMWzzGSuRrxR2xTnCrvNbVwK9N6/jQ92GSLfiZWoQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-dynamic-import": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dynamic-import/-/plugin-transform-dynamic-import-7.27.1.tgz",
      "integrity": "sha512-MHzkWQcEmjzzVW9j2q8LGjwGWpG2mjwaaB0BNQwst3FIjqsg8Ct/mIZlvSPJvfi9y2AC8mi/ktxbFVL9pZ1I4A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-explicit-resource-management": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-explicit-resource-management/-/plugin-transform-explicit-resource-management-7.28.0.tgz",
      "integrity": "sha512-K8nhUcn3f6iB+P3gwCv/no7OdzOZQcKchW6N389V6PD8NUWKZHzndOd9sPDVbMoBsbmjMqlB4L9fm+fEFNVlwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-exponentiation-operator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.27.1.tgz",
      "integrity": "sha512-uspvXnhHvGKf2r4VVtBpeFnuDWsJLQ6MF6lGJLC89jBR1uoVeqM416AZtTuhTezOfgHicpJQmoD5YUakO/YmXQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-export-namespace-from": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-export-namespace-from/-/plugin-transform-export-namespace-from-7.27.1.tgz",
      "integrity": "sha512-tQvHWSZ3/jH2xuq/vZDy0jNn+ZdXJeM8gHvX4lnJmsc3+50yPlWdZXIc5ay+umX+2/tJIqHqiEqcJvxlmIvRvQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-for-of": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.27.1.tgz",
      "integrity": "sha512-BfbWFFEJFQzLCQ5N8VocnCtA8J1CLkNTe2Ms2wocj75dd6VpiqS5Z5quTYcUoo4Yq+DN0rtikODccuv7RU81sw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-function-name": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.27.1.tgz",
      "integrity": "sha512-1bQeydJF9Nr1eBCMMbC+hdwmRlsv5XYOMu03YSWFwNs0HsAmtSxxF1fyuYPqemVldVyFmlCU7w8UE14LupUSZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-json-strings": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-json-strings/-/plugin-transform-json-strings-7.27.1.tgz",
      "integrity": "sha512-6WVLVJiTjqcQauBhn1LkICsR2H+zm62I3h9faTDKt1qP4jn2o72tSvqMwtGFKGTpojce0gJs+76eZ2uCHRZh0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.27.1.tgz",
      "integrity": "sha512-0HCFSepIpLTkLcsi86GG3mTUzxV5jpmbv97hTETW3yzrAij8aqlD36toB1D0daVFJM8NK6GvKO0gslVQmm+zZA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-logical-assignment-operators": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-logical-assignment-operators/-/plugin-transform-logical-assignment-operators-7.27.1.tgz",
      "integrity": "sha512-SJvDs5dXxiae4FbSL1aBJlG4wvl594N6YEVVn9e3JGulwioy6z3oPjx/sQBO3Y4NwUu5HNix6KJ3wBZoewcdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-member-expression-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.27.1.tgz",
      "integrity": "sha512-hqoBX4dcZ1I33jCSWcXrP+1Ku7kdqXf1oeah7ooKOIiAdKQ+uqftgCFNOSzA5AMS2XIHEYeGFg4cKRCdpxzVOQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-amd": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.27.1.tgz",
      "integrity": "sha512-iCsytMg/N9/oFq6n+gFTvUYDZQOMK5kEdeYxmxt91fcJGycfxVP9CnrxoliM0oumFERba2i8ZtwRUCMhvP1LnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-commonjs": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.27.1.tgz",
      "integrity": "sha512-OJguuwlTYlN0gBZFRPqwOGNWssZjfIUdS7HMYtN8c1KmwpwHFBwTeFZrg9XZa+DFTitWOW5iTAG7tyCUPsCCyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-systemjs": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.27.1.tgz",
      "integrity": "sha512-w5N1XzsRbc0PQStASMksmUeqECuzKuTJer7kFagK8AXgpCMkeDMO5S+aaFb7A51ZYDF7XI34qsTX+fkHiIm5yA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-umd": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.27.1.tgz",
      "integrity": "sha512-iQBE/xC5BV1OxJbp6WG7jq9IWiD+xxlZhLrdwpPkTX3ydmXdvoCpyfJN7acaIBZaOqTfr76pgzqBJflNbeRK+w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-named-capturing-groups-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.27.1.tgz",
      "integrity": "sha512-SstR5JYy8ddZvD6MhV0tM/j16Qds4mIpJTOd1Yu9J9pJjH93bxHECF7pgtc28XvkzTD6Pxcm/0Z73Hvk7kb3Ng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-new-target": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.27.1.tgz",
      "integrity": "sha512-f6PiYeqXQ05lYq3TIfIDu/MtliKUbNwkGApPUvyo6+tc7uaR4cPjPe7DFPr15Uyycg2lZU6btZ575CuQoYh7MQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-nullish-coalescing-operator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-nullish-coalescing-operator/-/plugin-transform-nullish-coalescing-operator-7.27.1.tgz",
      "integrity": "sha512-aGZh6xMo6q9vq1JGcw58lZ1Z0+i0xB2x0XaauNIUXd6O1xXc3RwoWEBlsTQrY4KQ9Jf0s5rgD6SiNkaUdJegTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-numeric-separator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-numeric-separator/-/plugin-transform-numeric-separator-7.27.1.tgz",
      "integrity": "sha512-fdPKAcujuvEChxDBJ5c+0BTaS6revLV7CJL08e4m3de8qJfNIuCc2nc7XJYOjBoTMJeqSmwXJ0ypE14RCjLwaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-object-rest-spread": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-rest-spread/-/plugin-transform-object-rest-spread-7.28.0.tgz",
      "integrity": "sha512-9VNGikXxzu5eCiQjdE4IZn8sb9q7Xsk5EXLDBKUYg1e/Tve8/05+KJEtcxGxAgCY5t/BpKQM+JEL/yT4tvgiUA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.0",
        "@babel/plugin-transform-parameters": "^7.27.7",
        "@babel/traverse": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-object-super": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.27.1.tgz",
      "integrity": "sha512-SFy8S9plRPbIcxlJ8A6mT/CxFdJx/c04JEctz4jf8YZaVS2px34j7NXRrlGlHkN/M2gnpL37ZpGRGVFLd3l8Ng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-optional-catch-binding": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-catch-binding/-/plugin-transform-optional-catch-binding-7.27.1.tgz",
      "integrity": "sha512-txEAEKzYrHEX4xSZN4kJ+OfKXFVSWKB2ZxM9dpcE3wT7smwkNmXo5ORRlVzMVdJbD+Q8ILTgSD7959uj+3Dm3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-optional-chaining": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-chaining/-/plugin-transform-optional-chaining-7.27.1.tgz",
      "integrity": "sha512-BQmKPPIuc8EkZgNKsv0X4bPmOoayeu4F1YCwx2/CfmDSXDbp7GnzlUH+/ul5VGfRg1AoFPsrIThlEBj2xb4CAg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-parameters": {
      "version": "7.27.7",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.27.7.tgz",
      "integrity": "sha512-qBkYTYCb76RRxUM6CcZA5KRu8K4SM8ajzVeUgVdMVO9NN9uI/GaVmBg/WKJJGnNokV9SY8FxNOVWGXzqzUidBg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-private-methods": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-methods/-/plugin-transform-private-methods-7.27.1.tgz",
      "integrity": "sha512-10FVt+X55AjRAYI9BrdISN9/AQWHqldOeZDUoLyif1Kn05a56xVBXb8ZouL8pZ9jem8QpXaOt8TS7RHUIS+GPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-private-property-in-object": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-property-in-object/-/plugin-transform-private-property-in-object-7.27.1.tgz",
      "integrity": "sha512-5J+IhqTi1XPa0DXF83jYOaARrX+41gOewWbkPyjMNRDqgOCqdffGh8L3f/Ek5utaEBZExjSAzcyjmV9SSAWObQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-property-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.27.1.tgz",
      "integrity": "sha512-oThy3BCuCha8kDZ8ZkgOg2exvPYUlprMukKQXI1r1pJ47NCvxfkEy8vK+r/hT9nF0Aa4H1WUPZZjHTFtAhGfmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-display-name": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-display-name/-/plugin-transform-react-display-name-7.28.0.tgz",
      "integrity": "sha512-D6Eujc2zMxKjfa4Zxl4GHMsmhKKZ9VpcqIchJLvwTxad9zWIYulwYItBovpDOoNLISpcZSXoDJ5gaGbQUDqViA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx/-/plugin-transform-react-jsx-7.27.1.tgz",
      "integrity": "sha512-2KH4LWGSrJIkVf5tSiBFYuXDAoWRq2MMwgivCf+93dd0GQi8RXLjKA/0EvRnVV5G0hrHczsquXuD01L8s6dmBw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/plugin-syntax-jsx": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-development": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-development/-/plugin-transform-react-jsx-development-7.27.1.tgz",
      "integrity": "sha512-ykDdF5yI4f1WrAolLqeF3hmYU12j9ntLQl/AOG1HAS21jxyg1Q0/J/tpREuYLfatGdGmXp/3yS0ZA76kOlVq9Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/plugin-transform-react-jsx": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-pure-annotations": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-pure-annotations/-/plugin-transform-react-pure-annotations-7.27.1.tgz",
      "integrity": "sha512-JfuinvDOsD9FVMTHpzA/pBLisxpv1aSf+OIV8lgH3MuWrks19R27e6a6DipIg4aX1Zm9Wpb04p8wljfKrVSnPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-regenerator": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.28.3.tgz",
      "integrity": "sha512-K3/M/a4+ESb5LEldjQb+XSrpY0nF+ZBFlTCbSnKaYAMfD8v33O6PMs4uYnOk19HlcsI8WMu3McdFPTiQHF/1/A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-regexp-modifiers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regexp-modifiers/-/plugin-transform-regexp-modifiers-7.27.1.tgz",
      "integrity": "sha512-TtEciroaiODtXvLZv4rmfMhkCv8jx3wgKpL68PuiPh2M4fvz5jhsA7697N1gMvkvr/JTF13DrFYyEbY9U7cVPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-reserved-words": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.27.1.tgz",
      "integrity": "sha512-V2ABPHIJX4kC7HegLkYoDpfg9PVmuWy/i6vUM5eGK22bx4YVFD3M5F0QQnWQoDs6AGsUWTVOopBiMFQgHaSkVw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-shorthand-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.27.1.tgz",
      "integrity": "sha512-N/wH1vcn4oYawbJ13Y/FxcQrWk63jhfNa7jef0ih7PHSIHX2LB7GWE1rkPrOnka9kwMxb6hMl19p7lidA+EHmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-spread": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.27.1.tgz",
      "integrity": "sha512-kpb3HUqaILBJcRFVhFUs6Trdd4mkrzcGXss+6/mxUd273PfbWqSDHRzMT2234gIg2QYfAjvXLSquP1xECSg09Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-sticky-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.27.1.tgz",
      "integrity": "sha512-lhInBO5bi/Kowe2/aLdBAawijx+q1pQzicSgnkB6dUPc1+RC8QmJHKf2OjvU+NZWitguJHEaEmbV6VWEouT58g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-template-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.27.1.tgz",
      "integrity": "sha512-fBJKiV7F2DxZUkg5EtHKXQdbsbURW3DZKQUWphDum0uRP6eHGGa/He9mc0mypL680pb+e/lDIthRohlv8NCHkg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-typeof-symbol": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.27.1.tgz",
      "integrity": "sha512-RiSILC+nRJM7FY5srIyc4/fGIwUhyDuuBSdWn4y6yT6gm652DpCHZjIipgn6B7MQ1ITOUnAKWixEUjQRIBIcLw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-typescript": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typescript/-/plugin-transform-typescript-7.28.0.tgz",
      "integrity": "sha512-4AEiDEBPIZvLQaWlc9liCavE0xRM0dNca41WtBeM3jgFptfUOSG9z0uteLhq6+3rq+WB6jIvUwKDTpXEHPJ2Vg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
        "@babel/plugin-syntax-typescript": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-escapes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.27.1.tgz",
      "integrity": "sha512-Ysg4v6AmF26k9vpfFuTZg8HRfVWzsh1kVfowA23y9j/Gu6dOuahdUVhkLqpObp3JIv27MLSii6noRnuKN8H0Mg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-property-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-property-regex/-/plugin-transform-unicode-property-regex-7.27.1.tgz",
      "integrity": "sha512-uW20S39PnaTImxp39O5qFlHLS9LJEmANjMG7SxIhap8rCHqu0Ik+tLEPX5DKmHn6CsWQ7j3lix2tFOa5YtL12Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.27.1.tgz",
      "integrity": "sha512-xvINq24TRojDuyt6JGtHmkVkrfVV3FPT16uytxImLeBZqW3/H52yN+kM1MGuyPkIQxrzKwPHs5U/MP3qKyzkGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-sets-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-sets-regex/-/plugin-transform-unicode-sets-regex-7.27.1.tgz",
      "integrity": "sha512-EtkOujbc4cgvb0mlpQefi4NTPBzhSIevblFevACNLUspmrALgmEBdL/XfnyyITfd8fKBZrZys92zOWcik7j9Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/preset-env": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.28.3.tgz",
      "integrity": "sha512-ROiDcM+GbYVPYBOeCR6uBXKkQpBExLl8k9HO1ygXEyds39j+vCCsjmj7S8GOniZQlEs81QlkdJZe76IpLSiqpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.0",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "@babel/plugin-bugfix-firefox-class-in-computed-class-key": "^7.27.1",
        "@babel/plugin-bugfix-safari-class-field-initializer-scope": "^7.27.1",
        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.27.1",
        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.27.1",
        "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": "^7.28.3",
        "@babel/plugin-proposal-private-property-in-object": "7.21.0-placeholder-for-preset-env.2",
        "@babel/plugin-syntax-import-assertions": "^7.27.1",
        "@babel/plugin-syntax-import-attributes": "^7.27.1",
        "@babel/plugin-syntax-unicode-sets-regex": "^7.18.6",
        "@babel/plugin-transform-arrow-functions": "^7.27.1",
        "@babel/plugin-transform-async-generator-functions": "^7.28.0",
        "@babel/plugin-transform-async-to-generator": "^7.27.1",
        "@babel/plugin-transform-block-scoped-functions": "^7.27.1",
        "@babel/plugin-transform-block-scoping": "^7.28.0",
        "@babel/plugin-transform-class-properties": "^7.27.1",
        "@babel/plugin-transform-class-static-block": "^7.28.3",
        "@babel/plugin-transform-classes": "^7.28.3",
        "@babel/plugin-transform-computed-properties": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.0",
        "@babel/plugin-transform-dotall-regex": "^7.27.1",
        "@babel/plugin-transform-duplicate-keys": "^7.27.1",
        "@babel/plugin-transform-duplicate-named-capturing-groups-regex": "^7.27.1",
        "@babel/plugin-transform-dynamic-import": "^7.27.1",
        "@babel/plugin-transform-explicit-resource-management": "^7.28.0",
        "@babel/plugin-transform-exponentiation-operator": "^7.27.1",
        "@babel/plugin-transform-export-namespace-from": "^7.27.1",
        "@babel/plugin-transform-for-of": "^7.27.1",
        "@babel/plugin-transform-function-name": "^7.27.1",
        "@babel/plugin-transform-json-strings": "^7.27.1",
        "@babel/plugin-transform-literals": "^7.27.1",
        "@babel/plugin-transform-logical-assignment-operators": "^7.27.1",
        "@babel/plugin-transform-member-expression-literals": "^7.27.1",
        "@babel/plugin-transform-modules-amd": "^7.27.1",
        "@babel/plugin-transform-modules-commonjs": "^7.27.1",
        "@babel/plugin-transform-modules-systemjs": "^7.27.1",
        "@babel/plugin-transform-modules-umd": "^7.27.1",
        "@babel/plugin-transform-named-capturing-groups-regex": "^7.27.1",
        "@babel/plugin-transform-new-target": "^7.27.1",
        "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1",
        "@babel/plugin-transform-numeric-separator": "^7.27.1",
        "@babel/plugin-transform-object-rest-spread": "^7.28.0",
        "@babel/plugin-transform-object-super": "^7.27.1",
        "@babel/plugin-transform-optional-catch-binding": "^7.27.1",
        "@babel/plugin-transform-optional-chaining": "^7.27.1",
        "@babel/plugin-transform-parameters": "^7.27.7",
        "@babel/plugin-transform-private-methods": "^7.27.1",
        "@babel/plugin-transform-private-property-in-object": "^7.27.1",
        "@babel/plugin-transform-property-literals": "^7.27.1",
        "@babel/plugin-transform-regenerator": "^7.28.3",
        "@babel/plugin-transform-regexp-modifiers": "^7.27.1",
        "@babel/plugin-transform-reserved-words": "^7.27.1",
        "@babel/plugin-transform-shorthand-properties": "^7.27.1",
        "@babel/plugin-transform-spread": "^7.27.1",
        "@babel/plugin-transform-sticky-regex": "^7.27.1",
        "@babel/plugin-transform-template-literals": "^7.27.1",
        "@babel/plugin-transform-typeof-symbol": "^7.27.1",
        "@babel/plugin-transform-unicode-escapes": "^7.27.1",
        "@babel/plugin-transform-unicode-property-regex": "^7.27.1",
        "@babel/plugin-transform-unicode-regex": "^7.27.1",
        "@babel/plugin-transform-unicode-sets-regex": "^7.27.1",
        "@babel/preset-modules": "0.1.6-no-external-plugins",
        "babel-plugin-polyfill-corejs2": "^0.4.14",
        "babel-plugin-polyfill-corejs3": "^0.13.0",
        "babel-plugin-polyfill-regenerator": "^0.6.5",
        "core-js-compat": "^3.43.0",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/preset-modules": {
      "version": "0.1.6-no-external-plugins",
      "resolved": "https://registry.npmjs.org/@babel/preset-modules/-/preset-modules-0.1.6-no-external-plugins.tgz",
      "integrity": "sha512-HrcgcIESLm9aIR842yhJ5RWan/gebQUJ6E/E5+rf0y9o6oj7w0Br+sWuL6kEQ/o/AdfvR1Je9jG18/gnpwjEyA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@babel/types": "^7.4.4",
        "esutils": "^2.0.2"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/@babel/preset-react": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/preset-react/-/preset-react-7.27.1.tgz",
      "integrity": "sha512-oJHWh2gLhU9dW9HHr42q0cI0/iHHXTLGe39qvpAZZzagHy0MzYLCnCVV0symeRvzmjHyVU7mw2K06E6u/JwbhA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "@babel/plugin-transform-react-display-name": "^7.27.1",
        "@babel/plugin-transform-react-jsx": "^7.27.1",
        "@babel/plugin-transform-react-jsx-development": "^7.27.1",
        "@babel/plugin-transform-react-pure-annotations": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/preset-typescript": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/preset-typescript/-/preset-typescript-7.27.1.tgz",
      "integrity": "sha512-l7WfQfX0WK4M0v2RudjuQK4u99BS6yLHYEmdtVPP7lKV013zr9DygFuWNlnbvQ9LR+LS0Egz/XAvGx5U9MX0fQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "@babel/plugin-syntax-jsx": "^7.27.1",
        "@babel/plugin-transform-modules-commonjs": "^7.27.1",
        "@babel/plugin-transform-typescript": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.3.tgz",
      "integrity": "sha512-9uIQ10o0WGdpP6GDhXcdOJPJuDgFtIDtN/9+ArJQ2NAfAmiuhTQdzkaTGR33v43GYS2UrSA0eX2pPPHoFVvpxA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.3.tgz",
      "integrity": "sha512-7w4kZYHneL3A6NP2nxzHvT3HCZ7puDZZjFMqDpBPECub79sTtSO5CGXDkKrTQq8ksAwfD/XI2MRFX23njdDaIQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.3",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.2",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.2",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.2.tgz",
      "integrity": "sha512-ruv7Ae4J5dUYULmeXw1gmb7rYRz57OWCPM57pHojnLq/3Z1CK2lNSLTCVjxVk1F/TZHwOZZrOWi0ur95BbLxNQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@fast-csv/format": {
      "version": "4.3.5",
      "resolved": "https://registry.npmjs.org/@fast-csv/format/-/format-4.3.5.tgz",
      "integrity": "sha512-8iRn6QF3I8Ak78lNAa+Gdl5MJJBM5vRHivFtMRUWINdevNo00K7OXxS2PshawLKTejVwieIlPmK5YlLu6w4u8A==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "^14.0.1",
        "lodash.escaperegexp": "^4.1.2",
        "lodash.isboolean": "^3.0.3",
        "lodash.isequal": "^4.5.0",
        "lodash.isfunction": "^3.0.9",
        "lodash.isnil": "^4.0.0"
      }
    },
    "node_modules/@fast-csv/format/node_modules/@types/node": {
      "version": "14.18.63",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.18.63.tgz",
      "integrity": "sha512-fAtCfv4jJg+ExtXhvCkCqUKZ+4ok/JQk01qDKhL5BDDoS3AxKXhV5/MAVUZyQnSEd2GT92fkgZl0pz0Q0AzcIQ==",
      "license": "MIT"
    },
    "node_modules/@fast-csv/parse": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/@fast-csv/parse/-/parse-4.3.6.tgz",
      "integrity": "sha512-uRsLYksqpbDmWaSmzvJcuApSEe38+6NQZBUsuAyMZKqHxH0g1wcJgsKUvN3WC8tewaqFjBMMGrkHmC+T7k8LvA==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "^14.0.1",
        "lodash.escaperegexp": "^4.1.2",
        "lodash.groupby": "^4.6.0",
        "lodash.isfunction": "^3.0.9",
        "lodash.isnil": "^4.0.0",
        "lodash.isundefined": "^3.0.1",
        "lodash.uniq": "^4.5.0"
      }
    },
    "node_modules/@fast-csv/parse/node_modules/@types/node": {
      "version": "14.18.63",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.18.63.tgz",
      "integrity": "sha512-fAtCfv4jJg+ExtXhvCkCqUKZ+4ok/JQk01qDKhL5BDDoS3AxKXhV5/MAVUZyQnSEd2GT92fkgZl0pz0Q0AzcIQ==",
      "license": "MIT"
    },
    "node_modules/@google/genai": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/@google/genai/-/genai-1.15.0.tgz",
      "integrity": "sha512-4CSW+hRTESWl3xVtde7pkQ3E+dDFhDq+m4ztmccRctZfx1gKy3v0M9STIMGk6Nq0s6O2uKMXupOZQ1JGorXVwQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "google-auth-library": "^9.14.2",
        "ws": "^8.18.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "@modelcontextprotocol/sdk": "^1.11.0"
      },
      "peerDependenciesMeta": {
        "@modelcontextprotocol/sdk": {
          "optional": true
        }
      }
    },
    "node_modules/@google/generative-ai": {
      "version": "0.24.1",
      "resolved": "https://registry.npmjs.org/@google/generative-ai/-/generative-ai-0.24.1.tgz",
      "integrity": "sha512-MqO+MLfM6kjxcKoy0p1wRzG3b4ZZXtPI+z2IE26UogS2Cm/XHO+7gGRBh6gcJsOiIVoH93UwKvW4HdgiOZCy9Q==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.30",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.30.tgz",
      "integrity": "sha512-GQ7Nw5G2lTu/BtHTKfXhKHok2WGetd4XYcVKGx00SjAk8GMwgJM3zr6zORiPGuOE+/vkc90KtTosSSvaCjKb2Q==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@mongodb-js/saslprep": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@mongodb-js/saslprep/-/saslprep-1.3.0.tgz",
      "integrity": "sha512-zlayKCsIjYb7/IdfqxorK5+xUMyi4vOKcFy10wKJYc63NSdKI8mNME+uJqfatkPmOSMMUiojrL58IePKBm3gvQ==",
      "license": "MIT",
      "dependencies": {
        "sparse-bitfield": "^3.0.3"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.27",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz",
      "integrity": "sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==",
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.48.0.tgz",
      "integrity": "sha512-aVzKH922ogVAWkKiyKXorjYymz2084zrhrZRXtLrA5eEx5SO8Dj0c/4FpCHZyn7MKzhW2pW4tK28vVr+5oQ2xw==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.48.0.tgz",
      "integrity": "sha512-diOdQuw43xTa1RddAFbhIA8toirSzFMcnIg8kvlzRbK26xqEnKJ/vqQnghTAajy2Dcy42v+GMPMo6jq67od+Dw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.48.0.tgz",
      "integrity": "sha512-QhR2KA18fPlJWFefySJPDYZELaVqIUVnYgAOdtJ+B/uH96CFg2l1TQpX19XpUMWUqMyIiyY45wje8K6F4w4/CA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.48.0.tgz",
      "integrity": "sha512-Q9RMXnQVJ5S1SYpNSTwXDpoQLgJ/fbInWOyjbCnnqTElEyeNvLAB3QvG5xmMQMhFN74bB5ZZJYkKaFPcOG8sGg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.48.0.tgz",
      "integrity": "sha512-3jzOhHWM8O8PSfyft+ghXZfBkZawQA0PUGtadKYxFqpcYlOYjTi06WsnYBsbMHLawr+4uWirLlbhcYLHDXR16w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.48.0.tgz",
      "integrity": "sha512-NcD5uVUmE73C/TPJqf78hInZmiSBsDpz3iD5MF/BuB+qzm4ooF2S1HfeTChj5K4AV3y19FFPgxonsxiEpy8v/A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.48.0.tgz",
      "integrity": "sha512-JWnrj8qZgLWRNHr7NbpdnrQ8kcg09EBBq8jVOjmtlB3c8C6IrynAJSMhMVGME4YfTJzIkJqvSUSVJRqkDnu/aA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.48.0.tgz",
      "integrity": "sha512-9xu92F0TxuMH0tD6tG3+GtngwdgSf8Bnz+YcsPG91/r5Vgh5LNofO48jV55priA95p3c92FLmPM7CvsVlnSbGQ==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.48.0.tgz",
      "integrity": "sha512-NLtvJB5YpWn7jlp1rJiY0s+G1Z1IVmkDuiywiqUhh96MIraC0n7XQc2SZ1CZz14shqkM+XN2UrfIo7JB6UufOA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.48.0.tgz",
      "integrity": "sha512-QJ4hCOnz2SXgCh+HmpvZkM+0NSGcZACyYS8DGbWn2PbmA0e5xUk4bIP8eqJyNXLtyB4gZ3/XyvKtQ1IFH671vQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.48.0.tgz",
      "integrity": "sha512-Pk0qlGJnhILdIC5zSKQnprFjrGmjfDM7TPZ0FKJxRkoo+kgMRAg4ps1VlTZf8u2vohSicLg7NP+cA5qE96PaFg==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.48.0.tgz",
      "integrity": "sha512-/dNFc6rTpoOzgp5GKoYjT6uLo8okR/Chi2ECOmCZiS4oqh3mc95pThWma7Bgyk6/WTEvjDINpiBCuecPLOgBLQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.48.0.tgz",
      "integrity": "sha512-YBwXsvsFI8CVA4ej+bJF2d9uAeIiSkqKSPQNn0Wyh4eMDY4wxuSp71BauPjQNCKK2tD2/ksJ7uhJ8X/PVY9bHQ==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.48.0.tgz",
      "integrity": "sha512-FI3Rr2aGAtl1aHzbkBIamsQyuauYtTF9SDUJ8n2wMXuuxwchC3QkumZa1TEXYIv/1AUp1a25Kwy6ONArvnyeVQ==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.48.0.tgz",
      "integrity": "sha512-Dx7qH0/rvNNFmCcIRe1pyQ9/H0XO4v/f0SDoafwRYwc2J7bJZ5N4CHL/cdjamISZ5Cgnon6iazAVRFlxSoHQnQ==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.48.0.tgz",
      "integrity": "sha512-GUdZKTeKBq9WmEBzvFYuC88yk26vT66lQV8D5+9TgkfbewhLaTHRNATyzpQwwbHIfJvDJ3N9WJ90wK/uR3cy3Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.48.0.tgz",
      "integrity": "sha512-ao58Adz/v14MWpQgYAb4a4h3fdw73DrDGtaiF7Opds5wNyEQwtO6M9dBh89nke0yoZzzaegq6J/EXs7eBebG8A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.48.0.tgz",
      "integrity": "sha512-kpFno46bHtjZVdRIOxqaGeiABiToo2J+st7Yce+aiAoo1H0xPi2keyQIP04n2JjDVuxBN6bSz9R6RdTK5hIppw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.48.0.tgz",
      "integrity": "sha512-rFYrk4lLk9YUTIeihnQMiwMr6gDhGGSbWThPEDfBoU/HdAtOzPXeexKi7yU8jO+LWRKnmqPN9NviHQf6GDwBcQ==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.48.0.tgz",
      "integrity": "sha512-sq0hHLTgdtwOPDB5SJOuaoHyiP1qSwg+71TQWk8iDS04bW1wIE0oQ6otPiRj2ZvLYNASLMaTp8QRGUVZ+5OL5A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@smithy/abort-controller": {
      "version": "3.1.9",
      "resolved": "https://registry.npmjs.org/@smithy/abort-controller/-/abort-controller-3.1.9.tgz",
      "integrity": "sha512-yiW0WI30zj8ZKoSYNx90no7ugVn3khlyH/z5W8qtKBtVE6awRALbhSG+2SAHA1r6bO/6M9utxYKVZ3PCJ1rWxw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/chunked-blob-reader": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/chunked-blob-reader/-/chunked-blob-reader-4.0.0.tgz",
      "integrity": "sha512-jSqRnZvkT4egkq/7b6/QRCNXmmYVcHwnJldqJ3IhVpQE2atObVJ137xmGeuGFhjFUr8gCEVAOKwSY79OvpbDaQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/chunked-blob-reader-native": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/@smithy/chunked-blob-reader-native/-/chunked-blob-reader-native-3.0.1.tgz",
      "integrity": "sha512-VEYtPvh5rs/xlyqpm5NRnfYLZn+q0SRPELbvBV+C/G7IQ+ouTuo+NKKa3ShG5OaFR8NYVMXls9hPYLTvIKKDrQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-base64": "^3.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/config-resolver": {
      "version": "3.0.13",
      "resolved": "https://registry.npmjs.org/@smithy/config-resolver/-/config-resolver-3.0.13.tgz",
      "integrity": "sha512-Gr/qwzyPaTL1tZcq8WQyHhTZREER5R1Wytmz4WnVGL4onA3dNk6Btll55c8Vr58pLdvWZmtG8oZxJTw3t3q7Jg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/types": "^3.7.2",
        "@smithy/util-config-provider": "^3.0.0",
        "@smithy/util-middleware": "^3.0.11",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/core": {
      "version": "2.5.7",
      "resolved": "https://registry.npmjs.org/@smithy/core/-/core-2.5.7.tgz",
      "integrity": "sha512-8olpW6mKCa0v+ibCjoCzgZHQx1SQmZuW/WkrdZo73wiTprTH6qhmskT60QLFdT9DRa5mXxjz89kQPZ7ZSsoqqg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/middleware-serde": "^3.0.11",
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/types": "^3.7.2",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-middleware": "^3.0.11",
        "@smithy/util-stream": "^3.3.4",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/credential-provider-imds": {
      "version": "3.2.8",
      "resolved": "https://registry.npmjs.org/@smithy/credential-provider-imds/-/credential-provider-imds-3.2.8.tgz",
      "integrity": "sha512-ZCY2yD0BY+K9iMXkkbnjo+08T2h8/34oHd0Jmh6BZUSZwaaGlGCyBT/3wnS7u7Xl33/EEfN4B6nQr3Gx5bYxgw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/property-provider": "^3.1.11",
        "@smithy/types": "^3.7.2",
        "@smithy/url-parser": "^3.0.11",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/eventstream-codec": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/@smithy/eventstream-codec/-/eventstream-codec-3.1.10.tgz",
      "integrity": "sha512-323B8YckSbUH0nMIpXn7HZsAVKHYHFUODa8gG9cHo0ySvA1fr5iWaNT+iIL0UCqUzG6QPHA3BSsBtRQou4mMqQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/crc32": "5.2.0",
        "@smithy/types": "^3.7.2",
        "@smithy/util-hex-encoding": "^3.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/eventstream-serde-browser": {
      "version": "3.0.14",
      "resolved": "https://registry.npmjs.org/@smithy/eventstream-serde-browser/-/eventstream-serde-browser-3.0.14.tgz",
      "integrity": "sha512-kbrt0vjOIihW3V7Cqj1SXQvAI5BR8SnyQYsandva0AOR307cXAc+IhPngxIPslxTLfxwDpNu0HzCAq6g42kCPg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/eventstream-serde-universal": "^3.0.13",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/eventstream-serde-config-resolver": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/eventstream-serde-config-resolver/-/eventstream-serde-config-resolver-3.0.11.tgz",
      "integrity": "sha512-P2pnEp4n75O+QHjyO7cbw/vsw5l93K/8EWyjNCAAybYwUmj3M+hjSQZ9P5TVdUgEG08ueMAP5R4FkuSkElZ5tQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/eventstream-serde-node": {
      "version": "3.0.13",
      "resolved": "https://registry.npmjs.org/@smithy/eventstream-serde-node/-/eventstream-serde-node-3.0.13.tgz",
      "integrity": "sha512-zqy/9iwbj8Wysmvi7Lq7XFLeDgjRpTbCfwBhJa8WbrylTAHiAu6oQTwdY7iu2lxigbc9YYr9vPv5SzYny5tCXQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/eventstream-serde-universal": "^3.0.13",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/eventstream-serde-universal": {
      "version": "3.0.13",
      "resolved": "https://registry.npmjs.org/@smithy/eventstream-serde-universal/-/eventstream-serde-universal-3.0.13.tgz",
      "integrity": "sha512-L1Ib66+gg9uTnqp/18Gz4MDpJPKRE44geOjOQ2SVc0eiaO5l255ADziATZgjQjqumC7yPtp1XnjHlF1srcwjKw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/eventstream-codec": "^3.1.10",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/fetch-http-handler": {
      "version": "3.2.9",
      "resolved": "https://registry.npmjs.org/@smithy/fetch-http-handler/-/fetch-http-handler-3.2.9.tgz",
      "integrity": "sha512-hYNVQOqhFQ6vOpenifFME546f0GfJn2OiQ3M0FDmuUu8V/Uiwy2wej7ZXxFBNqdx0R5DZAqWM1l6VRhGz8oE6A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^4.1.4",
        "@smithy/querystring-builder": "^3.0.7",
        "@smithy/types": "^3.5.0",
        "@smithy/util-base64": "^3.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/hash-blob-browser": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/@smithy/hash-blob-browser/-/hash-blob-browser-3.1.10.tgz",
      "integrity": "sha512-elwslXOoNunmfS0fh55jHggyhccobFkexLYC1ZeZ1xP2BTSrcIBaHV2b4xUQOdctrSNOpMqOZH1r2XzWTEhyfA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/chunked-blob-reader": "^4.0.0",
        "@smithy/chunked-blob-reader-native": "^3.0.1",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/hash-node": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/hash-node/-/hash-node-3.0.11.tgz",
      "integrity": "sha512-emP23rwYyZhQBvklqTtwetkQlqbNYirDiEEwXl2v0GYWMnCzxst7ZaRAnWuy28njp5kAH54lvkdG37MblZzaHA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "@smithy/util-buffer-from": "^3.0.0",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/hash-stream-node": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/@smithy/hash-stream-node/-/hash-stream-node-3.1.10.tgz",
      "integrity": "sha512-olomK/jZQ93OMayW1zfTHwcbwBdhcZOHsyWyiZ9h9IXvc1mCD/VuvzbLb3Gy/qNJwI4MANPLctTp2BucV2oU/Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/invalid-dependency": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/invalid-dependency/-/invalid-dependency-3.0.11.tgz",
      "integrity": "sha512-NuQmVPEJjUX6c+UELyVz8kUx8Q539EDeNwbRyu4IIF8MeV7hUtq1FB3SHVyki2u++5XLMFqngeMKk7ccspnNyQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/is-array-buffer": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-3.0.0.tgz",
      "integrity": "sha512-+Fsu6Q6C4RSJiy81Y8eApjEB5gVtM+oFKTffg+jSuwtvomJJrhUJBu2zS8wjXSgH/g1MKEWrzyChTBe6clb5FQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/md5-js": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/md5-js/-/md5-js-3.0.11.tgz",
      "integrity": "sha512-3NM0L3i2Zm4bbgG6Ymi9NBcxXhryi3uE8fIfHJZIOfZVxOkGdjdgjR9A06SFIZCfnEIWKXZdm6Yq5/aPXFFhsQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/middleware-content-length": {
      "version": "3.0.13",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-content-length/-/middleware-content-length-3.0.13.tgz",
      "integrity": "sha512-zfMhzojhFpIX3P5ug7jxTjfUcIPcGjcQYzB9t+rv0g1TX7B0QdwONW+ATouaLoD7h7LOw/ZlXfkq4xJ/g2TrIw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/middleware-endpoint": {
      "version": "3.2.8",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-endpoint/-/middleware-endpoint-3.2.8.tgz",
      "integrity": "sha512-OEJZKVUEhMOqMs3ktrTWp7UvvluMJEvD5XgQwRePSbDg1VvBaL8pX8mwPltFn6wk1GySbcVwwyldL8S+iqnrEQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/core": "^2.5.7",
        "@smithy/middleware-serde": "^3.0.11",
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/shared-ini-file-loader": "^3.1.12",
        "@smithy/types": "^3.7.2",
        "@smithy/url-parser": "^3.0.11",
        "@smithy/util-middleware": "^3.0.11",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/middleware-retry": {
      "version": "3.0.34",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-retry/-/middleware-retry-3.0.34.tgz",
      "integrity": "sha512-yVRr/AAtPZlUvwEkrq7S3x7Z8/xCd97m2hLDaqdz6ucP2RKHsBjEqaUA2ebNv2SsZoPEi+ZD0dZbOB1u37tGCA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/service-error-classification": "^3.0.11",
        "@smithy/smithy-client": "^3.7.0",
        "@smithy/types": "^3.7.2",
        "@smithy/util-middleware": "^3.0.11",
        "@smithy/util-retry": "^3.0.11",
        "tslib": "^2.6.2",
        "uuid": "^9.0.1"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/middleware-retry/node_modules/uuid": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-9.0.1.tgz",
      "integrity": "sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/@smithy/middleware-serde": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-serde/-/middleware-serde-3.0.11.tgz",
      "integrity": "sha512-KzPAeySp/fOoQA82TpnwItvX8BBURecpx6ZMu75EZDkAcnPtO6vf7q4aH5QHs/F1s3/snQaSFbbUMcFFZ086Mw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/middleware-stack": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-stack/-/middleware-stack-3.0.11.tgz",
      "integrity": "sha512-1HGo9a6/ikgOMrTrWL/WiN9N8GSVYpuRQO5kjstAq4CvV59bjqnh7TbdXGQ4vxLD3xlSjfBjq5t1SOELePsLnA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/node-config-provider": {
      "version": "3.1.12",
      "resolved": "https://registry.npmjs.org/@smithy/node-config-provider/-/node-config-provider-3.1.12.tgz",
      "integrity": "sha512-O9LVEu5J/u/FuNlZs+L7Ikn3lz7VB9hb0GtPT9MQeiBmtK8RSY3ULmsZgXhe6VAlgTw0YO+paQx4p8xdbs43vQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/property-provider": "^3.1.11",
        "@smithy/shared-ini-file-loader": "^3.1.12",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/node-http-handler": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@smithy/node-http-handler/-/node-http-handler-3.3.3.tgz",
      "integrity": "sha512-BrpZOaZ4RCbcJ2igiSNG16S+kgAc65l/2hmxWdmhyoGWHTLlzQzr06PXavJp9OBlPEG/sHlqdxjWmjzV66+BSQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/abort-controller": "^3.1.9",
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/querystring-builder": "^3.0.11",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/property-provider": {
      "version": "3.1.11",
      "resolved": "https://registry.npmjs.org/@smithy/property-provider/-/property-provider-3.1.11.tgz",
      "integrity": "sha512-I/+TMc4XTQ3QAjXfOcUWbSS073oOEAxgx4aZy8jHaf8JQnRkq2SZWw8+PfDtBvLUjcGMdxl+YwtzWe6i5uhL/A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/protocol-http": {
      "version": "4.1.8",
      "resolved": "https://registry.npmjs.org/@smithy/protocol-http/-/protocol-http-4.1.8.tgz",
      "integrity": "sha512-hmgIAVyxw1LySOwkgMIUN0kjN8TG9Nc85LJeEmEE/cNEe2rkHDUWhnJf2gxcSRFLWsyqWsrZGw40ROjUogg+Iw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/querystring-builder": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/querystring-builder/-/querystring-builder-3.0.11.tgz",
      "integrity": "sha512-u+5HV/9uJaeLj5XTb6+IEF/dokWWkEqJ0XiaRRogyREmKGUgZnNecLucADLdauWFKUNbQfulHFEZEdjwEBjXRg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "@smithy/util-uri-escape": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/querystring-parser": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/querystring-parser/-/querystring-parser-3.0.11.tgz",
      "integrity": "sha512-Je3kFvCsFMnso1ilPwA7GtlbPaTixa3WwC+K21kmMZHsBEOZYQaqxcMqeFFoU7/slFjKDIpiiPydvdJm8Q/MCw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/service-error-classification": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/service-error-classification/-/service-error-classification-3.0.11.tgz",
      "integrity": "sha512-QnYDPkyewrJzCyaeI2Rmp7pDwbUETe+hU8ADkXmgNusO1bgHBH7ovXJiYmba8t0fNfJx75fE8dlM6SEmZxheog==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/shared-ini-file-loader": {
      "version": "3.1.12",
      "resolved": "https://registry.npmjs.org/@smithy/shared-ini-file-loader/-/shared-ini-file-loader-3.1.12.tgz",
      "integrity": "sha512-1xKSGI+U9KKdbG2qDvIR9dGrw3CNx+baqJfyr0igKEpjbHL5stsqAesYBzHChYHlelWtb87VnLWlhvfCz13H8Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/signature-v4": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@smithy/signature-v4/-/signature-v4-3.1.2.tgz",
      "integrity": "sha512-3BcPylEsYtD0esM4Hoyml/+s7WP2LFhcM3J2AGdcL2vx9O60TtfpDOL72gjb4lU8NeRPeKAwR77YNyyGvMbuEA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^3.0.0",
        "@smithy/types": "^3.3.0",
        "@smithy/util-hex-encoding": "^3.0.0",
        "@smithy/util-middleware": "^3.0.3",
        "@smithy/util-uri-escape": "^3.0.0",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/smithy-client": {
      "version": "3.7.0",
      "resolved": "https://registry.npmjs.org/@smithy/smithy-client/-/smithy-client-3.7.0.tgz",
      "integrity": "sha512-9wYrjAZFlqWhgVo3C4y/9kpc68jgiSsKUnsFPzr/MSiRL93+QRDafGTfhhKAb2wsr69Ru87WTiqSfQusSmWipA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/core": "^2.5.7",
        "@smithy/middleware-endpoint": "^3.2.8",
        "@smithy/middleware-stack": "^3.0.11",
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/types": "^3.7.2",
        "@smithy/util-stream": "^3.3.4",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/types": {
      "version": "3.7.2",
      "resolved": "https://registry.npmjs.org/@smithy/types/-/types-3.7.2.tgz",
      "integrity": "sha512-bNwBYYmN8Eh9RyjS1p2gW6MIhSO2rl7X9QeLM8iTdcGRP+eDiIWDt66c9IysCc22gefKszZv+ubV9qZc7hdESg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/url-parser": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/url-parser/-/url-parser-3.0.11.tgz",
      "integrity": "sha512-TmlqXkSk8ZPhfc+SQutjmFr5FjC0av3GZP4B/10caK1SbRwe/v+Wzu/R6xEKxoNqL+8nY18s1byiy6HqPG37Aw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/querystring-parser": "^3.0.11",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/util-base64": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-base64/-/util-base64-3.0.0.tgz",
      "integrity": "sha512-Kxvoh5Qtt0CDsfajiZOCpJxgtPHXOKwmM+Zy4waD43UoEMA+qPxxa98aE/7ZhdnBFZFXMOiBR5xbcaMhLtznQQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^3.0.0",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-body-length-browser": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-body-length-browser/-/util-body-length-browser-3.0.0.tgz",
      "integrity": "sha512-cbjJs2A1mLYmqmyVl80uoLTJhAcfzMOyPgjwAYusWKMdLeNtzmMz9YxNl3/jRLoxSS3wkqkf0jwNdtXWtyEBaQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/util-body-length-node": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-body-length-node/-/util-body-length-node-3.0.0.tgz",
      "integrity": "sha512-Tj7pZ4bUloNUP6PzwhN7K386tmSmEET9QtQg0TgdNOnxhZvCssHji+oZTUIuzxECRfG8rdm2PMw2WCFs6eIYkA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-buffer-from": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-3.0.0.tgz",
      "integrity": "sha512-aEOHCgq5RWFbP+UDPvPot26EJHjOC+bRgse5A8V3FSShqd5E5UN4qc7zkwsvJPPAVsf73QwYcHN1/gt/rtLwQA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-config-provider": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-config-provider/-/util-config-provider-3.0.0.tgz",
      "integrity": "sha512-pbjk4s0fwq3Di/ANL+rCvJMKM5bzAQdE5S/6RL5NXgMExFAi6UgQMPOm5yPaIWPpr+EOXKXRonJ3FoxKf4mCJQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-defaults-mode-browser": {
      "version": "3.0.34",
      "resolved": "https://registry.npmjs.org/@smithy/util-defaults-mode-browser/-/util-defaults-mode-browser-3.0.34.tgz",
      "integrity": "sha512-FumjjF631lR521cX+svMLBj3SwSDh9VdtyynTYDAiBDEf8YPP5xORNXKQ9j0105o5+ARAGnOOP/RqSl40uXddA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/property-provider": "^3.1.11",
        "@smithy/smithy-client": "^3.7.0",
        "@smithy/types": "^3.7.2",
        "bowser": "^2.11.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/@smithy/util-defaults-mode-node": {
      "version": "3.0.34",
      "resolved": "https://registry.npmjs.org/@smithy/util-defaults-mode-node/-/util-defaults-mode-node-3.0.34.tgz",
      "integrity": "sha512-vN6aHfzW9dVVzkI0wcZoUXvfjkl4CSbM9nE//08lmUMyf00S75uuCpTrqF9uD4bD9eldIXlt53colrlwKAT8Gw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/config-resolver": "^3.0.13",
        "@smithy/credential-provider-imds": "^3.2.8",
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/property-provider": "^3.1.11",
        "@smithy/smithy-client": "^3.7.0",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/@smithy/util-endpoints": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@smithy/util-endpoints/-/util-endpoints-2.1.7.tgz",
      "integrity": "sha512-tSfcqKcN/Oo2STEYCABVuKgJ76nyyr6skGl9t15hs+YaiU06sgMkN7QYjo0BbVw+KT26zok3IzbdSOksQ4YzVw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^3.1.12",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-hex-encoding": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-hex-encoding/-/util-hex-encoding-3.0.0.tgz",
      "integrity": "sha512-eFndh1WEK5YMUYvy3lPlVmYY/fZcQE1D8oSf41Id2vCeIkKJXPcYDCZD+4+xViI6b1XSd7tE+s5AmXzz5ilabQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-middleware": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/util-middleware/-/util-middleware-3.0.11.tgz",
      "integrity": "sha512-dWpyc1e1R6VoXrwLoLDd57U1z6CwNSdkM69Ie4+6uYh2GC7Vg51Qtan7ITzczuVpqezdDTKJGJB95fFvvjU/ow==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-retry": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@smithy/util-retry/-/util-retry-3.0.11.tgz",
      "integrity": "sha512-hJUC6W7A3DQgaee3Hp9ZFcOxVDZzmBIRBPlUAk8/fSOEl7pE/aX7Dci0JycNOnm9Mfr0KV2XjIlUOcGWXQUdVQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/service-error-classification": "^3.0.11",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-stream": {
      "version": "3.3.4",
      "resolved": "https://registry.npmjs.org/@smithy/util-stream/-/util-stream-3.3.4.tgz",
      "integrity": "sha512-SGhGBG/KupieJvJSZp/rfHHka8BFgj56eek9px4pp7lZbOF+fRiVr4U7A3y3zJD8uGhxq32C5D96HxsTC9BckQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/fetch-http-handler": "^4.1.3",
        "@smithy/node-http-handler": "^3.3.3",
        "@smithy/types": "^3.7.2",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-buffer-from": "^3.0.0",
        "@smithy/util-hex-encoding": "^3.0.0",
        "@smithy/util-utf8": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-stream/node_modules/@smithy/fetch-http-handler": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/@smithy/fetch-http-handler/-/fetch-http-handler-4.1.3.tgz",
      "integrity": "sha512-6SxNltSncI8s689nvnzZQc/dPXcpHQ34KUj6gR/HBroytKOd/isMG3gJF/zBE1TBmTT18TXyzhg3O3SOOqGEhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^4.1.8",
        "@smithy/querystring-builder": "^3.0.11",
        "@smithy/types": "^3.7.2",
        "@smithy/util-base64": "^3.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@smithy/util-uri-escape": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-uri-escape/-/util-uri-escape-3.0.0.tgz",
      "integrity": "sha512-LqR7qYLgZTD7nWLBecUi4aqolw8Mhza9ArpNEQ881MJJIU2sE5iHCK6TdyqqzcDLy0OPe10IY4T8ctVdtynubg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-utf8": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-3.0.0.tgz",
      "integrity": "sha512-rUeT12bxFnplYDe815GXbq/oixEGHfRFFtcTF3YdDi/JaENIM6aSYYLJydG83UNzLXeRI5K8abYd/8Sp/QM0kA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^3.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@smithy/util-waiter": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-waiter/-/util-waiter-3.2.0.tgz",
      "integrity": "sha512-PpjSboaDUE6yl+1qlg3Si57++e84oXdWGbuFUSAciXsVfEZJJJupR2Nb0QuXHiunt2vGR+1PTizOMvnUPaG2Qg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/abort-controller": "^3.1.9",
        "@smithy/types": "^3.7.2",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@tanstack/react-virtual": {
      "version": "3.13.12",
      "resolved": "https://registry.npmjs.org/@tanstack/react-virtual/-/react-virtual-3.13.12.tgz",
      "integrity": "sha512-Gd13QdxPSukP8ZrkbgS2RwoZseTTbQPLnQEn7HY/rqtM+8Zt95f7xKC7N0EsKs7aoz0WzZ+fditZux+F8EzYxA==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/virtual-core": "3.13.12"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/@tanstack/virtual-core": {
      "version": "3.13.12",
      "resolved": "https://registry.npmjs.org/@tanstack/virtual-core/-/virtual-core-3.13.12.tgz",
      "integrity": "sha512-1YBOJfRHV4sXUmWsFSf5rQor4Ss82G8dQWLRbnk3GA4jeP8hQt1hxXh0tmflpC0dz3VgEv/1+qwPyLeWkQuPFA==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.19.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.11.tgz",
      "integrity": "sha512-uug3FEEGv0r+jrecvUUpbY8lLisvIjg6AAic6a2bSP5OEOLeJsDSnvhCDov7ipFFMXS3orMpzlmi0ZcuGkBbow==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/webidl-conversions": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/@types/webidl-conversions/-/webidl-conversions-7.0.3.tgz",
      "integrity": "sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==",
      "license": "MIT"
    },
    "node_modules/@types/whatwg-url": {
      "version": "11.0.5",
      "resolved": "https://registry.npmjs.org/@types/whatwg-url/-/whatwg-url-11.0.5.tgz",
      "integrity": "sha512-coYR071JRaHa+xoEvvYqvnIHaVqaYrLPbsufM9BF63HkwI5Lgmy2QR8Q5K/lYDYo5AK82wOvSOS0UsLTpTG7uQ==",
      "license": "MIT",
      "dependencies": {
        "@types/webidl-conversions": "*"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz",
      "integrity": "sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==",
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.27",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/abort-controller": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/abort-controller/-/abort-controller-3.0.0.tgz",
      "integrity": "sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==",
      "license": "MIT",
      "dependencies": {
        "event-target-shim": "^5.0.0"
      },
      "engines": {
        "node": ">=6.5"
      }
    },
    "node_modules/abortcontroller-polyfill": {
      "version": "1.7.8",
      "resolved": "https://registry.npmjs.org/abortcontroller-polyfill/-/abortcontroller-polyfill-1.7.8.tgz",
      "integrity": "sha512-9f1iZ2uWh92VcrU9Y8x+LdM4DLj75VE0MJB8zuF1iUnroEptStw+DQ8EQPMUdfe5k+PkB1uUfDQfWbhstH8LrQ==",
      "license": "MIT"
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/airtable": {
      "version": "0.12.2",
      "resolved": "https://registry.npmjs.org/airtable/-/airtable-0.12.2.tgz",
      "integrity": "sha512-HS3VytUBTKj8A0vPl7DDr5p/w3IOGv6RXL0fv7eczOWAtj9Xe8ri4TAiZRXoOyo+Z/COADCj+oARFenbxhmkIg==",
      "license": "MIT",
      "dependencies": {
        "@types/node": ">=8.0.0 <15",
        "abort-controller": "^3.0.0",
        "abortcontroller-polyfill": "^1.4.0",
        "lodash": "^4.17.21",
        "node-fetch": "^2.6.7"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/airtable/node_modules/@types/node": {
      "version": "14.18.63",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.18.63.tgz",
      "integrity": "sha512-fAtCfv4jJg+ExtXhvCkCqUKZ+4ok/JQk01qDKhL5BDDoS3AxKXhV5/MAVUZyQnSEd2GT92fkgZl0pz0Q0AzcIQ==",
      "license": "MIT"
    },
    "node_modules/airtable/node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "license": "MIT",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/archiver": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/archiver/-/archiver-5.3.2.tgz",
      "integrity": "sha512-+25nxyyznAXF7Nef3y0EbBeqmGZgeN/BxHX29Rs39djAfaFalmQ89SE6CWyDCHzGL0yt/ycBtNOmGTW0FyGWNw==",
      "license": "MIT",
      "dependencies": {
        "archiver-utils": "^2.1.0",
        "async": "^3.2.4",
        "buffer-crc32": "^0.2.1",
        "readable-stream": "^3.6.0",
        "readdir-glob": "^1.1.2",
        "tar-stream": "^2.2.0",
        "zip-stream": "^4.1.0"
      },
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/archiver-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/archiver-utils/-/archiver-utils-2.1.0.tgz",
      "integrity": "sha512-bEL/yUb/fNNiNTuUz979Z0Yg5L+LzLxGJz8x79lYmR54fmTIb6ob/hNQgkQnIUDWIFjZVQwl9Xs356I6BAMHfw==",
      "license": "MIT",
      "dependencies": {
        "glob": "^7.1.4",
        "graceful-fs": "^4.2.0",
        "lazystream": "^1.0.0",
        "lodash.defaults": "^4.2.0",
        "lodash.difference": "^4.5.0",
        "lodash.flatten": "^4.4.0",
        "lodash.isplainobject": "^4.0.6",
        "lodash.union": "^4.6.0",
        "normalize-path": "^3.0.0",
        "readable-stream": "^2.0.0"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/archiver-utils/node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/archiver-utils/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/archiver-utils/node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/async": {
      "version": "3.2.6",
      "resolved": "https://registry.npmjs.org/async/-/async-3.2.6.tgz",
      "integrity": "sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==",
      "license": "MIT"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/babel-plugin-polyfill-corejs2": {
      "version": "0.4.14",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.4.14.tgz",
      "integrity": "sha512-Co2Y9wX854ts6U8gAAPXfn0GmAyctHuK8n0Yhfjd6t30g7yvKjspvvOo9yG+z52PZRgFErt7Ka2pYnXCjLKEpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.7",
        "@babel/helper-define-polyfill-provider": "^0.6.5",
        "semver": "^6.3.1"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/babel-plugin-polyfill-corejs3": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.13.0.tgz",
      "integrity": "sha512-U+GNwMdSFgzVmfhNm8GJUX88AadB3uo9KpJqS3FaqNIPKgySuvMb+bHPsOmmuWyIcuqZj/pzt1RUIUZns4y2+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-define-polyfill-provider": "^0.6.5",
        "core-js-compat": "^3.43.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/babel-plugin-polyfill-regenerator": {
      "version": "0.6.5",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.6.5.tgz",
      "integrity": "sha512-ISqQ2frbiNU9vIJkzg7dlPpznPZ4jOiUQ1uSmB0fEHeowtN3COYRsXr/xexn64NpU13P06jc/L5TgiJXOgrbEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-define-polyfill-provider": "^0.6.5"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/babel-plugin-transform-import-meta": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/babel-plugin-transform-import-meta/-/babel-plugin-transform-import-meta-2.3.3.tgz",
      "integrity": "sha512-bbh30qz1m6ZU1ybJoNOhA2zaDvmeXMnGNBMVMDOJ1Fni4+wMBoy/j7MTRVmqAUCIcy54/rEnr9VEBsfcgbpm3Q==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/template": "^7.25.9",
        "tslib": "^2.8.1"
      },
      "peerDependencies": {
        "@babel/core": "^7.10.0"
      }
    },
    "node_modules/babel-plugin-transform-vite-meta-env": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/babel-plugin-transform-vite-meta-env/-/babel-plugin-transform-vite-meta-env-1.0.3.tgz",
      "integrity": "sha512-eyfuDEXrMu667TQpmctHeTlJrZA6jXYHyEJFjcM0yEa60LS/LXlOg2PBbMb8DVS+V9CnTj/j9itdlDVMcY2zEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.13.9",
        "@types/babel__core": "^7.1.12"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/big-integer": {
      "version": "1.6.52",
      "resolved": "https://registry.npmjs.org/big-integer/-/big-integer-1.6.52.tgz",
      "integrity": "sha512-QxD8cf2eVqJOOz63z6JIN9BzvVs/dlySa5HGSBH5xtR8dPteIRQnBxxKqkNTiT6jbDTF6jAfrd4oMcND9RGbQg==",
      "license": "Unlicense",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/bignumber.js": {
      "version": "9.3.1",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.3.1.tgz",
      "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/binary": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/binary/-/binary-0.3.0.tgz",
      "integrity": "sha512-D4H1y5KYwpJgK8wk1Cue5LLPgmwHKYSChkbspQg5JtVuR5ulGckxfR62H3AE9UDkdMC8yyXlqYihuz3Aqg2XZg==",
      "license": "MIT",
      "dependencies": {
        "buffers": "~0.1.1",
        "chainsaw": "~0.1.0"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "license": "MIT",
      "dependencies": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "node_modules/bluebird": {
      "version": "3.4.7",
      "resolved": "https://registry.npmjs.org/bluebird/-/bluebird-3.4.7.tgz",
      "integrity": "sha512-iD3898SR7sWVRHbiQv+sHUtHnMvC1o3nW5rAcqnq3uOn07DSAppZYUkIGslDz6gXC7HfunPe7YVBgoEJASPcHA==",
      "license": "MIT"
    },
    "node_modules/bowser": {
      "version": "2.12.1",
      "resolved": "https://registry.npmjs.org/bowser/-/bowser-2.12.1.tgz",
      "integrity": "sha512-z4rE2Gxh7tvshQ4hluIT7XcFrgLIQaw9X3A+kTTRdovCz5PMukm/0QC/BKSYPj3omF5Qfypn9O/c5kgpmvYUCw==",
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/browserslist": {
      "version": "4.25.3",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.25.3.tgz",
      "integrity": "sha512-cDGv1kkDI4/0e5yON9yM5G/0A5u8sf5TnmdX5C9qHzI9PPu++sQ9zjm1k9NiOrf3riY4OkK0zSGqfvJyJsgCBQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001735",
        "electron-to-chromium": "^1.5.204",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/bson": {
      "version": "6.10.4",
      "resolved": "https://registry.npmjs.org/bson/-/bson-6.10.4.tgz",
      "integrity": "sha512-WIsKqkSC0ABoBJuT1LEX+2HEvNmNKKgnTAyd0fL8qzK4SH2i9NXg+t08YtdZp/V9IZ33cxe3iV4yM0qg8lMQng==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=16.20.1"
      }
    },
    "node_modules/buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "node_modules/buffer-crc32": {
      "version": "0.2.13",
      "resolved": "https://registry.npmjs.org/buffer-crc32/-/buffer-crc32-0.2.13.tgz",
      "integrity": "sha512-VO9Ht/+p3SN7SKWqcrgEzjGbRSJYTx+Q1pTQC0wrWqHx0vpJraQ6GtHx8tvcg1rlK1byhU5gccxgOgj7B0TDkQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-indexof-polyfill": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/buffer-indexof-polyfill/-/buffer-indexof-polyfill-1.0.2.tgz",
      "integrity": "sha512-I7wzHwA3t1/lwXQh+A5PbNvJxgfo5r3xulgpYDB5zckTu/Z9oUK9biouBKQUjEqzaz3HnAT6TYoovmE+GqSf7A==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/buffers": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/buffers/-/buffers-0.1.1.tgz",
      "integrity": "sha512-9q/rDEGSb/Qsvv2qvzIzdluL5k7AaJOTrw23z9reQthrbF7is4CtlT0DXyO1oei2DCp4uojjzQ7igaSHp1kAEQ==",
      "engines": {
        "node": ">=0.2.0"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001737",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001737.tgz",
      "integrity": "sha512-BiloLiXtQNrY5UyF0+1nSJLXUENuhka2pzy2Fx5pGxqavdrxSCW4U6Pn/PoG3Efspi2frRbHpBV2XsrPE6EDlw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chainsaw": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/chainsaw/-/chainsaw-0.1.0.tgz",
      "integrity": "sha512-75kWfWt6MEKNC8xYXIdRpDehRYY/tNSgwKaJq+dbbDcxORuVrrQ+SEHoWsniVn9XPYfP4gmdWIeDk/4YNp1rNQ==",
      "license": "MIT/X11",
      "dependencies": {
        "traverse": ">=0.3.0 <0.4"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/compress-commons": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/compress-commons/-/compress-commons-4.1.2.tgz",
      "integrity": "sha512-D3uMHtGc/fcO1Gt1/L7i1e33VOvD4A9hfQLP+6ewd+BvG/gQ84Yh4oftEhAdjSMgBgwGL+jsppT7JYNpo6MHHg==",
      "license": "MIT",
      "dependencies": {
        "buffer-crc32": "^0.2.13",
        "crc32-stream": "^4.0.2",
        "normalize-path": "^3.0.0",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "license": "MIT"
    },
    "node_modules/core-js-compat": {
      "version": "3.45.1",
      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.45.1.tgz",
      "integrity": "sha512-tqTt5T4PzsMIZ430XGviK4vzYSoeNJ6CXODi6c/voxOT6IZqBht5/EKaSNnYiEjjRYxjVz7DQIsOsY0XNi8PIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.25.3"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/core-js"
      }
    },
    "node_modules/core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
      "license": "MIT"
    },
    "node_modules/crc-32": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/crc-32/-/crc-32-1.2.2.tgz",
      "integrity": "sha512-ROmzCKrTnOwybPcJApAA6WBWij23HVfGVNKqqrZpuyZOHqK2CwHSvpGuyt/UNNvaIjEd8X5IFGp4Mh+Ie1IHJQ==",
      "license": "Apache-2.0",
      "bin": {
        "crc32": "bin/crc32.njs"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/crc32-stream": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/crc32-stream/-/crc32-stream-4.0.3.tgz",
      "integrity": "sha512-NT7w2JVU7DFroFdYkeq8cywxrgjPHWkdX1wjpRQXPX5Asews3tA+Ght6lddQO5Mkumffp3X7GEqku3epj2toIw==",
      "license": "MIT",
      "dependencies": {
        "crc-32": "^1.2.0",
        "readable-stream": "^3.4.0"
      },
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/data-uri-to-buffer": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/data-uri-to-buffer/-/data-uri-to-buffer-4.0.1.tgz",
      "integrity": "sha512-0R9ikRb668HB7QDxT1vkpuUBtqc53YyAwMwGeUFKRojY/NWKvdZ+9UYtRfGmhqNbRkTSVpMbmyhXipFFv2cb/A==",
      "license": "MIT",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/dayjs": {
      "version": "1.11.13",
      "resolved": "https://registry.npmjs.org/dayjs/-/dayjs-1.11.13.tgz",
      "integrity": "sha512-oaMBel6gjolK862uaPQOVTA7q3TZhuSvuMQAAglQDOWYO9A91IrAOUJEyKVlqJlHE0vq5p5UXxzdPfMH/x6xNg==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/docx": {
      "version": "8.5.0",
      "resolved": "https://registry.npmjs.org/docx/-/docx-8.5.0.tgz",
      "integrity": "sha512-4SbcbedPXTciySXiSnNNLuJXpvxFe5nqivbiEHXyL8P/w0wx2uW7YXNjnYgjW0e2e6vy+L/tMISU/oAiXCl57Q==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "^20.3.1",
        "jszip": "^3.10.1",
        "nanoid": "^5.0.4",
        "xml": "^1.0.1",
        "xml-js": "^1.6.8"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.1",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.1.tgz",
      "integrity": "sha512-kQhDYKZecqnM0fCnzI5eIv5L4cAe/iRI+HqMbO/hbRdTAeXDG+M9FjipUxNfbARuEg4iHIbhnhs78BCHNbSxEQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/duplexer2": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/duplexer2/-/duplexer2-0.1.4.tgz",
      "integrity": "sha512-asLFVfWWtJ90ZyOUHMqk7/S2w2guQKxUI2itj3d92ADHhxUSbCMGi1f1cBcJ7xM1To+pE/Khbwo1yuNbMEPKeA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "readable-stream": "^2.0.2"
      }
    },
    "node_modules/duplexer2/node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/duplexer2/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/duplexer2/node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.208",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.208.tgz",
      "integrity": "sha512-ozZyibehoe7tOhNaf16lKmljVf+3npZcJIEbJRVftVsmAg5TeA1mGS9dVCZzOwr2xT7xK15V0p7+GZqSPgkuPg==",
      "license": "ISC"
    },
    "node_modules/end-of-stream": {
      "version": "1.4.5",
      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
      "integrity": "sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==",
      "license": "MIT",
      "dependencies": {
        "once": "^1.4.0"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/event-target-shim": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/event-target-shim/-/event-target-shim-5.0.1.tgz",
      "integrity": "sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/exceljs": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/exceljs/-/exceljs-4.4.0.tgz",
      "integrity": "sha512-XctvKaEMaj1Ii9oDOqbW/6e1gXknSY4g/aLCDicOXqBE4M0nRWkUu0PTp++UPNzoFY12BNHMfs/VadKIS6llvg==",
      "license": "MIT",
      "dependencies": {
        "archiver": "^5.0.0",
        "dayjs": "^1.8.34",
        "fast-csv": "^4.3.1",
        "jszip": "^3.10.1",
        "readable-stream": "^3.6.0",
        "saxes": "^5.0.1",
        "tmp": "^0.2.0",
        "unzipper": "^0.10.11",
        "uuid": "^8.3.0"
      },
      "engines": {
        "node": ">=8.3.0"
      }
    },
    "node_modules/exceljs/node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/extend": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
      "license": "MIT"
    },
    "node_modules/fast-csv": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/fast-csv/-/fast-csv-4.3.6.tgz",
      "integrity": "sha512-2RNSpuwwsJGP0frGsOmTb9oUF+VkFSM4SyLTDgwf2ciHWTarN0lQTC+F2f/t5J9QjW+c65VFIAAu85GsvMIusw==",
      "license": "MIT",
      "dependencies": {
        "@fast-csv/format": "4.3.5",
        "@fast-csv/parse": "4.3.6"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/fast-xml-parser": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/fast-xml-parser/-/fast-xml-parser-4.2.5.tgz",
      "integrity": "sha512-B9/wizE4WngqQftFPmdaMYlXoJlJOYxGQOanC77fq9k8+Z0v5dDSVh+3glErdIROP//s/jgb7ZuxKfB8nVyo0g==",
      "funding": [
        {
          "type": "paypal",
          "url": "https://paypal.me/naturalintelligence"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/NaturalIntelligence"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "strnum": "^1.0.5"
      },
      "bin": {
        "fxparser": "src/cli/cli.js"
      }
    },
    "node_modules/fetch-blob": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/fetch-blob/-/fetch-blob-3.2.0.tgz",
      "integrity": "sha512-7yAQpD2UMJzLi1Dqv7qFYnPbaPx7ZfFK6PiIxQ4PfkGPyNyl2Ugx+a/umUonmKqjhM4DnfbMvdX6otXq83soQQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/jimmywarting"
        },
        {
          "type": "paypal",
          "url": "https://paypal.me/jimmywarting"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "node-domexception": "^1.0.0",
        "web-streams-polyfill": "^3.0.3"
      },
      "engines": {
        "node": "^12.20 || >= 14.13"
      }
    },
    "node_modules/file-saver": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/file-saver/-/file-saver-2.0.5.tgz",
      "integrity": "sha512-P9bmyZ3h/PRG+Nzga+rbdI4OEpNDzAVyy74uVO9ATgzLK6VtAsYybF/+TOCvrc0MO793d6+42lLyZTw7/ArVzA==",
      "license": "MIT"
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/formdata-node": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/formdata-node/-/formdata-node-6.0.3.tgz",
      "integrity": "sha512-8e1++BCiTzUno9v5IZ2J6bv4RU+3UKDmqWUQD0MIMVCd9AdhWkO1gw57oo1mNEX1dMq2EGI+FbWz4B92pscSQg==",
      "license": "MIT",
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/formdata-polyfill": {
      "version": "4.0.10",
      "resolved": "https://registry.npmjs.org/formdata-polyfill/-/formdata-polyfill-4.0.10.tgz",
      "integrity": "sha512-buewHzMvYL29jdeQTVILecSaZKnt/RJWjoZCF5OW60Z67/GmSLBkOFM7qh1PI3zFNtJbaZL5eQu1vLfazOwj4g==",
      "license": "MIT",
      "dependencies": {
        "fetch-blob": "^3.1.2"
      },
      "engines": {
        "node": ">=12.20.0"
      }
    },
    "node_modules/fs-constants": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs-constants/-/fs-constants-1.0.0.tgz",
      "integrity": "sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==",
      "license": "MIT"
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/fstream": {
      "version": "1.0.12",
      "resolved": "https://registry.npmjs.org/fstream/-/fstream-1.0.12.tgz",
      "integrity": "sha512-WvJ193OHa0GHPEL+AycEJgxvBEwyfRkN1vhjca23OaPVMCaLCXTd5qAu82AjTcgP1UJmytkOKb63Ypde7raDIg==",
      "deprecated": "This package is no longer supported.",
      "license": "ISC",
      "dependencies": {
        "graceful-fs": "^4.1.2",
        "inherits": "~2.0.0",
        "mkdirp": ">=0.5 0",
        "rimraf": "2"
      },
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gaxios": {
      "version": "6.7.1",
      "resolved": "https://registry.npmjs.org/gaxios/-/gaxios-6.7.1.tgz",
      "integrity": "sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "extend": "^3.0.2",
        "https-proxy-agent": "^7.0.1",
        "is-stream": "^2.0.0",
        "node-fetch": "^2.6.9",
        "uuid": "^9.0.1"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/gaxios/node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "license": "MIT",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/gaxios/node_modules/uuid": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-9.0.1.tgz",
      "integrity": "sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/gcp-metadata": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/gcp-metadata/-/gcp-metadata-5.3.0.tgz",
      "integrity": "sha512-FNTkdNEnBdlqF2oatizolQqNANMrcqJt6AAYt99B3y1aLLC8Hc5IOBb+ZnnzllodEEf6xMBp6wRcBbc16fa65w==",
      "license": "Apache-2.0",
      "optional": true,
      "peer": true,
      "dependencies": {
        "gaxios": "^5.0.0",
        "json-bigint": "^1.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/gcp-metadata/node_modules/agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "license": "MIT",
      "optional": true,
      "peer": true,
      "dependencies": {
        "debug": "4"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/gcp-metadata/node_modules/gaxios": {
      "version": "5.1.3",
      "resolved": "https://registry.npmjs.org/gaxios/-/gaxios-5.1.3.tgz",
      "integrity": "sha512-95hVgBRgEIRQQQHIbnxBXeHbW4TqFk4ZDJW7wmVtvYar72FdhRIo1UGOLS2eRAKCPEdPBWu+M7+A33D9CdX9rA==",
      "license": "Apache-2.0",
      "optional": true,
      "peer": true,
      "dependencies": {
        "extend": "^3.0.2",
        "https-proxy-agent": "^5.0.0",
        "is-stream": "^2.0.0",
        "node-fetch": "^2.6.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/gcp-metadata/node_modules/https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "license": "MIT",
      "optional": true,
      "peer": true,
      "dependencies": {
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gcp-metadata/node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "license": "MIT",
      "optional": true,
      "peer": true,
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/google-auth-library": {
      "version": "9.15.1",
      "resolved": "https://registry.npmjs.org/google-auth-library/-/google-auth-library-9.15.1.tgz",
      "integrity": "sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==",
      "license": "Apache-2.0",
      "dependencies": {
        "base64-js": "^1.3.0",
        "ecdsa-sig-formatter": "^1.0.11",
        "gaxios": "^6.1.1",
        "gcp-metadata": "^6.1.0",
        "gtoken": "^7.0.0",
        "jws": "^4.0.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/google-auth-library/node_modules/gcp-metadata": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/gcp-metadata/-/gcp-metadata-6.1.1.tgz",
      "integrity": "sha512-a4tiq7E0/5fTjxPAaH4jpjkSv/uCaU2p5KC6HVGrvl0cDjA8iBZv4vv1gyzlmK0ZUKqwpOyQMKzZQe3lTit77A==",
      "license": "Apache-2.0",
      "dependencies": {
        "gaxios": "^6.1.1",
        "google-logging-utils": "^0.0.2",
        "json-bigint": "^1.0.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/google-logging-utils": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/google-logging-utils/-/google-logging-utils-0.0.2.tgz",
      "integrity": "sha512-NEgUnEcBiP5HrPzufUkBzJOD/Sxsco3rLNo1F1TNf7ieU8ryUzBhqba8r756CjLX7rn3fHl6iLEwPYuqpoKgQQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "license": "ISC"
    },
    "node_modules/gtoken": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/gtoken/-/gtoken-7.1.0.tgz",
      "integrity": "sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==",
      "license": "MIT",
      "dependencies": {
        "gaxios": "^6.0.0",
        "jws": "^4.0.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/immediate": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/immediate/-/immediate-3.0.6.tgz",
      "integrity": "sha512-XXOFtyqDjNDAQxVfYxuF7g9Il/IbWmmlQg2MYKOH8ExIT1qg6xc4zyS3HaEEATgs1btfzxq15ciUiY7gjSXRGQ==",
      "license": "MIT"
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==",
      "license": "MIT"
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-bigint": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/json-bigint/-/json-bigint-1.0.0.tgz",
      "integrity": "sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==",
      "license": "MIT",
      "dependencies": {
        "bignumber.js": "^9.0.0"
      }
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jszip": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/jszip/-/jszip-3.10.1.tgz",
      "integrity": "sha512-xXDvecyTpGLrqFrvkrUSoxxfJI5AH7U8zxxtVclpsUtMCq4JQ290LY8AW5c7Ggnr/Y/oK+bQMbqK2qmtk3pN4g==",
      "license": "(MIT OR GPL-3.0-or-later)",
      "dependencies": {
        "lie": "~3.3.0",
        "pako": "~1.0.2",
        "readable-stream": "~2.3.6",
        "setimmediate": "^1.0.5"
      }
    },
    "node_modules/jszip/node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/jszip/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/jszip/node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/jwa": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.1.tgz",
      "integrity": "sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.0.tgz",
      "integrity": "sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^2.0.0",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lazystream": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/lazystream/-/lazystream-1.0.1.tgz",
      "integrity": "sha512-b94GiNHQNy6JNTrt5w6zNyffMrNkXZb3KTkCZJb2V1xaEGCk093vkZ2jk3tpaeP33/OiXC+WvK9AxUebnf5nbw==",
      "license": "MIT",
      "dependencies": {
        "readable-stream": "^2.0.5"
      },
      "engines": {
        "node": ">= 0.6.3"
      }
    },
    "node_modules/lazystream/node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/lazystream/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/lazystream/node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/lie": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/lie/-/lie-3.3.0.tgz",
      "integrity": "sha512-UaiMJzeWRlEujzAuw5LokY1L5ecNQYZKfmyZ9L7wDHb/p5etKaxXhohBcrw0EYby+G/NA52vRSN4N39dxHAIwQ==",
      "license": "MIT",
      "dependencies": {
        "immediate": "~3.0.5"
      }
    },
    "node_modules/listenercount": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/listenercount/-/listenercount-1.0.1.tgz",
      "integrity": "sha512-3mk/Zag0+IJxeDrxSgaDPy4zZ3w05PRZeJNnlWhzFz5OkX49J4krc+A8X2d2M69vGMBEX0uyl8M+W+8gH+kBqQ==",
      "license": "ISC"
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.debounce": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/lodash.debounce/-/lodash.debounce-4.0.8.tgz",
      "integrity": "sha512-FT1yDzDYEoYWhnSGnpE/4Kj1fLZkDFyqRb7fNt6FdYOSxlUWAtp42Eh6Wb0rGIv/m9Bgo7x4GhQbm5Ys4SG5ow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lodash.defaults": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/lodash.defaults/-/lodash.defaults-4.2.0.tgz",
      "integrity": "sha512-qjxPLHd3r5DnsdGacqOMU6pb/avJzdh9tFX2ymgoZE27BmjXrNy/y4LoaiTeAb+O3gL8AfpJGtqfX/ae2leYYQ==",
      "license": "MIT"
    },
    "node_modules/lodash.difference": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.difference/-/lodash.difference-4.5.0.tgz",
      "integrity": "sha512-dS2j+W26TQ7taQBGN8Lbbq04ssV3emRw4NY58WErlTO29pIqS0HmoT5aJ9+TUQ1N3G+JOZSji4eugsWwGp9yPA==",
      "license": "MIT"
    },
    "node_modules/lodash.escaperegexp": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/lodash.escaperegexp/-/lodash.escaperegexp-4.1.2.tgz",
      "integrity": "sha512-TM9YBvyC84ZxE3rgfefxUWiQKLilstD6k7PTGt6wfbtXF8ixIJLOL3VYyV/z+ZiPLsVxAsKAFVwWlWeb2Y8Yyw==",
      "license": "MIT"
    },
    "node_modules/lodash.flatten": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/lodash.flatten/-/lodash.flatten-4.4.0.tgz",
      "integrity": "sha512-C5N2Z3DgnnKr0LOpv/hKCgKdb7ZZwafIrsesve6lmzvZIRZRGaZ/l6Q8+2W7NaT+ZwO3fFlSCzCzrDCFdJfZ4g==",
      "license": "MIT"
    },
    "node_modules/lodash.groupby": {
      "version": "4.6.0",
      "resolved": "https://registry.npmjs.org/lodash.groupby/-/lodash.groupby-4.6.0.tgz",
      "integrity": "sha512-5dcWxm23+VAoz+awKmBaiBvzox8+RqMgFhi7UvX9DHZr2HdxHXM/Wrf8cfKpsW37RNrvtPn6hSwNqurSILbmJw==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isequal": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.isequal/-/lodash.isequal-4.5.0.tgz",
      "integrity": "sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==",
      "deprecated": "This package is deprecated. Use require('node:util').isDeepStrictEqual instead.",
      "license": "MIT"
    },
    "node_modules/lodash.isfunction": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/lodash.isfunction/-/lodash.isfunction-3.0.9.tgz",
      "integrity": "sha512-AirXNj15uRIMMPihnkInB4i3NHeb4iBtNg9WRWuK2o31S+ePwwNmDPaTL3o7dTJ+VXNZim7rFs4rxN4YU1oUJw==",
      "license": "MIT"
    },
    "node_modules/lodash.isnil": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/lodash.isnil/-/lodash.isnil-4.0.0.tgz",
      "integrity": "sha512-up2Mzq3545mwVnMhTDMdfoG1OurpA/s5t88JmQX809eH3C8491iu2sfKhTfhQtKY78oPNhiaHJUpT/dUDAAtng==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isundefined": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isundefined/-/lodash.isundefined-3.0.1.tgz",
      "integrity": "sha512-MXB1is3s899/cD8jheYYE2V9qTHwKvt+npCwpD+1Sxm3Q3cECXCiYHjeHWXNwr6Q0SOBPrYUDxendrO6goVTEA==",
      "license": "MIT"
    },
    "node_modules/lodash.union": {
      "version": "4.6.0",
      "resolved": "https://registry.npmjs.org/lodash.union/-/lodash.union-4.6.0.tgz",
      "integrity": "sha512-c4pB2CdGrGdjMKYLA+XiRDO7Y0PRQbm/Gzg8qMj+QH+pFVAoTp5sBpO0odL3FjoPCGjK96p6qsP+yQoiLoOBcw==",
      "license": "MIT"
    },
    "node_modules/lodash.uniq": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.uniq/-/lodash.uniq-4.5.0.tgz",
      "integrity": "sha512-xfBaXQd9ryd9dlSDvnvI0lvxfLJlYAZzXomUYzLKtUeOQvOP5piqAWuGtrhWeqaXK9hhoM/iyJc5AV+XfsX3HQ==",
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/memory-pager": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/memory-pager/-/memory-pager-1.5.0.tgz",
      "integrity": "sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==",
      "license": "MIT"
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/mongodb": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/mongodb/-/mongodb-6.19.0.tgz",
      "integrity": "sha512-H3GtYujOJdeKIMLKBT9PwlDhGrQfplABNF1G904w6r5ZXKWyv77aB0X9B+rhmaAwjtllHzaEkvi9mkGVZxs2Bw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@mongodb-js/saslprep": "^1.1.9",
        "bson": "^6.10.4",
        "mongodb-connection-string-url": "^3.0.0"
      },
      "engines": {
        "node": ">=16.20.1"
      },
      "peerDependencies": {
        "@aws-sdk/credential-providers": "^3.188.0",
        "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
        "gcp-metadata": "^5.2.0",
        "kerberos": "^2.0.1",
        "mongodb-client-encryption": ">=6.0.0 <7",
        "snappy": "^7.3.2",
        "socks": "^2.7.1"
      },
      "peerDependenciesMeta": {
        "@aws-sdk/credential-providers": {
          "optional": true
        },
        "@mongodb-js/zstd": {
          "optional": true
        },
        "gcp-metadata": {
          "optional": true
        },
        "kerberos": {
          "optional": true
        },
        "mongodb-client-encryption": {
          "optional": true
        },
        "snappy": {
          "optional": true
        },
        "socks": {
          "optional": true
        }
      }
    },
    "node_modules/mongodb-connection-string-url": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/mongodb-connection-string-url/-/mongodb-connection-string-url-3.0.2.tgz",
      "integrity": "sha512-rMO7CGo/9BFwyZABcKAWL8UJwH/Kc2x0g72uhDWzG48URRax5TCIcJ7Rc3RZqffZzO/Gwff/jyKwCU9TN8gehA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@types/whatwg-url": "^11.0.2",
        "whatwg-url": "^14.1.0 || ^13.0.0"
      }
    },
    "node_modules/mongodb-connection-string-url/node_modules/tr46": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-5.1.1.tgz",
      "integrity": "sha512-hdF5ZgjTqgAntKkklYw0R03MG2x/bSzTtkxmIRw/sTNV8YXsCJ1tfLAX23lhxhHJlEf3CRCOCGGWw3vI3GaSPw==",
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/mongodb-connection-string-url/node_modules/webidl-conversions": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-7.0.0.tgz",
      "integrity": "sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/mongodb-connection-string-url/node_modules/whatwg-url": {
      "version": "14.2.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-14.2.0.tgz",
      "integrity": "sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "^5.1.0",
        "webidl-conversions": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "5.1.5",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-5.1.5.tgz",
      "integrity": "sha512-Ir/+ZpE9fDsNH0hQ3C68uyThDXzYcim2EqcZ8zn8Chtt1iylPT9xXJB0kPCnqzgcEGikO9RxSrh63MsmVCU7Fw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.js"
      },
      "engines": {
        "node": "^18 || >=20"
      }
    },
    "node_modules/node-domexception": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/node-domexception/-/node-domexception-1.0.0.tgz",
      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
      "deprecated": "Use your platform's native DOMException instead",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/jimmywarting"
        },
        {
          "type": "github",
          "url": "https://paypal.me/jimmywarting"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=10.5.0"
      }
    },
    "node_modules/node-fetch": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-3.3.2.tgz",
      "integrity": "sha512-dRB78srN/l6gqWulah9SrxeYnxeddIG30+GOqK/9OlLVyLg3HPnr6SqOWTWOXKRwC2eGYCkZ59NNuSgvSrpgOA==",
      "license": "MIT",
      "dependencies": {
        "data-uri-to-buffer": "^4.0.0",
        "fetch-blob": "^3.1.4",
        "formdata-polyfill": "^4.0.10"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/node-fetch"
      }
    },
    "node_modules/node-forge": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-1.3.1.tgz",
      "integrity": "sha512-dPEtOeMvF9VMcYV/1Wb8CPoVAXtp6MKMlcbAt4ddqmGqUJ6fQZFXkNZNkNlfevtNkGtaSoXf/vNNNSvgrdXwtA==",
      "license": "(BSD-3-Clause OR GPL-2.0)",
      "engines": {
        "node": ">= 6.13.0"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/pako": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/pako/-/pako-1.0.11.tgz",
      "integrity": "sha512-4hLB8Py4zZce5s4yd9XzopqwVv/yGNhV1Bl8NTmCq1763HeK2+EwVTv+leGeL13Dnh2wfbqowVPXCIO0z4taYw==",
      "license": "(MIT AND Zlib)"
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss/node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/react": {
      "version": "19.1.1",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.1.tgz",
      "integrity": "sha512-w8nqGImo45dmMIfljjMwOGtbmC/mk4CMYhWIicdSflH91J9TyCyczcPFXJzrZ/ZXcgGRFeP6BU0BEJTw6tZdfQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.1",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.1.tgz",
      "integrity": "sha512-Dlq/5LAZgF0Gaz6yiqZCf6VCcZs1ghAJyrsu84Q/GT0gV+mCxbfmKNoGRKBYMJ8IEdGPqu49YWXD02GCknEDkw==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.1"
      }
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/readdir-glob": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/readdir-glob/-/readdir-glob-1.1.3.tgz",
      "integrity": "sha512-v05I2k7xN8zXvPD9N+z/uhXPaj0sUFCe2rcWZIpBsqxfP7xXFQ0tipAd/wjj1YxWyWtUS5IDJpOG82JKt2EAVA==",
      "license": "Apache-2.0",
      "dependencies": {
        "minimatch": "^5.1.0"
      }
    },
    "node_modules/readdir-glob/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/readdir-glob/node_modules/minimatch": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.1.6.tgz",
      "integrity": "sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/regenerate": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.4.2.tgz",
      "integrity": "sha512-zrceR/XhGYU/d/opr2EKO7aRHUeiBI8qjtfHqADTwZd6Szfy16la6kqD0MIUs5z5hx6AaKa+PixpPrR289+I0A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/regenerate-unicode-properties": {
      "version": "10.2.0",
      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.2.0.tgz",
      "integrity": "sha512-DqHn3DwbmmPVzeKj9woBadqmXxLvQoQIwu7nopMc72ztvxVmVk2SBhSnx67zuye5TP+lJsb/TBQsjLKhnDf3MA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "regenerate": "^1.4.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/regexpu-core": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-6.2.0.tgz",
      "integrity": "sha512-H66BPQMrv+V16t8xtmq+UC0CBpiTBA60V8ibS1QVReIp8T1z8hwFxqcGzm9K6lgsN7sB5edVH8a+ze6Fqm4weA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "regenerate": "^1.4.2",
        "regenerate-unicode-properties": "^10.2.0",
        "regjsgen": "^0.8.0",
        "regjsparser": "^0.12.0",
        "unicode-match-property-ecmascript": "^2.0.0",
        "unicode-match-property-value-ecmascript": "^2.1.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/regjsgen": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.8.0.tgz",
      "integrity": "sha512-RvwtGe3d7LvWiDQXeQw8p5asZUmfU1G/l6WbUXeHta7Y2PEIvBTwH6E2EfmYUK8pxcxEdEmaomqyp0vZZ7C+3Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/regjsparser": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.12.0.tgz",
      "integrity": "sha512-cnE+y8bz4NhMjISKbgeVJtqNbtf5QpjZP+Bslo+UqkIt9QPnX9q095eiRRASJG1/tz6dlNr6Z5NsBiWYokp6EQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "jsesc": "~3.0.2"
      },
      "bin": {
        "regjsparser": "bin/parser"
      }
    },
    "node_modules/regjsparser/node_modules/jsesc": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.0.2.tgz",
      "integrity": "sha512-xKqzzWXDttJuOcawBt4KnKHHIf5oQ/Cxax+0PWFG+DFDgHNAdi+TXECADI+RYiFUMmx8792xsMbbgXj4CwnP4g==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/rimraf": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
      "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      }
    },
    "node_modules/rollup": {
      "version": "4.48.0",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.48.0.tgz",
      "integrity": "sha512-BXHRqK1vyt9XVSEHZ9y7xdYtuYbwVod2mLwOMFP7t/Eqoc1pHRlG/WdV2qNeNvZHRQdLedaFycljaYYM96RqJQ==",
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.48.0",
        "@rollup/rollup-android-arm64": "4.48.0",
        "@rollup/rollup-darwin-arm64": "4.48.0",
        "@rollup/rollup-darwin-x64": "4.48.0",
        "@rollup/rollup-freebsd-arm64": "4.48.0",
        "@rollup/rollup-freebsd-x64": "4.48.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.48.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.48.0",
        "@rollup/rollup-linux-arm64-gnu": "4.48.0",
        "@rollup/rollup-linux-arm64-musl": "4.48.0",
        "@rollup/rollup-linux-loongarch64-gnu": "4.48.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.48.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.48.0",
        "@rollup/rollup-linux-riscv64-musl": "4.48.0",
        "@rollup/rollup-linux-s390x-gnu": "4.48.0",
        "@rollup/rollup-linux-x64-gnu": "4.48.0",
        "@rollup/rollup-linux-x64-musl": "4.48.0",
        "@rollup/rollup-win32-arm64-msvc": "4.48.0",
        "@rollup/rollup-win32-ia32-msvc": "4.48.0",
        "@rollup/rollup-win32-x64-msvc": "4.48.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/sax": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.4.1.tgz",
      "integrity": "sha512-+aWOz7yVScEGoKNd4PA10LZ8sk0A/z5+nXQG5giUO5rprX9jgYsTdov9qCchZiPIZezbZH+jRut8nPodFAX4Jg==",
      "license": "ISC"
    },
    "node_modules/saxes": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/saxes/-/saxes-5.0.1.tgz",
      "integrity": "sha512-5LBh1Tls8c9xgGjw3QrMwETmTMVk0oFgvrFSvWx62llR2hcEInrKNZ2GZCCuuy2lvWrdl5jhbpeqc5hRYKFOcw==",
      "license": "ISC",
      "dependencies": {
        "xmlchars": "^2.2.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/selfsigned": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/selfsigned/-/selfsigned-3.0.1.tgz",
      "integrity": "sha512-6U6w6kSLrM9Zxo0D7mC7QdGS6ZZytMWBnj/vhF9p+dAHx6CwGezuRcO4VclTbrrI7mg7SD6zNiqXUuBHOVopNQ==",
      "license": "MIT",
      "dependencies": {
        "node-forge": "^1"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/setimmediate": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz",
      "integrity": "sha512-MATJdZp8sLqDl/68LfQmbP8zKPLQNV6BIZoIgrscFDQ+RsvK/BxeDQOgyxKKoh0y/8h3BqVFnCqQ/gd+reiIXA==",
      "license": "MIT"
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/sparse-bitfield": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/sparse-bitfield/-/sparse-bitfield-3.0.3.tgz",
      "integrity": "sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==",
      "license": "MIT",
      "dependencies": {
        "memory-pager": "^1.0.2"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/strnum": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/strnum/-/strnum-1.1.2.tgz",
      "integrity": "sha512-vrN+B7DBIoTTZjnPNewwhx6cBA/H+IS7rfW68n7XxC1y7uoiGQBxaKzqucGUgavX15dJgiGztLJ8vxuEzwqBdA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/NaturalIntelligence"
        }
      ],
      "license": "MIT"
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tar-stream": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/tar-stream/-/tar-stream-2.2.0.tgz",
      "integrity": "sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==",
      "license": "MIT",
      "dependencies": {
        "bl": "^4.0.3",
        "end-of-stream": "^1.4.1",
        "fs-constants": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.1.1"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/tmp": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.2.5.tgz",
      "integrity": "sha512-voyz6MApa1rQGUxT3E+BK7/ROe8itEx7vD8/HEvt4xwXucvQ5G5oeEiHkmHZJuBO21RpOf+YYm9MOivj709jow==",
      "license": "MIT",
      "engines": {
        "node": ">=14.14"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
      "license": "MIT"
    },
    "node_modules/traverse": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/traverse/-/traverse-0.3.9.tgz",
      "integrity": "sha512-iawgk0hLP3SxGKDfnDJf8wTz4p2qImnyihM5Hh/sGvQ3K37dPi/w8sRhdNIxYA1TwFwc5mDhIJq+O0RsvXBKdQ==",
      "license": "MIT/X11",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/unicode-canonical-property-names-ecmascript": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.1.tgz",
      "integrity": "sha512-dA8WbNeb2a6oQzAQ55YlT5vQAWGV9WXOsi3SskE3bcCdM0P4SDd+24zS/OCacdRq5BkdsRj9q3Pg6YyQoxIGqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-match-property-ecmascript": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/unicode-match-property-ecmascript/-/unicode-match-property-ecmascript-2.0.0.tgz",
      "integrity": "sha512-5kaZCrbp5mmbz5ulBkDkbY0SsPOjKqVS35VpL9ulMPfSl0J0Xsm+9Evphv9CoIZFwre7aJoa94AY6seMKGVN5Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "unicode-canonical-property-names-ecmascript": "^2.0.0",
        "unicode-property-aliases-ecmascript": "^2.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-match-property-value-ecmascript": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.2.0.tgz",
      "integrity": "sha512-4IehN3V/+kkr5YeSSDDQG8QLqO26XpL2XP3GQtqwlT/QYSECAwFztxVHjlbh0+gjJ3XmNLS0zDsbgs9jWKExLg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-property-aliases-ecmascript": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.1.0.tgz",
      "integrity": "sha512-6t3foTQI9qne+OZoVQB/8x8rk2k1eVy1gRXhV3oFQ5T6R1dqQ1xtin3XqSlx3+ATBkliTaR/hHyJBm+LVPNM8w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unzipper": {
      "version": "0.10.14",
      "resolved": "https://registry.npmjs.org/unzipper/-/unzipper-0.10.14.tgz",
      "integrity": "sha512-ti4wZj+0bQTiX2KmKWuwj7lhV+2n//uXEotUmGuQqrbVZSEGFMbI68+c6JCQ8aAmUWYvtHEz2A8K6wXvueR/6g==",
      "license": "MIT",
      "dependencies": {
        "big-integer": "^1.6.17",
        "binary": "~0.3.0",
        "bluebird": "~3.4.1",
        "buffer-indexof-polyfill": "~1.0.0",
        "duplexer2": "~0.1.4",
        "fstream": "^1.0.12",
        "graceful-fs": "^4.2.2",
        "listenercount": "~1.0.1",
        "readable-stream": "~2.3.6",
        "setimmediate": "~1.0.4"
      }
    },
    "node_modules/unzipper/node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/unzipper/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/unzipper/node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/uuid": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-11.1.0.tgz",
      "integrity": "sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/esm/bin/uuid"
      }
    },
    "node_modules/vite": {
      "version": "5.4.19",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.19.tgz",
      "integrity": "sha512-qO3aKv3HoQC8QKiNSTuUM1l9o/XX3+c+VTgLHbJWHZGeTPVAg2XwazI9UWzoxjIJCGCV2zU60uqMzjeLZuULqA==",
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-plugin-environment": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/vite-plugin-environment/-/vite-plugin-environment-1.1.3.tgz",
      "integrity": "sha512-9LBhB0lx+2lXVBEWxFZC+WO7PKEyE/ykJ7EPWCq95NEcCpblxamTbs5Dm3DLBGzwODpJMEnzQywJU8fw6XGGGA==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "vite": ">= 2.7"
      }
    },
    "node_modules/web-streams-polyfill": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/web-streams-polyfill/-/web-streams-polyfill-3.3.3.tgz",
      "integrity": "sha512-d2JWLCivmZYTSIoge9MsgFCZrt571BikcWGYkjC1khllbTeDlGqZ2D8vD8E/lJa8WGWbb7Plm8/XJYV7IJHZZw==",
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
      "license": "BSD-2-Clause"
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/xml": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/xml/-/xml-1.0.1.tgz",
      "integrity": "sha512-huCv9IH9Tcf95zuYCsQraZtWnJvBtLVE0QHMOs8bWyZAFZNDcYjsPq1nEx8jKA9y+Beo9v+7OBPRisQTjinQMw==",
      "license": "MIT"
    },
    "node_modules/xml-js": {
      "version": "1.6.11",
      "resolved": "https://registry.npmjs.org/xml-js/-/xml-js-1.6.11.tgz",
      "integrity": "sha512-7rVi2KMfwfWFl+GpPg6m80IVMWXLRjO+PxTq7V2CDhoGak0wzYzFgUY2m4XJ47OGdXd8eLE8EmwfAmdjw7lC1g==",
      "license": "MIT",
      "dependencies": {
        "sax": "^1.2.4"
      },
      "bin": {
        "xml-js": "bin/cli.js"
      }
    },
    "node_modules/xmlchars": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/xmlchars/-/xmlchars-2.2.0.tgz",
      "integrity": "sha512-JZnDKK8B0RCDw84FNdDAIpZK+JuJw+s7Lz8nksI7SIuU3UXJJslUthsi+uWBUYOwPFwW7W7PRLRfUKpxjtjFCw==",
      "license": "MIT"
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "license": "ISC"
    },
    "node_modules/zip-stream": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/zip-stream/-/zip-stream-4.1.1.tgz",
      "integrity": "sha512-9qv4rlDiopXg4E69k+vMHjNN63YFMe9sZMrdlvKnCjlCRWeCBswPPMPUfx+ipsAWq1LXHe70RcbaHdJJpS6hyQ==",
      "license": "MIT",
      "dependencies": {
        "archiver-utils": "^3.0.4",
        "compress-commons": "^4.1.2",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/zip-stream/node_modules/archiver-utils": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/archiver-utils/-/archiver-utils-3.0.4.tgz",
      "integrity": "sha512-KVgf4XQVrTjhyWmx6cte4RxonPLR9onExufI1jhvw/MQ4BB6IsZD5gT8Lq+u/+pRkWna/6JoHpiQioaqFP5Rzw==",
      "license": "MIT",
      "dependencies": {
        "glob": "^7.2.3",
        "graceful-fs": "^4.2.0",
        "lazystream": "^1.0.0",
        "lodash.defaults": "^4.2.0",
        "lodash.difference": "^4.5.0",
        "lodash.flatten": "^4.4.0",
        "lodash.isplainobject": "^4.0.6",
        "lodash.union": "^4.6.0",
        "normalize-path": "^3.0.0",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">= 10"
      }
    }
  }
}
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package-lock.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package.json ---\n{
  "name": "socialsync-pro-2.0",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "vercel-build": "npm run build",
    "migrate": "node scripts/migrate-airtable-to-mongodb.js",
    "migrate:dry-run": "node scripts/migrate-airtable-to-mongodb.js --dry-run",
    "test:mongodb": "node scripts/test-mongodb-connection.js",
    "test:mongodb:impl": "node scripts/test-mongodb-implementation.js",
    "init:mongodb": "node scripts/init-mongodb-database.js",
    "check:migration": "node scripts/check-migration-status.js"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "3.614.0",
    "@google/genai": "^1.10.0",
    "@google/generative-ai": "^0.24.1",
    "@tanstack/react-virtual": "^3.8.0",
    "@vitejs/plugin-react": "^4.0.0",
    "airtable": "^0.12.2",
    "docx": "8.5.0",
    "exceljs": "4.4.0",
    "file-saver": "2.0.5",
    "form-data": "^4.0.0",
    "formdata-node": "^6.0.3",
    "jszip": "3.10.1",
    "mongodb": "^6.19.0",
    "node-fetch": "^3.3.2",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "selfsigned": "^3.0.1",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/preset-env": "^7.28.0",
    "@babel/preset-react": "^7.27.1",
    "@babel/preset-typescript": "^7.27.1",
    "@types/uuid": "^10.0.0",
    "babel-plugin-transform-import-meta": "^2.3.3",
    "babel-plugin-transform-vite-meta-env": "^1.0.3",
    "dotenv": "^17.2.1",
    "typescript": "~5.8.2",
    "vite": "^5.2.0",
    "vite-plugin-environment": "^1.1.3"
  }
}
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\package.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\QWEN.md ---\nInstructions:

Purpose and Goals:

* Serve as an expert software engineer specializing in project refactoring and dependency management.
* Provide clean, step-by-step guides for users on how to professionally prompt a Coder AI Assistant to perform specific tasks.
* Focus on creating prompts that are clear, unambiguous, and result in high-quality code and project restructuring.

Behaviors and Rules:

1) Initial Inquiry and Task Analysis:
when user give a task of programming, you analyze it and then response with the following structure: AI Asistant Role (expert software engineer), Project Context (user will give this and the Knowledge files), Primary Goal (solve the problem), Step-by-Step Instructions to do, Output Format, Example of Desired Output

2) Prompt Construction:
a) A professional prompt must be a single, comprehensive block of text, not a series of back-and-forth commands.
b) Each prompt should include the following sections, clearly delineated:
    i. **Objective:** A concise statement of the desired outcome (e.g., 'Refactor the 'User' class to use a factory pattern').
    ii. **Context:** Relevant information about the project environment, including technology stack, coding standards, and existing code snippets.
    iii. **Constraints:** Any specific limitations or requirements, such as avoiding certain libraries, maintaining backward compatibility, or adhering to a specific design pattern.
    iv. **Step-by-Step Technical Plan:** A numbered list of logical steps for the AI to follow to complete the task. Note that the project will be deployed on Vercel so the project structure should follows the Vercel Structure with Hobby plan (which is descibed the knowledge file)
    v. **Desired Output Format:** A clear description of how the AI should present its response (e.g., 'Provide a single code block with the refactored class, and a markdown table of new dependencies').

3) Overall Tone:
* Be knowledgeable, professional, and methodical.
* Use precise technical language appropriate for a software engineer.
* Maintain a helpful, guiding tone, as if mentoring a junior engineer on how to best use their tools.
* Avoid slang, casual language, or excessive emojis.

Knowledge: Project files\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\QWEN.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\README.md ---\n# SocialSync Pro 2.1

This contains everything you need to run your app locally.

## Run Locally

**Prerequisites:**  Node.js

1. Install frontend dependencies:
   `npm install`
2. Install backend dependencies:
   `cd server && npm install`
3. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
4. (Optional) Set the `VITE_ADMIN_PASSWORD` in [.env.local](.env.local) to your preferred admin password (defaults to 'admin123')
5. Set Airtable and Cloudinary credentials in the server's [.env](server/.env) file
6. Run the backend (BFF):
   `cd server && npm start`
7. Run the frontend app:
   `npm run dev`

## Backend-for-Frontend (BFF) Layer

SocialSync Pro now includes a dedicated Backend-for-Frontend (BFF) service that acts as an intermediary between the client-side application and numerous third-party services (Airtable, Gemini, Facebook, Cloudinary). This architecture provides several key benefits:

- **Security**: API keys are kept secure on the backend rather than exposed in the frontend
- **Centralized Logic**: All external API communications are handled in one place
- **Caching Opportunities**: Future enhancements can implement server-side caching
- **Rate Limiting**: Better control over API usage and request throttling

The BFF is implemented with Node.js and Express, and provides proxy endpoints for all external services.

## Admin Panel

To access the admin panel, navigate to `/admin` in your browser. Use the configured admin password (or 'admin123' if not configured) to log in.

The admin panel allows you to:
- Manage AI services and their supported models
- Configure text and image generation models
- Set up provider capabilities

Sample data is available to help you get started quickly.

## Database Migration (Airtable to MongoDB)

SocialSync Pro now supports MongoDB as an alternative to Airtable for data storage. The migration tools allow you to seamlessly move your data from Airtable to MongoDB without any code changes.

### Benefits of MongoDB Migration

1. **Better Performance**: Faster data queries and operations
2. **Higher Scalability**: Handle larger datasets more efficiently
3. **Cost Savings**: Eliminate Airtable's record and attachment limits
4. **Enhanced Features**: Advanced querying and indexing capabilities

### Migration Process

1. **Prepare Your Environment**: Set up MongoDB and configure environment variables
2. **Run Migration Tools**: Use the provided scripts to migrate your data
3. **Verify Migration**: Confirm all data has been transferred correctly
4. **Switch to MongoDB**: Update your application to use MongoDB

For detailed migration instructions, see:
- [MIGRATION_GUIDE.md](MIGRATION_GUIDE.md) - Complete migration instructions
- [MIGRATION_SUMMARY.md](MIGRATION_SUMMARY.md) - Overview of benefits and process
- [scripts/README.md](scripts/README.md) - Tool-specific documentation

### Zero Code Change Requirement

The MongoDB migration is designed to work with your existing codebase without any modifications. All API contracts remain identical, ensuring seamless operation after migration.
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\README.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\social-sync-pro-afa76-firebase-adminsdk-fbsvc-3b5d1b4378.json ---\n{
  "type": "service_account",
  "project_id": "social-post-scheduler-afa76",
  "private_key_id": "3b5d1b43785655ccc56714dbca85623a8203cef2",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCS/GdKbyhkKEDo\n+BuG5mVicCcB14WLVjEWyFvec5L82ttIpmiDXUtSSDIHCE1pqjILc977r5Ifh8Yy\nNyKhrBdWImJXFWphFWcKMElXFBT0SftDyCK2uPrxBtLiP3VwcpQCLvKh+8ERKEoX\n9lL96XlG43AmYy6RcAGoo63RrZepCntlRvDIvkgxO7sgtjTTnavLvogpFEZjzK5h\nIUm+7FTfjhJRHI0mFkryDmVr9P2MGXqy92p5AkaQFPjD+8p7FH9zK8kxGsMvfmGt\nuJYSsvFyfTQEseLSz0Tyhh6dn0i2lsHbPMd2YGxvWNa60ZuiM6+BsXDw4UNXHZvw\n9YcU1tSxAgMBAAECggEAB2mnh2VW+QMfL+iYUcuzg/0COJlvDJWAlQSufmffezVJ\n3w52YZ6ePnRx4nEon0o0KyfxMEn80W6CYDSv4E2qoR9LjJcBxgrjZwwDnNrASkgj\nXfodRxAJ5scocjzPTkgW/wuxVJo61MPOhcoYSiIgycKNXMA+gFrw2HmFuff6WK3h\nLpIW6s3xF4sb0qpD79j0SpuiF4tXIsVGOe6DyUZwLD7ctk0UuTjygsnU7YFumNkU\n7b3KdbnymbdhxMbFl5GuKJ4rP3YXGZFuqB5iPKliBpl86q3dyIzbSggKcCwVtcya\ne8wKhAQix2atG7Z4dh/BjA2TgljOIIE1O9PnV7RhQQKBgQDMlNiETqIDJPnT/fyW\n/J6CqhG9v6ewIC03/b+JCKOIkC5YG8pHFjNmwXH54aol1ufT9O2A8nY1KOCHgE0X\nODun/CK1EX6xpT4Tmg/XK71mHOqwDx7TeRzQZfs8zpo8tBO9zmeZaR3xlTTJLv56\nSpeo/yNo2X9vBF65p5kwtnWZEQKBgQC37cGaJ6aQlmS1yPT/ZVvOVtgj/Ci7UWhB\nnYq6rVcaMlhEEP3OfG1JRTd4HDq0Xcz3g1bqmVPbwKXeET8AEg7b4E+QVSTXJ8iP\nj7rhqCSm140cl3kieA74Cc+T5qlFc7e7PXGdnzjzCnATIa9t3GPY50ujRQcIw/+R\n4BaL5sCBoQKBgEPaxqmzjwbt97L5lhLaPRTnpbTC4bKIKZddoW6pH9yGvehZZ1EG\nqwvU86HG2HFugzwJC9FuGgjtwvMOegNOknLYLQbTg6sWPK2xtrlOd6ZrxueYTEgl\n7omsmZUEjaG+tKGK2U/Hzre3HmfwH1WecgkKfssjAKJo16ZKUYQXsI+RAoGAY7yn\nqUIrDmifP/wy7nM2L1PkbM8F/12LnVkiq0vn2arHNlHIb7oFQSApjhYwtzHOPcGY\n1ipC0P1MdHkBorYoHI8sVeX1zj4igca83jThex+Tw5dX9psH8vTO/TKtQ54WWZBe\nFc0Lgq98SsOPb5F9C1eRKn357ITsB1xunXqJlUECgYEAkvGujQhpgDoxudCWo2mv\nmT5Rw+UQUodqlyk8oHtOD7AEQJ91nYF6tib2C+cCzrvtrOQ4JpjK9U88tYnBx7YW\nxZ+uv0fgKhbfHYcq3Igx+PduCapdDXnrZJbKDKAxirPI4I8rcgkYakrOcdoLXWIv\neqefHz9lY6qQdrU8qrINe4k=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@social-post-scheduler-afa76.iam.gserviceaccount.com",
  "client_id": "115713665305652773527",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40social-post-scheduler-afa76.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\social-sync-pro-afa76-firebase-adminsdk-fbsvc-3b5d1b4378.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\temp_ps.ps1 ---\n$output = "=== Project Analysis File ===\n" 
$output += "Generated on: $(Get-Date)\n" 
$output += "Project Root: $PWD\n\n" 
$output += "=== File Structure (Tree View) ===\n" 
$output += (Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike '*node_modules*' -and $_.FullName -notlike '*.git*' -and $_.FullName -notlike '*dist*' -and $_.FullName -notlike '*build*' -and $_.FullName -notlike '*.env*' -and $_.FullName -notlike '*.log' } | Select-Object -ExpandProperty FullName | ForEach-Object { $_ }) -join "\n" 
$output += "\n\n=== File Contents ===\n" 
Get-ChildItem -Recurse -File | Where-Object { $_.FullName -notlike '*node_modules*' -and $_.FullName -notlike '*.git*' -and $_.FullName -notlike '*dist*' -and $_.FullName -notlike '*build*' -and $_.FullName -notlike '*.env*' -and $_.FullName -notlike '*.log' } | ForEach-Object { 
    $file = $_.FullName 
    $output += "\n--- File: $file ---\n" 
    if ($file -like '*.env*') { 
        $output += "[Sensitive file: Contents omitted for security. Manually review if needed.]\n" 
    } else { 
        try { 
            $content = Get-Content -Path $file -Raw -Encoding UTF8 
            $output += $content + "\n" 
        } catch { 
            $output += "[Binary or unreadable file: Contents omitted.]\n" 
        } 
    } 
    $output += "--- End of File: $file ---\n" 
} 
$output += "\n=== End of Project Analysis File ===\n" 
$output += "Upload this file to Grok. If sensitive data (e.g., API keys) appears, edit it out before uploading.\n" 
$output | Out-File -FilePath combined_project.txt -Encoding utf8 
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\temp_ps.ps1 ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\tsconfig.json ---\n{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "types": ["vite/client"]
  }
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\tsconfig.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\types.ts ---\nexport interface PersonaPhoto {
    id: string;
    imageKey: string;
}

export interface SocialAccount {
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest';
    credentials: Record<string, string>; // Stores platform-specific credentials (e.g., accessToken, pageId)
    displayName?: string; // e.g., "My Facebook Page"
    profileUrl?: string; // e.g., "https://www.facebook.com/mypage"
}

export interface Persona {
    id: string;
    nickName: string;
    outfitDescription: string;
    mainStyle: string;
    activityField: string;
    avatarImageKey?: string;
    avatarImageUrl?: string;
    photos: PersonaPhoto[];
    socialAccounts?: SocialAccount[]; // New field to store social accounts associated with the persona
}

export interface BrandInfo {
  name: string;
  mission: string;
  values: string;
  audience: string;
  personality: string;
}

export interface Settings {
    language: string;
    totalPostsPerMonth: number;
    mediaPromptSuffix: string;
    affiliateContentKit: string;
    textGenerationModel: string;
    imageGenerationModel: string;
    textModelFallbackOrder: string[];
    visionModels: string[];
}

export interface UnifiedProfileAssets {
  accountName: string;
  username:string;
  profilePicturePrompt: string;
  profilePictureId: string;
  profilePictureImageKey: string;
  coverPhoto: {
    prompt: string;
    designConcept: string;
  };
  coverPhotoId: string;
  coverPhotoImageKey: string;
}

export type PostStatus = 'draft' | 'scheduled' | 'published' | 'error';

export interface MediaPlanPost {
    id: string;
    platform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest';
    contentType: string;
    title: string;
    content: string;
    description?: string; // For YouTube video descriptions
    hashtags: string[];
    cta: string;
    mediaPrompt?: string | string[];
    script?: string;
    imageKey?: string;
    videoKey?: string;
    mediaOrder?: ('image' | 'video')[];
    sources?: { uri: string; title: string; }[];
    promotedProductIds?: string[];
    scheduledAt?: string;
    publishedAt?: string; 
    publishedUrl?: string;
    autoComment?: string;
    status?: PostStatus;
    // New fields for package context
    isPillar?: boolean;
}

export interface MediaPlanWeek {
    week: number;
    theme: string;
    posts: MediaPlanPost[];
}

export type MediaPlan = MediaPlanWeek[];

export interface MediaPlanGroup {
    id: string;
    name: string;
    prompt: string;
    plan: MediaPlan;
    source?: 'wizard' | 'content-package' | 'brand-launch';
    sources?: { uri: string; title: string; }[];
    productImages?: { name: string, type: string, data: string }[];
    personaId?: string;
}

export interface BrandFoundation {
  brandName: string;
  mission: string;
  values: string[];
  targetAudience: string;
  personality: string;
  keyMessaging: string[];
  usp: string;
}

export interface ColorInfo {
  name: string;
  hex: string;
}

export interface ColorPalette {
  primary: ColorInfo;
  secondary: ColorInfo;
  accent: ColorInfo;
  text: ColorInfo;
}

export interface FontRecommendations {
  headlines: { name: string; weight: string };
  body: { name: string; weight: string };
}

export interface LogoConcept {
  id: string;
  style: string;
  prompt: string;
  imageKey: string;
}

export interface CoreMediaAssets {
  logoConcepts: LogoConcept[];
  colorPalette: ColorPalette;
  fontRecommendations: FontRecommendations;
}

export interface AffiliateLink {
    id: string;
    productId: string;
    productName: string;
    price: number;
    salesVolume: number;
    providerName: string;
    commissionRate: number; // Stored as percentage, e.g., 20 for 20%
    commissionValue: number;
    productLink: string;
    promotionLink?: string;
    product_avatar?: string; // URL to product avatar image
    product_description?: string;
    features?: string[];
    use_cases?: string[];
    product_image_links?: string[]; // URLs to additional product images
    customer_reviews?: string; // Summary or snippet of reviews
    product_rating?: number; // Numeric rating, e.g., 4.5
}

export interface Trend {
  id: string;
  brandId: string;
  industry: string;
  topic: string;
  keywords: string[];
  links: { url: string; title: string }[];
  notes?: string;
  analysis: string;
  createdAt: string;
}

export interface Idea {
  id: string;
  trendId: string;
  title: string;
  description: string;
  targetAudience?: string;
  mediaPrompt?: string;
  cta?: string;
  productId?: string; // New field to link idea to a product
}

export interface GeneratedAssets {
  brandFoundation: BrandFoundation;
  coreMediaAssets: CoreMediaAssets;
  unifiedProfileAssets: UnifiedProfileAssets;
  mediaPlans: MediaPlanGroup[];
  affiliateLinks: AffiliateLink[];
  personas?: Persona[];
  trends?: Trend[];
  ideas?: Idea[];
  facebookTrends?: FacebookTrend[];
  facebookPostIdeas?: FacebookPostIdea[];
}



export type SchedulingPost = {
  planId: string;
  weekIndex: number;
  postIndex: number;
  post: MediaPlanPost;
};

export type PostInfo = { planId: string; weekIndex: number; postIndex: number; post: MediaPlanPost };

export interface FacebookPage {
    id: string;
    name: string;
    access_token: string;
    category: string;
    category_list: { id: string; name: string }[];
    tasks: string[];
}

export interface FacebookLoginResponse {
    userAccessToken: string;
    pages: FacebookPage[];
}

export interface FacebookTrend {
  id: string;
  brandId: string;
  industry: string;
  topic: string;
  keywords: string[];
  links: { uri: string; title: string }[];
  analysis: string;
  createdAt: string;
}

export interface FacebookPostIdea {
  id: string;
  trendId: string;
  title: string;
  content: string;
  mediaPrompt: string;
  cta: string;
}

export interface AIModel {
  id: string;
  name: string;
  provider: string;
  capabilities: string[];
}

export interface AIService {
  id: string;
  name: string;
  description: string;
  models: AIModel[];
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\types.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\update_function.cjs ---\nconst fs = require('fs');

// Read the file
const filePath = 'C:\\Users\\trltr\\Downloads\\personal_projects\\socialsync-pro-2.1\\services\\geminiService.ts';
let content = fs.readFileSync(filePath, 'utf-8');

// Define the old and new functions
const oldFunction = `export const sanitizeAndParseJson = (jsonText: string) => {
    // This function attempts to fix common JSON errors produced by AI models.
    if (!jsonText) {
        throw new Error("Received empty JSON string from AI.");
    }

    let sanitized = jsonText;

    // The single-line comment removal was removed because it was corrupting
    // base64 strings in image generation which can contain "//".
    // The AI models should be trusted to return valid JSON when requested.

    // 2. Fix for observed error: \`... ,"=value" ...\` which should be \`... ,"value" ...\`
    // This regex looks for a comma or opening bracket, optional whitespace,
    // then the erroneous \`="\` followed by a string, and a closing "\`.
    // It reconstructs it as a valid JSON string.
    sanitized = sanitized.replace(/([,\\[])\\s*=\\s*"([^"]*)"/g, '$1"$2"');

    // 3. Fix for Pinterest posts generating "infographicContent" instead of "content".
    sanitized = sanitized.replace(/"infographicContent":/g, '"content":');
    
    // 4. Fix for hashtags missing an opening quote, e.g., [... , #tag"] or [#tag"]
    // This looks for a comma/bracket followed by whitespace, then a #, then captures the tag content, and the closing quote.
    // It then reconstructs it with the opening quote.
    sanitized = sanitized.replace(/([\\[,]\\s*)#([^"]+)(")/g, '$1"#$2$3');

    // 5. Removed risky unescaped quote sanitizer. Relying on responseMimeType: "application/json".
    // sanitized = sanitized.replace(/(?<![[{\\s:,])"(?![\\s,}\\]:])/g, '\\"');

    // 6. Remove trailing commas, which are valid in JS but not in strict JSON.
    // e.g., \`{"key":"value",}\` or \`["item1",]\`
    sanitized = sanitized.replace(/,(\\s*[}\\]])/g, '$1');
    
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        console.error("Failed to parse AI JSON response for product-based ideas:", jsonText);
        throw new Error("The AI returned a malformed or unexpected response. This may be a temporary issue with the model. Please try again later or configure a different model in Settings.");
    }
};`;

const newFunction = `export const sanitizeAndParseJson = (jsonText: string) => {
    // This function attempts to fix common JSON errors produced by AI models.
    if (!jsonText) {
        throw new Error("Received empty JSON string from AI.");
    }

    let sanitized = jsonText.trim();

    // First, try to parse the JSON as is - if it works, return it immediately
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        // If it fails, continue with sanitization
    }

    // Remove any markdown code block markers if present
    const markdownMatch = sanitized.match(/\\\`\\\`\\\`(json)?\\\\s*([\\\\s\\\\S]*?)\\\\s*\\\`\\\`\\\`/);
    if (markdownMatch && markdownMatch[2]) {
        sanitized = markdownMatch[2];
    }

    // The single-line comment removal was removed because it was corrupting
    // base64 strings in image generation which can contain "//".
    // The AI models should be trusted to return valid JSON when requested.

    // 2. Fix for observed error: \`... ,"=value" ...\` which should be \`... ,"value" ...\`
    // This regex looks for a comma or opening bracket, optional whitespace,
    // then the erroneous \`="\` followed by a string, and a closing "\`.
    // It reconstructs it as a valid JSON string.
    sanitized = sanitized.replace(/([,\\[])\\s*=\\s*"([^"]*)"/g, '$1"$2"');

    // 3. Fix for Pinterest posts generating "infographicContent" instead of "content".
    sanitized = sanitized.replace(/"infographicContent":/g, '"content":');
    
    // 4. Fix for hashtags missing an opening quote, e.g., [... , #tag"] or [#tag"]
    // This looks for a comma/bracket followed by whitespace, then a #, then captures the tag content, and the closing quote.
    // It then reconstructs it with the opening quote.
    sanitized = sanitized.replace(/([\\[,]\\s*)#([^"]+)(")/g, '$1"#$2$3');

    // 5. Removed risky unescaped quote sanitizer. Relying on responseMimeType: "application/json".
    // sanitized = sanitized.replace(/(?<![[{\\s:,])"(?![\\s,}\\]:])/g, '\\"');

    // 6. Remove trailing commas, which are valid in JS but not in strict JSON.
    // e.g., \`{"key":"value",}\` or \`["item1",]\`
    sanitized = sanitized.replace(/,(\\s*[}\\]])/g, '$1');
    
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        console.error("Failed to parse AI JSON response for product-based ideas:", jsonText);
        throw new Error("The AI returned a malformed or unexpected response. This may be a temporary issue with the model. Please try again later or configure a different model in Settings.");
    }
};`;

// Replace the old function with the new one
content = content.replace(oldFunction, newFunction);

// Write the updated content back to the file
fs.writeFileSync(filePath, content);

console.log('File updated successfully.');\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\update_function.cjs ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\vite.config.ts ---\nimport path from 'path';
import { defineConfig, loadEnv } from 'vite';
import EnvironmentPlugin from 'vite-plugin-environment';
// Import 'react' plugin nếu bạn chưa có
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    const isProduction = mode === 'production';
    
    return {
      // Đã xóa basicSsl() và thêm plugin 'react()'
      plugins: [react(), EnvironmentPlugin({
        
      })],
      // Đã xóa toàn bộ khối 'server'
      build: {
        outDir: 'dist',
        assetsDir: 'assets',
        rollupOptions: {
          output: {
            manualChunks: {
              vendor: ['react', 'react-dom'],
              utils: ['file-saver', 'uuid'],
            }
          }
        }
      },
      css: {
        devSourcemap: true,
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\vite.config.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.gemini\GEMINI.md ---\nInstructions:

Purpose and Goals:

* Serve as an expert software engineer specializing in project refactoring and dependency management.
* Provide clean, step-by-step guides for users on how to professionally prompt a Coder AI Assistant to perform specific tasks.
* Focus on creating prompts that are clear, unambiguous, and result in high-quality code and project restructuring.

Behaviors and Rules:

1) Initial Inquiry and Task Analysis:
when user give a task of programming, you analyze it and then response with the following structure: AI Asistant Role (expert software engineer), Project Context (user will give this and the Knowledge files), Primary Goal (solve the problem), Step-by-Step Instructions to do, Output Format, Example of Desired Output

2) Prompt Construction:
a) A professional prompt must be a single, comprehensive block of text, not a series of back-and-forth commands.
b) Each prompt should include the following sections, clearly delineated:
    i. **Objective:** A concise statement of the desired outcome (e.g., 'Refactor the 'User' class to use a factory pattern').
    ii. **Context:** Relevant information about the project environment, including technology stack, coding standards, and existing code snippets.
    iii. **Constraints:** Any specific limitations or requirements, such as avoiding certain libraries, maintaining backward compatibility, or adhering to a specific design pattern.
    iv. **Step-by-Step Technical Plan:** A numbered list of logical steps for the AI to follow to complete the task. Note that the project will be deployed on Vercel so the project structure should follows the Vercel Structure with Hobby plan (which is descibed the knowledge file)
    v. **Desired Output Format:** A clear description of how the AI should present its response (e.g., 'Provide a single code block with the refactored class, and a markdown table of new dependencies').

3) Overall Tone:
* Be knowledgeable, professional, and methodical.
* Use precise technical language appropriate for a software engineer.
* Maintain a helpful, guiding tone, as if mentoring a junior engineer on how to best use their tools.
* Avoid slang, casual language, or excessive emojis.

Knowledge: Project files\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.gemini\GEMINI.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\project.json ---\n{"projectId":"prj_QcpX7po25laYoHWNxIumZemsh21i","orgId":"team_r9KtYs9qgA0kSZr3jSrrh8LW","projectName":"social-sync-pro"}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\project.json ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\README.txt ---\n> Why do I have a folder named ".vercel" in my project?
The ".vercel" folder is created when you link a directory to a Vercel project.

> What does the "project.json" file contain?
The "project.json" file contains:
- The ID of the Vercel project that you linked ("projectId")
- The ID of the user or team your Vercel project is owned by ("orgId")

> Should I commit the ".vercel" folder?
No, you should not share the ".vercel" folder with anyone.
Upon creation, it will be automatically added to your ".gitignore" file.
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\.vercel\README.txt ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini-generate.js ---\nimport { config } from 'dotenv';
config();

import { GoogleGenerativeAI } from "@google/generative-ai";

export default async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { model, contents, config: generationConfig } = request.body;

    if (!model || !contents) {
      return response.status(400).json({ error: 'Missing required fields: model and contents' });
    }

    // Initialize Gemini AI
    if (!process.env.GEMINI_API_KEY) {
      return response.status(500).json({ error: 'GEMINI_API_KEY is not configured' });
    }

    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

    // Separate systemInstruction from generationConfig
    const genConfig = { ...generationConfig };
    const systemInstruction = genConfig?.systemInstruction;
    if (systemInstruction) {
      delete genConfig.systemInstruction;
    }

    const modelConfig = { model: model };
    if (systemInstruction) {
      modelConfig.systemInstruction = systemInstruction;
    }

    const geminiModel = genAI.getGenerativeModel(modelConfig);

    // Using the full configuration if provided
    const generateContentRequest = {
      contents: [{ parts: [{ text: JSON.stringify(contents) }] }]
    };
    
    if (Object.keys(genConfig).length > 0) {
      generateContentRequest.generationConfig = genConfig;
    }

    const result = generationConfig 
      ? await geminiModel.generateContent(generateContentRequest)
      : await geminiModel.generateContent(JSON.stringify(contents));
    
    const responseText = result.response.text();

    return response.status(200).json({ text: responseText });
  } catch (error) {
    console.error('Error in /api/gemini/generate:', error);
    return response.status(500).json({ error: 'Failed to generate content from Gemini API: ' + error.message });
  }
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini-generate.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\health.js ---\n
import { allowCors } from './lib/cors.js';

function handler(request, response) {
  if (request.method !== 'GET') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  response.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    services: {
      gemini: !!process.env.GEMINI_API_KEY,
      openrouter: !!process.env.OPENROUTER_API_KEY,
      cloudflare: !!(process.env.CLOUDFLARE_ACCOUNT_ID && process.env.CLOUDFLARE_API_TOKEN),
      cloudinary: !!(process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_UPLOAD_PRESET),
      facebook: !!(process.env.FACEBOOK_APP_ID),
      airtable: !!(process.env.AIRTABLE_PAT && process.env.AIRTABLE_BASE_ID)
    }
  });
}

export default allowCors(handler);
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\health.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\index.js ---\nimport { allowCors } from './lib/cors.js';
const { GoogleGenerativeAI } = require("@google/generative-ai");
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const FormData = require('form-data');

// Airtable helper
const { makeAirtableRequest } = require('./lib/airtable.js');

// Initialize AI services
const genAI = process.env.GEMINI_API_KEY ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;

async function handler(request, response) {
  // Set CORS headers
  response.setHeader('Access-Control-Allow-Credentials', true);
  response.setHeader('Access-Control-Allow-Origin', '*');
  response.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  response.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );

  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    response.status(200).end();
    return;
  }

  const { service, action } = request.query;

  // Route based on service
  switch (service) {
    case 'airtable':
      return handleAirtableRequest(request, response, action);
    case 'mongodb':
      return handleMongodbRequest(request, response, action);
    case 'gemini':
      return handleGeminiRequest(request, response, action);
    case 'openrouter':
      return handleOpenRouterRequest(request, response, action);
    case 'cloudflare':
      return handleCloudflareRequest(request, response, action);
    case 'cloudinary':
      return handleCloudinaryRequest(request, response, action);
    case 'facebook':
      return handleFacebookRequest(request, response, action);
    case 'health':
      return handleHealthRequest(request, response);
    default:
      response.setHeader('Allow', ['GET', 'POST']);
      response.status(405).end(`Service ${service} Not Allowed`);
  }
}

// Airtable handler
async function handleAirtableRequest(request, response, action) {
  switch (action) {
    case 'request': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { method = 'GET', path, body, headers = {} } = request.body;
        const { AIRTABLE_PAT, AIRTABLE_BASE_ID } = process.env;

        if (!AIRTABLE_PAT || !AIRTABLE_BASE_ID) {
          return response.status(500).json({ error: 'Airtable credentials not configured on server' });
        }

        if (!path) {
          return response.status(400).json({ error: 'Missing path for Airtable request' });
        }

        // Construct the full URL
        let fullPath;
        if (path.startsWith('meta/bases/')) {
          fullPath = path.replace('meta/bases/', `meta/bases/${AIRTABLE_BASE_ID}/`);
        } else {
          fullPath = `${AIRTABLE_BASE_ID}/${path}`;
        }
        
        const url = `https://api.airtable.com/v0/${fullPath}`;
        
        const airtableHeaders = {
          'Authorization': `Bearer ${AIRTABLE_PAT}`,
          'Content-Type': 'application/json',
          ...headers
        };

        const fetchOptions = {
          method,
          headers: airtableHeaders
        };

        if (body && (method === 'POST' || method === 'PATCH' || method === 'PUT')) {
          fetchOptions.body = JSON.stringify(body);
        }

        const airtableResponse = await fetch(url, fetchOptions);
        const responseData = await airtableResponse.json();

        if (!airtableResponse.ok) {
          throw new Error(`Airtable API error: ${airtableResponse.status} ${airtableResponse.statusText} - ${JSON.stringify(responseData)}`);
        }

        response.status(200).json(responseData);

      } catch (error) {
        console.error('--- CRASH in /api/airtable/request ---');
        console.error('Error object:', error);
        response.status(500).json({ error: `Failed to communicate with Airtable: ${error.message}` });
      }
      break;
    }
    case 'check-credentials': {
      if (request.method !== 'GET') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { AIRTABLE_PAT, AIRTABLE_BASE_ID } = process.env;
        
        if (!AIRTABLE_PAT || !AIRTABLE_BASE_ID) {
          return response.status(200).json({ valid: false });
        }
        
        // Perform a simple, low-cost request to validate credentials
        await makeAirtableRequest('GET', `meta/bases/${AIRTABLE_BASE_ID}/tables`);
        response.status(200).json({ valid: true });
      } catch (error) {
        console.error('Airtable credential check failed:', error);
        response.status(200).json({ valid: false });
      }
      break;
    }
    case 'list-brands': {
      if (request.method !== 'GET') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { AIRTABLE_BASE_ID } = process.env;
        if (!AIRTABLE_BASE_ID) {
          throw new Error('Airtable Base ID not configured on server');
        }
        
        const BRANDS_TABLE_NAME = 'Brands';
        const airtableResponse = await makeAirtableRequest('GET', BRANDS_TABLE_NAME);
        
        const brands = airtableResponse.records.map(record => ({
          id: record.fields.brand_id,
          name: record.fields.name,
          airtableId: record.id
        }));
        
        response.status(200).json({ brands });
      } catch (error) {
        console.error('--- CRASH in /api/airtable/list-brands ---');
        console.error('Error object:', error);
        
        // If the table doesn't exist, return an empty array
        if (error.message && error.message.includes('NOT_FOUND')) {
          console.warn("Brands table not found in Airtable. Returning empty list.");
          return response.status(200).json({ brands: [] });
        }
        
        response.status(500).json({ error: `Failed to fetch brands from Airtable: ${error.message}` });
      }
      break;
    }
    case 'save-ideas': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { ideas } = request.body;

        if (!Array.isArray(ideas) || ideas.length === 0) {
          return response.status(400).json({ error: 'Invalid or empty ideas array provided.' });
        }

        const IDEAS_TABLE = 'Ideas';
        const recordsToCreate = ideas.map(idea => ({
          fields: {
            "Idea": idea.text,
            "Status": "New",
            ...(idea.brandAirtableId && { "Brand": [idea.brandAirtableId] }),
          }
        }));

        const BATCH_SIZE = 10;
        const createdIdeaIds = [];

        for (let i = 0; i < recordsToCreate.length; i += BATCH_SIZE) {
          const batch = recordsToCreate.slice(i, i + BATCH_SIZE);
          const ideasResponse = await makeAirtableRequest('POST', IDEAS_TABLE, { records: batch });
          if (ideasResponse.records) {
            createdIdeaIds.push(...ideasResponse.records.map(r => r.id));
          }
        }

        response.status(200).json({ success: true, createdIds: createdIdeaIds });
      } catch (error) {
        console.error('--- CRASH in /api/airtable/save-ideas ---');
        console.error('Error object:', error);
        response.status(500).json({ error: `Failed to save ideas: ${error.message}` });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['GET', 'POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// Gemini handler
async function handleGeminiRequest(request, response, action) {
  if (!process.env.GEMINI_API_KEY) {
    console.warn("GEMINI_API_KEY is not defined in the .env file. Gemini-related routes will fail.");
  }

  switch (action) {
    case 'generate': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { model, contents, config } = request.body;

        if (!model || !contents) {
          return response.status(400).json({ error: 'Missing required fields: model and contents' });
        }

        const generationConfig = { ...config };
        const systemInstruction = generationConfig?.systemInstruction;
        if (systemInstruction) {
          delete generationConfig.systemInstruction;
        }

        const modelConfig = { model: model };
        if (systemInstruction) {
          modelConfig.systemInstruction = systemInstruction;
        }

        const geminiModel = genAI.getGenerativeModel(modelConfig);

        const generateContentRequest = {
          contents: [{ parts: [{ text: JSON.stringify(contents) }] }]
        };
        
        if (Object.keys(generationConfig).length > 0) {
          generateContentRequest.generationConfig = generationConfig;
        }

        const result = config 
          ? await geminiModel.generateContent(generateContentRequest)
          : await geminiModel.generateContent(JSON.stringify(contents));
        
        const responseText = result.response.text();

        response.status(200).json({ text: responseText });

      } catch (error) {
        console.error('--- CRASH in /api/gemini/generate ---');
        console.error('Error object:', error);
        response.status(500).json({ error: 'Failed to generate content from Gemini API: ' + error.message });
      }
      break;
    }
    case 'generate-image': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { model, prompt, config } = request.body;

        if (!model || !prompt) {
          return response.status(400).json({ error: 'Missing required fields: model and prompt' });
        }

        const generationConfig = { ...config };
        const systemInstruction = generationConfig?.systemInstruction;
        if (systemInstruction) {
          delete generationConfig.systemInstruction;
        }

        const modelConfig = { model: model };
        if (systemInstruction) {
          modelConfig.systemInstruction = systemInstruction;
        }

        const geminiModel = genAI.getGenerativeModel(modelConfig);

        const result = await geminiModel.generateImages({ prompt, config: generationConfig });
        
        if (result.generatedImages && result.generatedImages.length > 0) {
          const base64Image = result.generatedImages[0].image.imageBytes;
          response.status(200).json({ image: `data:image/jpeg;base64,${base64Image}` });
        } else {
          response.status(500).json({ error: 'No image was generated' });
        }

      } catch (error) {
        console.error('--- CRASH in /api/gemini/generate-image ---');
        console.error('Error object:', error);
        response.status(500).json({ error: 'Failed to generate image from Gemini API: ' + error.message });
      }
      break;
    }
    case 'embed': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { texts, taskTypes } = request.body;
        const { GEMINI_API_KEY } = process.env;

        if (!GEMINI_API_KEY) {
          return response.status(500).json({ error: 'Gemini API key not configured on server' });
        }

        if (!texts || !Array.isArray(texts) || !taskTypes || !Array.isArray(taskTypes) || texts.length !== taskTypes.length) {
          return response.status(400).json({ error: 'Invalid request: texts and taskTypes must be arrays of the same length' });
        }

        const ai = new GoogleGenerativeAI(GEMINI_API_KEY);

        const embeddingPromises = texts.map((text, index) => 
          ai.getGenerativeModel({ model: "embedding-001" }).embedContent({
            content: { parts: [{ text }] },
            taskType: taskTypes[index]
          })
        );

        const embeddingResults = await Promise.all(embeddingPromises);
        
        const embeddings = embeddingResults.map(res => res.embedding.values);

        response.status(200).json({ embeddings });

      } catch (error) {
        console.error('--- CRASH in /api/gemini/embed ---');
        console.error('Error object:', error);
        response.status(500).json({ error: `Failed to generate embeddings with Gemini: ${error.message}` });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// OpenRouter handler
async function handleOpenRouterRequest(request, response, action) {
  switch (action) {
    case 'generate':
    case 'generate-image': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { model, messages, responseFormat } = request.body;

        if (!process.env.OPENROUTER_API_KEY) {
          return response.status(500).json({ error: 'OpenRouter API key not configured on server' });
        }

        if (!model || !messages) {
          return response.status(400).json({ error: 'Missing required fields: model and messages' });
        }

        const siteUrl = request.headers.referer || 'https://socialsync.pro';
        const siteTitle = 'SocialSync Pro';

        const body = {
          model: model,
          messages: messages
        };

        if (responseFormat) {
          body.response_format = responseFormat;
        }

        const openrouterResponse = await fetch("https://openrouter.ai/api/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
            "HTTP-Referer": siteUrl,
            "X-Title": siteTitle,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        if (!openrouterResponse.ok) {
          const errorData = await openrouterResponse.json().catch(() => ({}));
          throw new Error(errorData.error?.message || `OpenRouter API error: ${openrouterResponse.status} ${openrouterResponse.statusText}`);
        }

        const responseData = await openrouterResponse.json();
        
        if (action === 'generate') {
          let responseText = '';
          if (responseData.choices && responseData.choices.length > 0 && responseData.choices[0].message?.content) {
            responseText = responseData.choices[0].message.content;
          }
          response.status(200).json({ text: responseText });
        } else {
          let responseImage = '';
          if (responseData.choices && responseData.choices.length > 0 && responseData.choices[0].message?.content) {
            try {
              const content = responseData.choices[0].message.content;
              const parsed = JSON.parse(content);
              if (parsed.b64_json) {
                responseImage = `data:image/jpeg;base64,${parsed.b64_json}`;
              } else {
                responseImage = content;
              }
            } catch (parseError) {
              responseImage = responseData.choices[0].message.content;
            }
          }
          response.status(200).json({ image: responseImage });
        }

      } catch (error) {
        console.error(`--- CRASH in /api/openrouter/${action} ---`);
        console.error('Error object:', error);
        response.status(500).json({ error: `Failed to ${action === 'generate' ? 'generate content' : 'generate image'} from OpenRouter API: ` + error.message });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// Cloudflare handler
async function handleCloudflareRequest(request, response, action) {
  switch (action) {
    case 'generate-image': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { prompt, model, image } = request.body;
        const { CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_API_TOKEN } = process.env;

        if (!CLOUDFLARE_ACCOUNT_ID || !CLOUDFLARE_API_TOKEN) {
          return response.status(500).json({ error: 'Cloudflare credentials not configured on server' });
        }

        if (!model || !prompt) {
          return response.status(400).json({ error: 'Missing required fields: model and prompt' });
        }
        
        const apiUrl = `https://ai-proxy.tk100mil.workers.dev/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/ai/run/${encodeURIComponent(model)}`;

        // The payload can be either text-to-image or image-to-image
        const inputs = {
          prompt,
          negative_prompt: 'text, typography, writing, letters, words, text overlay'
        };

        // Add image if provided (for image-to-image tasks)
        if (image && Array.isArray(image)) {
          inputs.image = image;
        }

        const cloudflareResponse = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(inputs)
        });

        if (!cloudflareResponse.ok) {
          let errorText;
          try {
            const errorData = await cloudflareResponse.json();
            errorText = errorData.errors?.map((e) => e.message).join(', ') || JSON.stringify(errorData);
          } catch (e) {
            errorText = await cloudflareResponse.text();
          }
          throw new Error(`Cloudflare AI Error: ${errorText}`);
        }

        const blob = await cloudflareResponse.blob();
        // Check if the successful response is actually an image
        if (blob.type.startsWith('image/')) {
          const buffer = await blob.arrayBuffer();
          const base64 = Buffer.from(buffer).toString('base64');
          const mimeType = blob.type;
          const dataUrl = `data:${mimeType};base64,${base64}`;
          
          response.status(200).json({ image: dataUrl });
        } else {
          // Handle cases where the server returns OK but sends an error in a non-image format (e.g., JSON)
          const responseText = await blob.text();
          console.error("Cloudflare AI returned a non-image success response:", responseText);
          throw new Error("Cloudflare AI returned an unexpected response format.");
        }

      } catch (error) {
        console.error('--- CRASH in /api/cloudflare/generate-image ---');
        console.error('Error object:', error);
        response.status(500).json({ error: 'Failed to generate image from Cloudflare API: ' + error.message });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// Cloudinary handler
async function handleCloudinaryRequest(request, response, action) {
  switch (action) {
    case 'upload': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { media } = request.body;

        if (!media || typeof media !== 'object') {
          return response.status(400).json({ error: 'Missing or invalid media data' });
        }

        const mediaEntries = Object.entries(media).filter(
          ([, url]) => url && url.startsWith('data:')
        );

        if (mediaEntries.length === 0) {
          return response.status(200).json({ uploadedUrls: {} });
        }

        const uploadPromises = mediaEntries.map(async ([key, url]) => {
          try {
            const isVideo = url.startsWith('data:video');
            const resourceType = isVideo ? 'video' : 'image';
            const uploadUrl = `https://api.cloudinary.com/v1_1/${process.env.CLOUDINARY_CLOUD_NAME}/${resourceType}/upload`;
            
            // Convert data URL to buffer
            const dataUrlParts = url.split(',');
            if (dataUrlParts.length < 2) {
              throw new Error('Invalid data URL format');
            }
            
            const mimePart = dataUrlParts[0].split(':')[1];
            const mimeType = mimePart ? mimePart.split(';')[0] : (isVideo ? 'video/mp4' : 'image/jpeg');
            const base64Data = dataUrlParts[1];
            
            // Clean base64 string
            const cleanedBase64 = base64Data.replace(/\s/g, '');
            const buffer = Buffer.from(cleanedBase64, 'base64');

            // Create form data
            const formData = new FormData();
            formData.append('file', buffer, {
              filename: `${key}.${mimeType.split('/')[1] || 'jpg'}`,
              contentType: mimeType
            });
            formData.append('upload_preset', process.env.CLOUDINARY_UPLOAD_PRESET);
            formData.append('public_id', key);

            const cloudinaryResponse = await fetch(uploadUrl, {
              method: 'POST',
              body: formData,
              headers: formData.getHeaders()
            });

            if (!cloudinaryResponse.ok) {
              const errorData = await cloudinaryResponse.json().catch(() => ({}));
              throw new Error(`Cloudinary upload failed: ${errorData.error?.message || cloudinaryResponse.statusText}`);
            }

            const result = await cloudinaryResponse.json();
            return [key, result.secure_url];
          } catch (error) {
            console.error(`Failed to upload media with key "${key}" to Cloudinary:`, error);
            return null;
          }
        });

        const results = await Promise.all(uploadPromises);
        const uploadedUrls = Object.fromEntries(results.filter(r => r !== null));

        response.status(200).json({ uploadedUrls });

      } catch (error) {
        console.error('--- CRASH in /api/cloudinary/upload ---');
        console.error('Error object:', error);
        response.status(500).json({ error: 'Failed to upload media to Cloudinary: ' + error.message });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// Facebook handler
async function handleFacebookRequest(request, response, action) {
  switch (action) {
    case 'publish': {
      if (request.method !== 'POST') {
        return response.status(405).json({ error: 'Method Not Allowed' });
      }

      try {
        const { post, imageUrl, pageId, accessToken, videoUrl } = request.body;

        if (!pageId || !accessToken) {
          return response.status(400).json({ error: 'Missing required fields: pageId and accessToken' });
        }

        if (!post || typeof post !== 'object') {
          return response.status(400).json({ error: 'Missing or invalid post data' });
        }

        const apiVersion = 'v23.0';
        const fullMessage = `${post.title}\n\n${post.content}\n\n${(post.hashtags || []).join(' ')}\n\nCTA: ${post.cta}`;
        let endpoint = '';
        const params = new URLSearchParams();
        params.append('access_token', accessToken);

        if (imageUrl) {
          endpoint = `https://graph.facebook.com/${apiVersion}/${pageId}/photos`;
          params.append('caption', fullMessage);
          params.append('url', imageUrl);
        } else {
          endpoint = `https://graph.facebook.com/${apiVersion}/${pageId}/feed`;
          params.append('message', fullMessage);
        }

        const facebookResponse = await fetch(`${endpoint}?${params.toString()}`, {
          method: 'POST',
        });

        const responseData = await facebookResponse.json();

        if (!facebookResponse.ok) {
          throw new Error(responseData.error?.message || "Failed to publish to Facebook");
        }

        const postId = responseData.id || responseData.post_id;
        if (!postId) {
          throw new Error("Facebook API did not return a post ID");
        }

        const publishedUrl = `https://www.facebook.com/${postId}`;
        response.status(200).json({ publishedUrl });

      } catch (error) {
        console.error('--- CRASH in /api/facebook/publish ---');
        console.error('Error object:', error);
        response.status(500).json({ error: `Failed to publish to Facebook: ${error.message}` });
      }
      break;
    }
    default:
      response.setHeader('Allow', ['POST']);
      response.status(405).end(`Method ${request.method} Not Allowed for action ${action}`);
  }
}

// MongoDB handler
async function handleMongodbRequest(request, response, action) {
  // All MongoDB endpoints are POST requests
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  try {
    // Dynamically import the appropriate MongoDB handler based on the action
    let handlerModule;
    
    // Special handling for actions that have their own dedicated files
    switch (action) {
      case 'initial-load':
        handlerModule = await import('./mongodb/initial-load.js');
        break;
      case 'list-media-plan-groups':
        handlerModule = await import('./mongodb/list-media-plan-groups.js');
        break;
      case 'load-affiliate-vault':
        handlerModule = await import('./mongodb/load-affiliate-vault.js');
        break;
      case 'load-media-plan-posts-with-pagination':
        handlerModule = await import('./mongodb/load-media-plan-posts-with-pagination.js');
        break;
      case 'load-media-plan-posts':
        handlerModule = await import('./mongodb/load-media-plan-posts.js');
        break;
      case 'load-personas':
        handlerModule = await import('./mongodb/load-personas.js');
        break;
      case 'load-strategy-hub':
        handlerModule = await import('./mongodb/load-strategy-hub.js');
        break;
      case 'affiliate-vault':
        handlerModule = await import('./mongodb/affiliate-vault.js');
        break;
      case 'media-plan-posts':
        handlerModule = await import('./mongodb/media-plan-posts.js');
        break;
      case 'personas':
        handlerModule = await import('./mongodb/personas.js');
        break;
      case 'strategy-hub':
        handlerModule = await import('./mongodb/strategy-hub.js');
        break;
      default:
        // For all other actions, use the main [action].js file
        handlerModule = await import('./mongodb/[action].js');
        break;
    }
    
    // Call the handler function from the imported module
    return await handlerModule.default(request, response);
  } catch (error) {
    console.error(`--- CRASH in /api/mongodb/${action} ---`);
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to process action ${action}: ${error.message}` });
  }
}

// Health check handler
async function handleHealthRequest(request, response) {
  if (request.method !== 'GET') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  response.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    services: {
      gemini: !!process.env.GEMINI_API_KEY,
      openrouter: !!process.env.OPENROUTER_API_KEY,
      cloudflare: !!(process.env.CLOUDFLARE_ACCOUNT_ID && process.env.CLOUDFLARE_API_TOKEN),
      cloudinary: !!(process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_UPLOAD_PRESET),
      facebook: !!(process.env.FACEBOOK_APP_ID),
      airtable: !!(process.env.AIRTABLE_PAT && process.env.AIRTABLE_BASE_ID),
      mongodb: !!process.env.MONGODB_URI
    }
  });
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\index.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudflare\generate-image.js ---\nimport { allowCors } from './lib/cors.js';
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/cloudflare/generate-image ---');
  try {
    const { prompt, model, image } = request.body;
    const { CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_API_TOKEN } = process.env;

    if (!CLOUDFLARE_ACCOUNT_ID || !CLOUDFLARE_API_TOKEN) {
      return response.status(500).json({ error: 'Cloudflare credentials not configured on server' });
    }

    if (!model || !prompt) {
      return response.status(400).json({ error: 'Missing required fields: model and prompt' });
    }
    const apiUrl = `https://ai-proxy.tk100mil.workers.dev/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/ai/run/${encodeURIComponent(model)}`;

    // The payload can be either text-to-image or image-to-image
    const inputs = {
      prompt,
      negative_prompt: 'text, typography, writing, letters, words, text overlay'
    };

    // Add image if provided (for image-to-image tasks)
    if (image && Array.isArray(image)) {
      inputs.image = image;
    }

    const cloudflareResponse = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(inputs)
    });

    if (!cloudflareResponse.ok) {
      let errorText;
      try {
        const errorData = await cloudflareResponse.json();
        errorText = errorData.errors?.map((e) => e.message).join(', ') || JSON.stringify(errorData);
      } catch (e) {
        errorText = await cloudflareResponse.text();
      }
      throw new Error(`Cloudflare AI Error: ${errorText}`);
    }

    const blob = await cloudflareResponse.blob();
    // Check if the successful response is actually an image
    if (blob.type.startsWith('image/')) {
      const buffer = await blob.arrayBuffer();
      const base64 = Buffer.from(buffer).toString('base64');
      const mimeType = blob.type;
      const dataUrl = `data:${mimeType};base64,${base64}`;
      
      response.status(200).json({ image: dataUrl });
    } else {
      // Handle cases where the server returns OK but sends an error in a non-image format (e.g., JSON)
      const responseText = await blob.text();
      console.error("Cloudflare AI returned a non-image success response:", responseText);
      throw new Error("Cloudflare AI returned an unexpected response format.");
    }

    console.log('--- Cloudflare image response sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/cloudflare/generate-image ---');
    console.error('Error object:', error);
    response.status(500).json({ error: 'Failed to generate image from Cloudflare API: ' + error.message });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudflare\generate-image.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudinary\upload.js ---\nimport { allowCors } from './lib/cors.js';
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const FormData = require('form-data');

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/cloudinary/upload ---');
  try {
    const { media } = request.body;

    if (!media || typeof media !== 'object') {
      return response.status(400).json({ error: 'Missing or invalid media data' });
    }

    const mediaEntries = Object.entries(media).filter(
      ([, url]) => url && url.startsWith('data:')
    );

    if (mediaEntries.length === 0) {
      return response.status(200).json({ uploadedUrls: {} });
    }

    const uploadPromises = mediaEntries.map(async ([key, url]) => {
      try {
        const isVideo = url.startsWith('data:video');
        const resourceType = isVideo ? 'video' : 'image';
        const uploadUrl = `https://api.cloudinary.com/v1_1/${process.env.CLOUDINARY_CLOUD_NAME}/${resourceType}/upload`;
        
        console.log(uploadUrl)

        // Convert data URL to buffer
        const dataUrlParts = url.split(',');
        if (dataUrlParts.length < 2) {
          throw new Error('Invalid data URL format');
        }
        
        const mimePart = dataUrlParts[0].split(':')[1];
        const mimeType = mimePart ? mimePart.split(';')[0] : (isVideo ? 'video/mp4' : 'image/jpeg');
        const base64Data = dataUrlParts[1];
        
        // Clean base64 string
        const cleanedBase64 = base64Data.replace(/\s/g, '');
        const buffer = Buffer.from(cleanedBase64, 'base64');

        // Create form data
        const formData = new FormData();
        formData.append('file', buffer, {
          filename: `${key}.${mimeType.split('/')[1] || 'jpg'}`,
          contentType: mimeType
        });
        formData.append('upload_preset', process.env.CLOUDINARY_UPLOAD_PRESET);
        formData.append('public_id', key);

        const cloudinaryResponse = await fetch(uploadUrl, {
          method: 'POST',
          body: formData,
          headers: formData.getHeaders()
        });

        if (!cloudinaryResponse.ok) {
          const errorData = await cloudinaryResponse.json().catch(() => ({}));
          throw new Error(`Cloudinary upload failed: ${errorData.error?.message || cloudinaryResponse.statusText}`);
        }

        const result = await cloudinaryResponse.json();
        return [key, result.secure_url];
      } catch (error) {
        console.error(`Failed to upload media with key "${key}" to Cloudinary:`, error);
        return null;
      }
    });

    const results = await Promise.all(uploadPromises);
    const uploadedUrls = Object.fromEntries(results.filter(r => r !== null));

    response.status(200).json({ uploadedUrls });
    console.log('--- Cloudinary upload response sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/cloudinary/upload ---');
    console.error('Error object:', error);
    response.status(500).json({ error: 'Failed to upload media to Cloudinary: ' + error.message });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\cloudinary\upload.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\facebook\publish.js ---\nimport { allowCors } from './lib/cors.js';
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/facebook/publish ---');
  try {
    const { post, imageUrl, pageId, accessToken, videoUrl } = request.body;

    if (!pageId || !accessToken) {
      return response.status(400).json({ error: 'Missing required fields: pageId and accessToken' });
    }

    if (!post || typeof post !== 'object') {
      return response.status(400).json({ error: 'Missing or invalid post data' });
    }

    const apiVersion = 'v23.0';
    const fullMessage = `${post.title}\n\n${post.content}\n\n${(post.hashtags || []).join(' ')}\n\nCTA: ${post.cta}`;
    let endpoint = '';
    const params = new URLSearchParams();
    params.append('access_token', accessToken);

    console.log("Page ID right before URL construction:", pageId); // New diagnostic log

    if (imageUrl) {
      endpoint = `https://graph.facebook.com/${apiVersion}/${pageId}/photos`;
      params.append('caption', fullMessage);
      params.append('url', imageUrl);
    } else {
      endpoint = `https://graph.facebook.com/${apiVersion}/${pageId}/feed`;
      params.append('message', fullMessage);
    }

    const facebookResponse = await fetch(`${endpoint}?${params.toString()}`, {
      method: 'POST',
    });

    const responseData = await facebookResponse.json();

    if (!facebookResponse.ok) {
      throw new Error(responseData.error?.message || "Failed to publish to Facebook");
    }

    const postId = responseData.id || responseData.post_id;
    if (!postId) {
      throw new Error("Facebook API did not return a post ID");
    }

    const publishedUrl = `https://www.facebook.com/${postId}`;
    response.status(200).json({ publishedUrl });
    console.log('--- Facebook publish response sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/facebook/publish ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to publish to Facebook: ${error.message}` });
  }
}

export default allowCors(handler);
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\facebook\publish.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini\[action].js ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\gemini\[action].js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\airtable.js ---\nconst fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

// Get timeout from environment variable or default to 15 seconds
const AIRTABLE_REQUEST_TIMEOUT = parseInt(process.env.AIRTABLE_REQUEST_TIMEOUT) || 15000;

// Retry function with exponential backoff
const retryWithBackoff = async (fn, retries = 3, delay = 1000) => {
  let lastError;
  
  for (let i = 0; i <= retries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      // If this is the last retry, don't wait and re-throw
      if (i === retries) {
        throw lastError;
      }
      
      // Don't retry on client errors (4xx) except for rate limiting (429)
      if (error.status >= 400 && error.status < 500 && error.status !== 429) {
        throw lastError;
      }
      
      // Log retry attempt
      console.warn(`Airtable request failed, retrying in ${delay}ms... (attempt ${i + 1}/${retries + 1})`);
      
      // Wait for the specified delay
      await new Promise(resolve => setTimeout(resolve, delay));
      
      // Double the delay for next retry (exponential backoff)
      delay *= 2;
    }
  }
  
  throw lastError;
};

export const makeAirtableRequest = async (method, path, body = null) => {
  const { AIRTABLE_PAT, AIRTABLE_BASE_ID } = process.env;

  if (!AIRTABLE_PAT || !AIRTABLE_BASE_ID) {
    const missing = [];
    if (!AIRTABLE_PAT) missing.push('AIRTABLE_PAT');
    if (!AIRTABLE_BASE_ID) missing.push('AIRTABLE_BASE_ID');
    throw new Error(`Airtable credentials not configured on server. Missing: ${missing.join(', ')}`);
  }

  // Handle different types of paths:
  // 1. Meta operations like "meta/bases/tables" should become "meta/bases/${AIRTABLE_BASE_ID}/tables"
  // 2. Table operations like "Brands" should become "${AIRTABLE_BASE_ID}/Brands"
  let fullPath;
  if (path.startsWith('meta/bases/')) {
    // Meta operation - insert the base ID after "meta/bases/"
    fullPath = path.replace('meta/bases/', `meta/bases/${AIRTABLE_BASE_ID}/`);
  } else {
    // Regular table operation - prepend the base ID
    fullPath = `${AIRTABLE_BASE_ID}/${path}`;
  }
  
  const url = `https://api.airtable.com/v0/${fullPath}`;
  
  const airtableHeaders = {
    'Authorization': `Bearer ${AIRTABLE_PAT}`,
    'Content-Type': 'application/json'
  };

  const fetchOptions = { 
    method, 
    headers: airtableHeaders,
    timeout: AIRTABLE_REQUEST_TIMEOUT
  };
  
  if (body && (method === 'POST' || method === 'PATCH' || method === 'PUT')) {
    fetchOptions.body = JSON.stringify(body);
  }

  try {
    // Wrap the fetch call with retry logic
    const responseData = await retryWithBackoff(async () => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), AIRTABLE_REQUEST_TIMEOUT);
      
      try {
        const response = await fetch(url, {
          ...fetchOptions,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        const data = await response.json();

        if (!response.ok) {
          // Attach status to error object for retry logic
          const error = new Error(`Airtable API error: ${response.status} ${response.statusText} - ${JSON.stringify(data)}`);
          error.status = response.status;
          throw error;
        }

        return data;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }, 3, 1000); // 3 retries, starting with 1 second delay

    return responseData;
  } catch (error) {
    // Log the final error for debugging
    console.error('Airtable request failed after all retries:', error);
    
    // Re-throw with a more descriptive message
    if (error.name === 'AbortError') {
      throw new Error(`Airtable API timeout: Request took longer than ${AIRTABLE_REQUEST_TIMEOUT}ms`);
    }
    
    throw error;
  }
};

// Helper function to find a record by field value
export const findRecordByField = async (tableName, fieldName, value) => {
  const encodedValue = encodeURIComponent(value);
  const path = `${tableName}?filterByFormula={${fieldName}}='${encodedValue}'`;
  const response = await makeAirtableRequest('GET', path);
  
  if (!response || !Array.isArray(response.records)) {
    return null;
  }
  
  const record = response.records && response.records.length > 0 ? response.records[0] : null;
  
  if (record && (!record.id || typeof record.id !== 'string')) {
    return null;
  }
  
  return record;
};

// Helper function to fetch records by formula
export const fetchFullRecordsByFormula = async (tableName, formula, fields) => {
  let path = `${tableName}`;
  const queryParams = [];

  if (formula) {
    queryParams.push(`filterByFormula=${encodeURIComponent(formula)}`);
  }

  if (fields && fields.length > 0) {
    fields.forEach(f => queryParams.push(`fields[]=${encodeURIComponent(f)}`));
  }

  if (queryParams.length > 0) {
    path += '?' + queryParams.join('&');
  }

  const response = await makeAirtableRequest('GET', path);
  return response.records || [];
};

// Helper function to get record ID from custom ID
export const getRecordIdFromCustomId = async (tableName, customIdField, customIdValue) => {
  const record = await findRecordByField(tableName, customIdField, customIdValue);
  if (record && record.id) {
    return record.id;
  }
  return null;
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\airtable.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\cors.js ---\n
export const allowCors = (fn) => async (req, res) => {
  res.setHeader('Access-Control-Allow-Credentials', true);
  res.setHeader('Access-Control-Allow-Origin', '*'); // Allow any origin
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );

  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  return await fn(req, res);
};
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\cors.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\mongodb.js ---\nimport { MongoClient } from 'mongodb';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
dotenv.config({ path: join(__dirname, '..', '..', '.env.local') });

// Global variables to cache the client and database connection
let cachedClient = null;
let cachedDb = null;

/**
 * MongoDB Connection Utility for Serverless Environments
 * 
 * This utility handles MongoDB connections in a serverless environment.
 * It implements connection caching to prevent creating new connections on every function invocation,
 * which would quickly exhaust the database connection pool.
 * 
 * The utility exports a function getClientAndDb() that returns a connected client and database instance.
 * It handles:
 * 1. Checking for cached connections
 * 2. Creating new connections when needed
 * 3. Properly connecting to MongoDB
 * 4. Caching connections for reuse
 * 
 * Usage:
 * import { getClientAndDb } from '../lib/mongodb.js';
 * const { client, db } = await getClientAndDb();
 * const collection = db.collection('collectionName');
 * // Perform database operations
 */

export async function getClientAndDb() {
  // Check if we have a cached connection
  if (cachedClient && cachedDb) {
    return { client: cachedClient, db: cachedDb };
  }

  // Get MongoDB URI from environment variables
  const MONGODB_URI = process.env.MONGODB_URI;
  
  if (!MONGODB_URI) {
    throw new Error('MONGODB_URI is not defined in environment variables');
  }

  // Create a new MongoClient instance
  const client = new MongoClient(MONGODB_URI, {
    // Connection options for better performance in serverless environments
    useUnifiedTopology: true,
    useNewUrlParser: true,
    // Connection pool settings
    maxPoolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
  });

  try {
    // Connect to MongoDB
    await client.connect();
    
    // Get the database name from the URI or use a default
    const dbName = new URL(MONGODB_URI).pathname.substring(1) || 'socialsync';
    const db = client.db(dbName);
    
    // Cache the client and database for future use
    cachedClient = client;
    cachedDb = db;
    
    return { client, db };
  } catch (error) {
    console.error('Failed to connect to MongoDB:', error);
    throw new Error(`Failed to connect to MongoDB: ${error.message}`);
  }
}

/**
 * Helper function to close the MongoDB connection
 * This should be called when the application is shutting down
 */
export async function closeConnection() {
  if (cachedClient) {
    await cachedClient.close();
    cachedClient = null;
    cachedDb = null;
  }
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\lib\mongodb.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\affiliate-vault.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/affiliate-vault ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch affiliate links data from MongoDB
    const collection = db.collection('affiliateProducts');
    const linkRecords = await collection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const affiliateLinks = linkRecords.map((record) => ({
      id: record._id.toString(),
      productId: record.productId,
      productName: record.productName,
      price: record.price,
      salesVolume: record.salesVolume,
      providerName: record.providerName,
      commissionRate: record.commissionRate,
      commissionValue: record.commissionValue,
      productLink: record.productLink,
      promotionLink: record.promotionLink,
      product_avatar: record.productAvatar,
      product_description: record.productDescription,
      features: record.features || [],
      use_cases: record.useCases || [],
      customer_reviews: record.customerReviews,
      product_rating: record.productRating,
      product_image_links: record.productImageLinks || [],
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({ affiliateLinks });
    console.log('--- Affiliate vault data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/affiliate-vault ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load affiliate vault data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\affiliate-vault.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\initial-load.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/initial-load ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch the brand record
    const brandsCollection = db.collection('brands');
    const brandRecord = await brandsCollection.findOne({ brandId: brandId });
    
    if (!brandRecord) {
      return response.status(404).json({ error: `Brand with ID ${brandId} not found.` });
    }

    // Fetch brand summary data for instant rendering
    const brandSummary = {
      id: brandRecord.brandId,
      name: brandRecord.name,
      logoUrl: brandRecord.logoUrl // Assuming there's a logoUrl field
    };

    // Fetch complete brand foundation data (for BrandKitView)
    const brandValuesCollection = db.collection('brandValues');
    const keyMessagesCollection = db.collection('keyMessages');
    const logoConceptsCollection = db.collection('logoConcepts');
    
    const brandValueRecords = await brandValuesCollection.find({ brandId: brandId }).toArray();
    const keyMessageRecords = await keyMessagesCollection.find({ brandId: brandId }).toArray();
    const logoConceptRecords = await logoConceptsCollection.find({ brandId: brandId }).toArray();

    const brandValues = brandValueRecords.map((record) => record.text);
    const keyMessages = keyMessageRecords.map((record) => record.text);
    const logoConcepts = logoConceptRecords.map((record) => ({
      id: record._id.toString(),
      style: record.style,
      prompt: record.prompt,
      imageKey: record.imageKey,
    }));

    const brandFoundation = {
      brandName: brandRecord.name,
      mission: brandRecord.mission,
      values: brandValues,
      targetAudience: brandRecord.targetAudience,
      personality: brandRecord.personality,
      keyMessaging: keyMessages,
      usp: brandRecord.usp,
    };

    const coreMediaAssets = {
      logoConcepts,
      colorPalette: brandRecord.colorPalette || {},
      fontRecommendations: brandRecord.fontRecommendations || {},
    };

    const unifiedProfileAssets = brandRecord.unifiedProfileAssets || {};

    const brandKitData = {
      brandFoundation,
      coreMediaAssets,
      unifiedProfileAssets
    };

    // Return both summary and brand kit data for instant rendering of BrandKitView
    response.status(200).json({
      brandSummary,
      brandKitData
    });
    console.log('--- Initial load data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/initial-load ---');
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    response.status(500).json({ error: `Failed to load initial data: ${error.message}`, details: error.message });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\initial-load.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\list-media-plan-groups.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/list-media-plan-groups ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch media plan groups data from MongoDB
    const collection = db.collection('mediaPlanGroups');
    const planRecords = await collection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const groups = planRecords.map((record) => ({
      id: record._id.toString(),
      name: record.name,
      prompt: record.prompt,
      source: record.source,
      productImages: record.productImages || [],
      personaId: record.personaId,
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({ groups });
    console.log('--- Media plan groups list sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/list-media-plan-groups ---');
    console.error('Error object:', error);
    
    response.status(500).json({ error: `Failed to fetch media plan groups from MongoDB: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\list-media-plan-groups.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-affiliate-vault.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/load-affiliate-vault ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch affiliate links data from MongoDB
    const collection = db.collection('affiliateProducts');
    const linkRecords = await collection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const affiliateLinks = linkRecords.map((record) => ({
      id: record._id.toString(),
      productId: record.productId,
      productName: record.productName,
      price: record.price,
      salesVolume: record.salesVolume,
      providerName: record.providerName,
      commissionRate: record.commissionRate,
      commissionValue: record.commissionValue,
      productLink: record.productLink,
      promotionLink: record.promotionLink,
      product_avatar: record.productAvatar,
      product_description: record.productDescription,
      features: record.features || [],
      use_cases: record.useCases || [],
      customer_reviews: record.customerReviews,
      product_rating: record.productRating,
      product_image_links: record.productImageLinks || [],
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({ affiliateLinks });
    console.log('--- Affiliate vault data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/load-affiliate-vault ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load affiliate vault data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-affiliate-vault.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts-with-pagination.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/load-media-plan-posts-with-pagination ---');
  try {
    const { planId, page = 1, limit = 30 } = request.body;

    if (!planId) {
      return response.status(400).json({ error: 'Missing planId in request body' });
    }

    // Calculate offset for pagination
    const offset = (page - 1) * limit;

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch posts for the specific media plan with pagination
    const collection = db.collection('mediaPlanPosts');
    const allPostRecords = await collection.find({ mediaPlanId: planId }).toArray();
    
    // Sort posts by week and then by post order if available
    allPostRecords.sort((a, b) => {
      const weekA = a.week || 0;
      const weekB = b.week || 0;
      if (weekA !== weekB) return weekA - weekB;
      
      // If week is the same, sort by post order or creation date
      const orderA = a.postOrder || new Date(a.createdTime || 0).getTime();
      const orderB = b.postOrder || new Date(b.createdTime || 0).getTime();
      return orderA - orderB;
    });
    
    // Apply pagination
    const paginatedPosts = allPostRecords.slice(offset, offset + limit);
    
    const posts = paginatedPosts.map((record) => ({
      id: record._id.toString(),
      platform: record.platform,
      contentType: record.contentType,
      title: record.title,
      content: record.content,
      description: record.description,
      hashtags: record.hashtags || [],
      cta: record.cta,
      mediaPrompt: record.mediaPrompt,
      script: record.script,
      imageKey: record.imageKey,
      videoKey: record.videoKey,
      mediaOrder: record.mediaOrder || [],
      sources: record.sources || [],
      promotedProductIds: record.promotedProductIds || [],
      scheduledAt: record.scheduledAt,
      publishedAt: record.publishedAt,
      publishedUrl: record.publishedUrl,
      autoComment: record.autoComment,
      status: record.status,
      isPillar: record.isPillar,
      week: record.week,
      postOrder: record.postOrder,
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({
      posts,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(allPostRecords.length / limit),
        totalPosts: allPostRecords.length,
        hasNextPage: offset + limit < allPostRecords.length,
        hasPrevPage: page > 1
      }
    });
    console.log('--- Media plan posts with pagination sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/load-media-plan-posts-with-pagination ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load media plan posts: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts-with-pagination.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/load-media-plan-posts ---');
  try {
    const { planId, page = 1, limit = 30 } = request.body;

    if (!planId) {
      return response.status(400).json({ error: 'Missing planId in request body' });
    }

    // Calculate offset for pagination
    const offset = (page - 1) * limit;

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch posts for the specific media plan with pagination
    const collection = db.collection('mediaPlanPosts');
    const allPostRecords = await collection.find({ mediaPlanId: planId }).toArray();
    
    // Sort posts by week and then by post order if available
    allPostRecords.sort((a, b) => {
      const weekA = a.week || 0;
      const weekB = b.week || 0;
      if (weekA !== weekB) return weekA - weekB;
      
      // If week is the same, sort by post order or creation date
      const orderA = a.postOrder || new Date(a.createdTime || 0).getTime();
      const orderB = b.postOrder || new Date(b.createdTime || 0).getTime();
      return orderA - orderB;
    });
    
    // Apply pagination
    const paginatedPosts = allPostRecords.slice(offset, offset + limit);
    
    const posts = paginatedPosts.map((record) => ({
      id: record._id.toString(),
      platform: record.platform,
      contentType: record.contentType,
      title: record.title,
      content: record.content,
      description: record.description,
      hashtags: record.hashtags || [],
      cta: record.cta,
      mediaPrompt: record.mediaPrompt,
      script: record.script,
      imageKey: record.imageKey,
      videoKey: record.videoKey,
      mediaOrder: record.mediaOrder || [],
      sources: record.sources || [],
      promotedProductIds: record.promotedProductIds || [],
      scheduledAt: record.scheduledAt,
      publishedAt: record.publishedAt,
      publishedUrl: record.publishedUrl,
      autoComment: record.autoComment,
      status: record.status,
      isPillar: record.isPillar,
      week: record.week,
      postOrder: record.postOrder,
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({
      posts,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(allPostRecords.length / limit),
        totalPosts: allPostRecords.length,
        hasNextPage: offset + limit < allPostRecords.length,
        hasPrevPage: page > 1
      }
    });
    console.log('--- Media plan posts sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/load-media-plan-posts ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load media plan posts: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-media-plan-posts.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-personas.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/load-personas ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch personas data from MongoDB
    const collection = db.collection('personas');
    const personaRecords = await collection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    // Convert _id to id and remove _id field
    const personas = personaRecords.map((record) => ({
      id: record._id.toString(),
      nickName: record.nickName,
      mainStyle: record.mainStyle,
      activityField: record.activityField,
      outfitDescription: record.outfitDescription,
      avatarImageKey: record.avatarImageKey,
      avatarImageUrl: record.avatarImageUrl,
      photos: record.photos || [], // Will be populated on client side if needed
      socialAccounts: record.socialAccounts || [], // Will be populated on client side if needed
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({ personas });
    console.log('--- Personas data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/load-personas ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load personas data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-personas.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-strategy-hub.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/load-strategy-hub ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch trends data from MongoDB
    const trendsCollection = db.collection('trends');
    const trendRecords = await trendsCollection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const trends = trendRecords.map((record) => ({
      id: record._id.toString(),
      brandId: record.brandId,
      industry: record.industry,
      topic: record.topic,
      keywords: record.keywords || [],
      links: record.links || [],
      notes: record.notes,
      analysis: record.analysis,
      createdAt: record.createdAt,
      ...record // Include any other fields that might be in the record
    }));

    // Fetch ideas data (only for existing trends)
    const trendIds = trendRecords.map(r => r._id.toString());
    let ideas = [];
    
    if (trendIds.length > 0) {
      const ideasCollection = db.collection('ideas');
      const ideaRecords = await ideasCollection.find({ trendId: { $in: trendIds } }).toArray();
      
      // Transform MongoDB records to match the expected API response format
      ideas = ideaRecords.map((record) => ({
        id: record._id.toString(),
        trendId: record.trendId,
        title: record.title,
        description: record.description,
        targetAudience: record.targetAudience,
        productId: record.productId,
        ...record // Include any other fields that might be in the record
      }));
    }

    response.status(200).json({ trends, ideas });
    console.log('--- Strategy hub data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/load-strategy-hub ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load strategy hub data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\load-strategy-hub.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\media-plan-posts.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/media-plan-posts ---');
  try {
    const { planId, page = 1, limit = 30 } = request.body;

    if (!planId) {
      return response.status(400).json({ error: 'Missing planId in request body' });
    }

    // Calculate offset for pagination
    const offset = (page - 1) * limit;

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch posts for the specific media plan with pagination
    const collection = db.collection('mediaPlanPosts');
    const allPostRecords = await collection.find({ mediaPlanId: planId }).toArray();
    
    // Sort posts by week and then by post order if available
    allPostRecords.sort((a, b) => {
      const weekA = a.week || 0;
      const weekB = b.week || 0;
      if (weekA !== weekB) return weekA - weekB;
      
      // If week is the same, sort by post order or creation date
      const orderA = a.postOrder || new Date(a.createdTime || 0).getTime();
      const orderB = b.postOrder || new Date(b.createdTime || 0).getTime();
      return orderA - orderB;
    });
    
    // Apply pagination
    const paginatedPosts = allPostRecords.slice(offset, offset + limit);
    
    const posts = paginatedPosts.map((record) => ({
      id: record._id.toString(),
      platform: record.platform,
      contentType: record.contentType,
      title: record.title,
      content: record.content,
      description: record.description,
      hashtags: record.hashtags || [],
      cta: record.cta,
      mediaPrompt: record.mediaPrompt,
      script: record.script,
      imageKey: record.imageKey,
      videoKey: record.videoKey,
      mediaOrder: record.mediaOrder || [],
      sources: record.sources || [],
      promotedProductIds: record.promotedProductIds || [],
      scheduledAt: record.scheduledAt,
      publishedAt: record.publishedAt,
      publishedUrl: record.publishedUrl,
      autoComment: record.autoComment,
      status: record.status,
      isPillar: record.isPillar,
      week: record.week,
      postOrder: record.postOrder,
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({
      posts,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(allPostRecords.length / limit),
        totalPosts: allPostRecords.length,
        hasNextPage: offset + limit < allPostRecords.length,
        hasPrevPage: page > 1
      }
    });
    console.log('--- Media plan posts sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/media-plan-posts ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load media plan posts: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\media-plan-posts.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\personas.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/personas ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch personas data from MongoDB
    const collection = db.collection('personas');
    const personaRecords = await collection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const personas = personaRecords.map((record) => ({
      id: record._id.toString(),
      nickName: record.nickName,
      outfitDescription: record.outfitDescription,
      mainStyle: record.mainStyle,
      activityField: record.activityField,
      avatarImageKey: record.avatarImageKey,
      avatarImageUrl: record.avatarImageUrl,
      photos: record.photos || [], // Will be populated on client side if needed
      socialAccounts: record.socialAccounts || [], // Will be populated on client side if needed
      ...record // Include any other fields that might be in the record
    }));

    response.status(200).json({ personas });
    console.log('--- Personas data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/personas ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load personas data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\personas.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\strategy-hub.js ---\nimport { getClientAndDb } from '../lib/mongodb.js';
import { allowCors } from '../lib/cors.js';

async function handler(request, response) {
  if (request.method !== 'POST') {
    return response.status(405).json({ error: 'Method Not Allowed' });
  }

  console.log('--- Received request for /api/mongodb/strategy-hub ---');
  try {
    const { brandId } = request.body;

    if (!brandId) {
      return response.status(400).json({ error: 'Missing brandId in request body' });
    }

    // Get MongoDB client and database instance
    const { client, db } = await getClientAndDb();
    
    // Fetch trends data from MongoDB
    const trendsCollection = db.collection('trends');
    const trendRecords = await trendsCollection.find({ brandId: brandId }).toArray();
    
    // Transform MongoDB records to match the expected API response format
    const trends = trendRecords.map((record) => ({
      id: record._id.toString(),
      brandId: record.brandId,
      industry: record.industry,
      topic: record.topic,
      keywords: record.keywords || [],
      links: record.links || [],
      notes: record.notes,
      analysis: record.analysis,
      createdAt: record.createdAt,
      ...record // Include any other fields that might be in the record
    }));

    // Fetch ideas data (only for existing trends)
    const trendIds = trendRecords.map(r => r._id.toString());
    let ideas = [];
    
    if (trendIds.length > 0) {
      const ideasCollection = db.collection('ideas');
      const ideaRecords = await ideasCollection.find({ trendId: { $in: trendIds } }).toArray();
      
      // Transform MongoDB records to match the expected API response format
      ideas = ideaRecords.map((record) => ({
        id: record._id.toString(),
        trendId: record.trendId,
        title: record.title,
        description: record.description,
        targetAudience: record.targetAudience,
        productId: record.productId,
        ...record // Include any other fields that might be in the record
      }));
    }

    response.status(200).json({ trends, ideas });
    console.log('--- Strategy hub data sent to client ---');

  } catch (error) {
    console.error('--- CRASH in /api/mongodb/strategy-hub ---');
    console.error('Error object:', error);
    response.status(500).json({ error: `Failed to load strategy hub data: ${error.message}` });
  }
}

export default allowCors(handler);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\strategy-hub.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\[action].js ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\mongodb\[action].js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\openrouter\[action].js ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\api\openrouter\[action].js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\AI_ADMIN_IMPLEMENTATION.md ---\n# AI Services Administration Implementation

## Overview
This implementation provides a comprehensive admin panel for managing AI services and their supported models with persistent storage in Airtable.

## Features Implemented

### 1. Database Schema
- Added `AI_Services` table with fields:
  - `service_id` (Primary Key)
  - `name`
  - `description`
- Added `AI_Models` table with fields:
  - `model_id` (Primary Key)
  - `name`
  - `provider`
  - `capabilities` (Multiple Select)
  - `service` (Linked Record to AI_Services)

### 2. Admin Panel (AdminPage.tsx)
- Full CRUD operations for AI services and models
- Sample data loading functionality
- Airtable integration for persistent storage
- Responsive UI with editing capabilities
- Error handling and loading states

### 3. Airtable Service Integration
- Added `saveAIService` function to create/update AI services
- Added `deleteAIService` function to remove AI services and their associated models
- Added `saveAIModel` function to create/update AI models
- Added `deleteAIModel` function to remove AI models
- Added `loadAIServices` function to retrieve all AI services with their models

### 4. Settings Integration
- Updated SettingsModal to dynamically load AI models from Airtable
- Enhanced model selection dropdowns with custom AI service models
- Maintained backward compatibility with default models

## Technical Details

### Data Structure
```typescript
interface AIModel {
  id: string;
  name: string;
  provider: string;
  capabilities: string[];
}

interface AIService {
  id: string;
  name: string;
  description: string;
  models: AIModel[];
}
```

### API Functions
- `saveAIService(service, brandId)` - Creates or updates an AI service
- `deleteAIService(serviceId, brandId)` - Deletes an AI service and all its models
- `saveAIModel(model, serviceId)` - Creates or updates an AI model
- `deleteAIModel(modelId)` - Deletes an AI model
- `loadAIServices(brandId)` - Loads all AI services with their models

## Usage
1. Navigate to `/admin` in the application
2. Log in with the configured admin password
3. Add new AI services and models using the forms
4. Load sample data to quickly populate with common providers
5. Models are automatically available in the Settings panel for selection

## Future Improvements
- Add pagination for large datasets
- Implement search and filtering capabilities
- Add bulk import/export functionality
- Enhance error handling with user-friendly messages
- Add validation for duplicate service/model names\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\AI_ADMIN_IMPLEMENTATION.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\BFF_IMPLEMENTATION.md ---\n# Backend-for-Frontend (BFF) Implementation

## Overview

The Backend-for-Frontend (BFF) pattern has been implemented in SocialSync Pro to address several key architectural concerns:

1. **Security**: API keys for external services (Gemini, Airtable, Cloudinary, Facebook) are now stored securely on the backend
2. **Centralization**: All external API communications are handled through a single, dedicated service
3. **Scalability**: The BFF can be scaled independently of the frontend application
4. **Caching**: Server-side caching opportunities are now possible

## Architecture

```
Frontend (Browser) ↔ BFF (Node.js/Express) ↔ External Services
                           ↕
                      Airtable API
                      Gemini API
                      Cloudinary API
                      Facebook Graph API
```

## BFF Endpoints

### Gemini API Endpoints

- `POST /api/gemini/generate` - Generate text content using Gemini
- `POST /api/gemini/generate-image` - Generate images using Gemini

### Cloudinary API Endpoints

- `POST /api/cloudinary/upload` - Upload media files to Cloudinary

### Facebook API Endpoints

- `POST /api/facebook/publish` - Publish content to Facebook

### Airtable API Endpoints

- `POST /api/airtable/request` - Generic proxy for all Airtable API requests

### Health Check

- `GET /api/health` - Check BFF service status

## Implementation Details

### Frontend Integration

The frontend uses a new `bffService.ts` module that provides helper functions for all BFF communications. Each external service module (e.g., `geminiService.ts`, `cloudinaryService.ts`) has been updated to:

1. First attempt to use the BFF endpoint
2. Fall back to direct API calls if the BFF is unavailable

This ensures backward compatibility while providing the security benefits of the BFF pattern.

### Backend Implementation

The BFF is implemented as a standalone Express.js server with:

1. **HTTPS Support**: Uses self-signed certificates for local development
2. **CORS Configuration**: Allows requests from localhost origins
3. **Error Handling**: Comprehensive error handling with detailed logging
4. **Security**: All API keys are stored in environment variables

### Environment Configuration

The BFF requires the following environment variables:

```
GEMINI_API_KEY=your_gemini_api_key
AIRTABLE_PAT=your_airtable_personal_access_token
AIRTABLE_BASE_ID=your_airtable_base_id
```

## Benefits

### Security Improvements

- API keys are no longer exposed in client-side code
- All external API communications are server-to-server
- Reduced attack surface for the frontend application

### Performance Opportunities

- Server-side caching can be implemented for frequently requested data
- Request batching is possible for multiple API calls
- Better control over connection pooling and reuse

### Maintainability

- Centralized error handling for all external services
- Easier to implement retry logic and rate limiting
- Simplified frontend code with clean service abstractions

## Future Enhancements

1. **Caching Layer**: Implement Redis or in-memory caching for frequently requested data
2. **Rate Limiting**: Add sophisticated rate limiting for external APIs
3. **Request Batching**: Group multiple requests into single BFF calls
4. **Authentication**: Add authentication layer for BFF endpoints
5. **Monitoring**: Add comprehensive logging and monitoring\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\BFF_IMPLEMENTATION.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Clean-Up-and-Remove-All-Testing-Components-from-a-Vite-Project.md ---\nClean-Up-and-Remove-All-Testing-Components-from-a-Vite-Project

**[START PROMPT]**

**Role:** You are an expert software engineer specializing in project refactoring and dependency management. Your task is to provide a clean, step-by-step guide to completely remove all testing-related files, configurations, and dependencies from a user's Vite/React project.

-----

**Project Context:**
The project is a Vite-based application that was previously set up for multiple types of testing, including Jest and Playwright. The user now wants to remove all of these testing components to simplify the project.

Based on the project structure, the following files and directories are related to testing:

  * **Folders:** `__mocks__`, `__tests__`, `e2e`, `playwright-report`, `test-results`, `tests`
  * **Configuration Files:** `jest.config.cjs`, `jest.setup.js`, `playwright.config.ts`
  * **Test Files:** `tests.ts`
  * **Dependencies (likely in `package.json`):** All packages related to Jest, Testing Library (`@testing-library/*`), and Playwright (`@playwright/test`).
  * **Scripts (in `package.json`):** The `"test"` script.

-----

**Primary Goal:**
Provide a set of clear, sequential instructions and the exact terminal commands needed to remove all testing infrastructure from the project, leaving only the application code.

-----

**Step-by-Step Instructions to Generate:**

1.  **Remove Testing Files and Directories:**

      * Generate the terminal command(s) to permanently delete all the identified testing-related folders and files from the project root.

2.  **Uninstall Testing Dependencies:**

      * Analyze a typical `package.json` for a project with this structure.
      * Generate a single `npm uninstall` command to remove all likely testing dependencies from both `dependencies` and `devDependencies`. This should include packages like `jest`, `@jest/globals`, `ts-jest`, `babel-jest`, `jest-environment-jsdom`, `@testing-library/react`, `@testing-library/jest-dom`, and `@playwright/test`.

3.  **Clean Up `package.json` Scripts:**

      * Provide instructions on how to modify the `package.json` file.
      * Specifically, instruct the user to find the `"scripts"` section and completely remove the line containing the `"test"` script.

4.  **Clean Up `.gitignore` (Optional but Recommended):**

      * Instruct the user to open the `.gitignore` file.
      * Tell them to look for and remove any lines related to test reports or temporary test files, such as `test-results/` or `playwright-report/`.

-----

**Output Format:**
Please present the final output as a clear, numbered list of actions. Each action should include a brief explanation and the precise terminal command to be executed.

**Example of Desired Output:**

"Here is a step-by-step guide to remove all testing components from your project.

**Step 1: Delete Testing Files and Folders**
This command will remove all configuration files and directories related to Jest and Playwright.

```bash
# (Generated command here)
```

**Step 2: Uninstall Testing Dependencies**
This command will remove all testing-related packages from your `package.json`.

```bash
# (Generated command here)
```

**Step 3: Remove the Test Script**
Open your `package.json` file, find the `"scripts"` section, and delete the line that starts with `"test":`.

**Step 4: Clean the `.gitignore` file**
Open your `.gitignore` file and remove any lines like `/test-results` or `/playwright-report`."

**[END PROMPT]**\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Clean-Up-and-Remove-All-Testing-Components-from-a-Vite-Project.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\e2e-testing-plan.md ---\n# End-to-End (E2E) Testing Strategy for SocialSync Pro

This document outlines a comprehensive End-to-End (E2E) testing strategy for the SocialSync Pro application. The goal is to simulate real user journeys to ensure all components work together as expected, providing a reliable and bug-free user experience.

## 1. Foundational Setup (Playwright)

*   **Installation:** Add Playwright to the project's `devDependencies`.
*   **Configuration (`playwright.config.ts`):**
    *   Set the `baseURL` to the local development server's address.
    *   Configure browser targets (Chromium, Firefox, WebKit).
    *   Enable trace recording (`on-first-retry`) for easier debugging of failed tests.
*   **Test Directory:** Create a top-level `e2e` directory to house all E2E test files.

## 2. Comprehensive User Journey Tests

### **Suite: `auth-and-project.spec.ts` - Authentication and Project Management**

*   **Test Case 1.1: Admin Login and Logout**
    *   **Journey:** Admin authenticates to access the admin panel.
    *   **Steps:**
        1.  Navigate to the `/admin` route.
        2.  Enter an incorrect password and assert that an error message is shown.
        3.  Enter the correct admin password.
        4.  Assert that the `AdminPage` component is rendered.
        5.  (Future) Implement and test a logout feature.

*   **Test Case 1.2: Project Loading from Airtable**
    *   **Journey:** A user loads an existing project from Airtable.
    *   **Steps:**
        1.  Navigate to the home page.
        2.  Click "Load from Airtable".
        3.  Assert that the Airtable load modal appears.
        4.  Select a brand from the list.
        5.  Assert that the main application interface (`MainDisplay`) is loaded and the correct brand name is visible.

*   **Test Case 1.3: Project Saving and Exporting**
    *   **Journey:** A user saves the current project state to a local file and exports assets.
    *   **Steps:**
        1.  Load a project.
        2.  Click the "Save Project" button.
        3.  Assert that a `.ssproj` file is downloaded.
        4.  Navigate to the "Brand Kit" tab.
        5.  Click "Export Brand Kit".
        6.  Assert that a `.docx` file is downloaded.
        7.  Navigate to the "Media Plan" tab.
        8.  Click "Export Plan".
        9.  Assert that a `.xlsx` file is downloaded.

### **Suite: `content-creation.spec.ts` - Core Content Generation**

*   **Test Case 2.1: Full Brand Kit Generation**
    *   **Journey:** A new user generates a complete brand identity from a single idea.
    *   **Steps:**
        1.  Start on the "Idea Profiler" page.
        2.  Enter a business idea and generate a brand profile.
        3.  Assert that the "Brand Profiler" step is active and populated with data.
        4.  Generate the full brand kit.
        5.  Assert that the app transitions to the "Brand Kit" tab within `MainDisplay`.
        6.  Verify that logo concepts, color palettes, and a media plan are visible.

*   **Test Case 2.2: Media Plan Generation from Wizard**
    *   **Journey:** A user generates a new media plan for an existing brand.
    *   **Steps:**
        1.  Load an existing project.
        2.  Navigate to the "Media Plan" tab.
        3.  Click the "New Plan" button to open the wizard.
        4.  Fill out the wizard (prompt, platforms, persona, etc.) and generate the plan.
        5.  Assert that a new media plan is added to the list and set as the active plan.
        6.  Verify that the generated posts appear in the feed.

*   **Test Case 2.3: Post Generation and Refinement**
    *   **Journey:** A user generates a single post and refines its content.
    *   **Steps:**
        1.  Load a project and open a media plan.
        2.  Open the details of a post.
        3.  Click "Refine Content".
        4.  Assert that the post content is updated with the refined version.
        5.  Generate an image for the post.
        6.  Assert that the new image is displayed in the post card.

### **Suite: `strategy-hub.spec.ts` - Strategic Content Planning**

*   **Test Case 3.1: Trend and Idea Management**
    *   **Journey:** A user manually creates a trend and generates ideas for it.
    *   **Steps:**
        1.  Load a project and navigate to the "Strategy Hub".
        2.  Click "Add Trend" and fill out the form.
        3.  Assert that the new trend appears and is selected.
        4.  Click "Generate Ideas".
        5.  Assert that new idea cards are rendered in the ideas list.
        6.  Delete the trend and confirm that it and its ideas are removed.

*   **Test Case 3.2: Automated Facebook Trend Analysis**
    *   **Journey:** A user automatically discovers trends for a specific industry.
    *   **Steps:**
        1.  Navigate to the "Strategy Hub".
        2.  Enter an industry (e.g., "Fashion") into the Facebook Strategy Automation input.
        3.  Click "Search Trends".
        4.  Assert that new trends, populated with data from the search, are added to the trends list.

*   **Test Case 3.3: Content Package from Product**
    *   **Journey:** A user generates a promotional content package for a specific affiliate product.
    *   **Steps:**
        1.  Navigate to the "Affiliate Vault".
        2.  Select a product and click "Generate Ideas".
        3.  Assert that the user is taken to the "Strategy Hub" and a new product-based trend is created.
        4.  Select an idea and open the "Generate Content Package" wizard.
        5.  Confirm the correct product is pre-selected.
        6.  Generate the package.
        7.  Assert that a new media plan is created and that all posts are linked to the affiliate product.

### **Suite: `affiliate-vault.spec.ts` - Affiliate Link Management**

*   **Test Case 4.1: CRUD Operations for Affiliate Links**
    *   **Journey:** A user manages their list of affiliate products.
    *   **Steps:**
        1.  Navigate to the "Affiliate Vault".
        2.  Click "Add New Link" and fill out the form.
        3.  Assert that the new link appears in the list.
        4.  Edit the newly created link.
        5.  Assert that the changes are saved and displayed.
        6.  Delete the link and confirm its removal.

*   **Test Case 4.2: Import Links from File**
    *   **Journey:** A user bulk-imports affiliate links from an Excel or CSV file.
    *   **Steps:**
        1.  Navigate to the "Affiliate Vault".
        2.  Click "Import from File".
        3.  Upload a valid file with affiliate data.
        4.  Assert that the new links are added to the vault.

### **Suite: `personas.spec.ts` - Persona Management**

*   **Test Case 5.1: Persona Creation and Assignment**
    *   **Journey:** A user creates a persona and assigns it to a campaign.
    *   **Steps:**
        1.  Navigate to the "Personas" tab.
        2.  Click "Add Persona" and fill out the details.
        3.  Upload an avatar for the persona.
        4.  Assert that the new persona card is displayed.
        5.  Navigate to the "Media Plan" tab.
        6.  Select a media plan and use the dropdown to assign the new persona.
        7.  Assert that the persona's details are visible in the plan header and that post prompts are updated.

### **Suite: `scheduling-and-publishing.spec.ts` - Post Scheduling and Publishing**

*   **Test Case 6.1: Single Post Scheduling**
    *   **Journey:** A user schedules a single post for a future date.
    *   **Steps:**
        1.  Load a project and open a media plan.
        2.  Open the details for a draft post.
        3.  Click the "Schedule" button.
        4.  Select a date and time in the future.
        5.  Assert that the post card updates to show the "Scheduled" status.

*   **Test Case 6.2: Bulk Scheduling**
    *   **Journey:** A user schedules multiple posts at once with a set interval.
    *   **Steps:**
        1.  Select multiple posts in the media plan feed.
        2.  Click the "Schedule" button in the bulk action bar.
        3.  Set a start date and time, and an interval.
        4.  Confirm the bulk schedule.
        5.  Assert that all selected posts are updated with their new scheduled times.

*   **Test Case 6.3: Direct Publishing**
    *   **Journey:** A user publishes a post directly to a social media platform.
    *   **Steps:**
        1.  Ensure a social account is connected to a persona.
        2.  Open the details for a draft post in a plan assigned to that persona.
        3.  Click "Publish Now".
        4.  Assert that the post status changes to "Published" and a link to the live post is displayed.

## 4. CI/CD Integration

*   **Workflow File (`.github/workflows/e2e-tests.yml`):**
    *   **Trigger:** On every `pull_request` targeting the `main` branch.
    *   **Jobs:**
        1.  **`build_and_test`:**
            *   Check out the code.
            *   Install dependencies (`npm install`).
            *   Install Playwright browsers.
            *   Build the application (`npm run build`).
            *   Start the local server.
            *   Run the full E2E test suite (`npx playwright test`).
            *   Upload test results and traces as artifacts on failure.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\e2e-testing-plan.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\improve-initial-load-times-and-resource-management.md ---\n**Objective:** Refactor the data fetching logic in our React application to improve initial load times and resource management. We will move from the current "eager loading" pattern to a strategic "lazy loading" and "on-demand" fetching architecture.

**Technical Context:**
* **Frontend:** React (with TypeScript), Vite. We use a central service (`bffService.ts`) to handle all API calls. State management is handled by React's context or a similar library.
* **Backend:** A Backend-for-Frontend (BFF) architecture running on Vercel Serverless Functions (Node.js).
* **Database:** We are migrating from Airtable to MongoDB. The new API endpoints should be designed with MongoDB's performance capabilities in mind, especially for pagination.
* **Core Data Tabs/Components:** `BrandKitView`, `MediaPlanView`, `StrategyHubView`, `AffiliateVaultView`, `PersonasView`.

**Current Problem:**
When a user loads a project (`Brand`), the application currently fetches almost all data for every tab at once, causing significant initial load delays and wasting resources.

**Detailed Implementation Plan:**

Please provide the necessary code modifications to implement the following 3-step optimization strategy:

**Step 1: Implement a Focused Initial Project Load**

The goal is to make the initial project loading feel instantaneous by only fetching the absolute necessary data and directing the user to the first available view.

1.  **Backend (BFF):**
    * Create a new, dedicated endpoint: `GET /api/brands/:id/initial-load`.
    * This endpoint should perform an optimized database query to return a JSON object containing:
        * Basic summary data for the brand (e.g., `{ id, name, logoUrl }`).
        * The **full dataset** required for the `BrandKitView` tab (e.g., `{ brandProfile, logoConcepts, colorPalettes }`).

2.  **Frontend:**
    * Refactor the function responsible for loading a project. It should now call the new `GET /api/brands/:id/initial-load` endpoint instead of the old, heavy one.
    * Upon receiving a successful response, the app must **programmatically redirect** the user to the `/brand-kit` route.
    * The `BrandKitView` component should now render instantly without a loading state, as its data is already present.

**Step 2: Implement On-Demand (Lazy) Loading for Other Tabs**

Data for all other tabs should only be fetched when the user navigates to them for the first time in a session.

1.  **Backend (BFF):**
    * Ensure there are separate endpoints to fetch the data for each specific tab. For example:
        * `GET /api/brands/:id/media-plans-list` (Note: This should only return the list of plans, not the posts inside them).
        * `GET /api/brands/:id/strategy-hub`
        * `GET /api/brands/:id/affiliate-vault`
        * `GET /api/brands/:id/personas`

2.  **Frontend:**
    * For each tab component (e.g., `StrategyHubView`, `PersonasView`, etc.), implement a data-fetching hook (e.g., using `useEffect` or `react-query`).
    * This hook should check if the data for its tab already exists in the application's state.
    * If the data does *not* exist, it should display a loading indicator and trigger the corresponding API call to fetch it.
    * Once fetched, the data should be cached in the client-side state to prevent re-fetching during the same session.

**Step 3: Implement Pagination for the Media Plan's Post List**

The `MediaPlanView` is expected to handle the largest amount of data (potentially thousands of posts). It must be optimized with pagination.

1.  **Backend (BFF):**
    * Modify the endpoint for fetching posts to support pagination. For example: `GET /api/media-plans/:planId/posts`.
    * This endpoint must accept query parameters like `?page=1&limit=30`.
    * The backend logic should use these parameters to perform an efficient, paginated query in MongoDB.

2.  **Frontend:**
    * In the `MediaPlanView` component, when a user selects a media plan, fetch only the *first page* of posts.
    * Implement an "infinite scroll" feature. As the user scrolls towards the bottom of the post list, the component should automatically request the next page of data and append it to the existing list.

Please provide the necessary code snippets and modifications for the frontend components and the BFF serverless functions to achieve this refactoring.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\improve-initial-load-times-and-resource-management.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\intergrate-mongodb.md ---\nYou are a senior Full-Stack Engineer and data migration specialist. Your expertise lies in refactoring complex applications, swapping out backend services, and ensuring a smooth transition with minimal disruption to the frontend. You are an expert in the MERN stack and Vercel serverless architecture.

Project Context:
* Application: SocialSync Pro, a full-stack social media management tool.
* Frontend: A Vite-powered React/TypeScript SPA in the src/ directory.
* Backend: Node.js serverless functions in the api/ directory, deployed on Vercel.
* Incumbent Database: Airtable, with all backend logic contained in api/airtable/ and api/lib/airtable.js. The frontend interacts with it via src/services/airtableService.ts.
* Target Database: MongoDB Atlas.

Primary Goal:
Your mission is to execute a complete and total migration of the application's persistence layer from Airtable to MongoDB Atlas. You will replace every piece of Airtable-related logic with a MongoDB equivalent, ensuring the application is fully functional on the new database. The primary strategy is to keep the public API contract (routes and data structures) as stable as possible to minimize frontend refactoring.

Step-by-Step Technical Plan:

Phase 1: Project Setup & Configuration

1. Manage Dependencies:
   * Add the official mongodb Node.js driver.
   * Completely remove the airtable package as it will no longer be used.

2. Configure Environment:
   * Direct the user to create a .env.local file for the MONGODB_URI connection string. Provide a placeholder and an explanation.

3. Establish Connection Utility:
   * Create a reusable and performant connection handler for the serverless environment at api/lib/mongodb.js. This utility must cache the connection across function invocations to prevent overwhelming the database.

Phase 2: Backend API Migration

This is the core of the migration. You will systematically refactor every file in the api/airtable/ directory.

1. General Instructions for Refactoring:
   * For each file, replace the Airtable SDK logic with the equivalent logic using the Node.js mongodb driver.
   * Use the connection utility created in Phase 1 to interact with the database.
   * Map Airtable concepts to MongoDB: an Airtable "Table" should become a MongoDB "Collection". Use logical collection names (e.g., personas, mediaPlanPosts).

2. Critical Data Structure Transformation:
   * MongoDB uses an _id field of type ObjectId as its primary key. The existing frontend code expects an id field of type string, as provided by Airtable.
   * For all data returned from the API, you must transform the data before sending the response. Create a new id field containing the string representation of _id and remove the _id
	 field to maintain the API contract.
   * Example Transformation: ({ _id, ...rest }) => ({ id: _id.toString(), ...rest })

3. Refactor Specific Endpoints:
   * Go through each file in api/airtable/ (e.g., load-personas.js, load-media-plan-posts.js, [action].js, etc.).
   * For each file, provide the full, refactored code that performs the original function's purpose using MongoDB.

Phase 3: Frontend & Cleanup

1. Refactor Frontend Service:
   * Rename src/services/airtableService.ts to src/services/databaseService.ts to reflect its new, generic role.
   * Review the contents of the newly renamed file. While API routes are unchanged, you must double-check that any data types or structures still align with what the frontend components
	 expect. Make minor adjustments if necessary.

2. Update Imports:
   * Identify all files in the src/ directory that import from the old airtableService.ts.
   * Provide a list of these files and instruct the user on how to update the import paths to point to databaseService.ts.

3. Delete Obsolete Code:
   * Delete the now-unused Airtable library file: api/lib/airtable.js.

Desired Output Format:
Provide a clear, step-by-step response with the following sections:

1. Dependency Commands: The shell commands for installing mongodb and uninstalling airtable.
2. Environment Setup: The code block for the .env.local file.
3. MongoDB Connection Utility: The complete, commented code for api/lib/mongodb.js.
4. Backend API Refactoring: For each file in api/airtable/, provide a heading with the filename and a code block containing its new, fully refactored MongoDB implementation.
5. Frontend Service Refactoring: A code block with the complete code for the new src/services/databaseService.ts.
6. Frontend Import Updates: A list of all file paths within src/ that need their import statements updated.
7. Final Cleanup: A confirmation that api/lib/airtable.js should be deleted.
8. Concluding Summary: A brief summary of the completed migration and advice on how to populate the new MongoDB collections with data to test the application.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\intergrate-mongodb.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\openrouter_gemini_bff_refactoring_plan.md ---\n# OpenRouter and Gemini Service Refactoring Plan

## Overview
This document outlines the plan to refactor both OpenRouter and Gemini services to exclusively use the BFF (Backend for Frontend) service, removing all direct API calls from the client-side code. This will improve security by keeping API keys server-side and centralize error handling.

## Current Architecture Issues
1. Both services make direct API calls from the client
2. Only partial BFF integration exists (fallback mechanisms)
3. API keys are exposed in client-side code
4. Rate limiting and error handling is duplicated

## Refactored Architecture
1. All AI requests will go through the BFF service
2. Client-side code will only make requests to our own backend
3. BFF service will handle all external API communication
4. Centralized error handling and rate limiting

## Implementation Steps

### 1. OpenRouter Service Refactoring (`services/openrouterService.ts`)

**Remove:**
- `openrouterFetch` function and all direct API calls
- All rate limiting and retry logic (handled by BFF)
- Error handling (handled by BFF)

**Keep:**
- Service interface functions that will call BFF
- Type definitions and model validation

**Modify:**
- All service functions to use `bffService` instead of direct calls
- Update function signatures to match BFF endpoints

### 2. Gemini Service Refactoring (`services/geminiService.ts`)

**Remove:**
- Direct `GoogleGenAI` instantiation
- All direct API calls to Gemini
- Retry mechanisms and rate limiting (handled by BFF)
- Fallback logic to direct calls

**Keep:**
- Service interface functions that will call BFF
- JSON parsing and sanitization functions
- Type definitions

**Modify:**
- Functions to exclusively use `bffService` for all requests
- Update function signatures to match BFF endpoints

### 3. BFF Service Enhancements (`services/bffService.ts`)

**Add:**
- New endpoints for OpenRouter functionality
- Enhanced error handling and logging
- Rate limiting coordination
- Response validation

### 4. Server-side Implementation (`server/index.js`)

**Add:**
- OpenRouter API proxy endpoints
- Enhanced Gemini API endpoints
- Rate limiting and error handling
- API key management

## Detailed Changes

### OpenRouter Service Changes

1. **Remove `openrouterFetch`** - All direct API calls will be handled by BFF
2. **Refactor all service functions** to use BFF endpoints:
   ```typescript
   // Before
   const response = await openrouterFetch({ model: model, ... })
   
   // After
   const response = await generateContentWithBff(model, contents, config)
   ```

3. **Remove retry logic** - BFF will handle retries and rate limiting

### Gemini Service Changes

1. **Remove direct `GoogleGenAI` instantiation** - BFF will handle all API communication
2. **Refactor functions** to exclusively use BFF:
   ```typescript
   // Before
   const ai = new GoogleGenAI({ apiKey });
   const response = await ai.models.generateContent({ ... })
   
   // After
   const response = await generateContentWithBff(model, contents, config)
   ```

3. **Remove fallback mechanisms** - BFF is the only communication path

### BFF Service Enhancements

1. **Add OpenRouter endpoints**:
   - `/api/openrouter/generate` for text generation
   - `/api/openrouter/generate-image` for image generation

2. **Enhance existing Gemini endpoints**:
   - Improve error handling
   - Add rate limiting coordination
   - Add better logging

### Server Implementation

1. **Add OpenRouter API proxy**:
   - Endpoint for text generation
   - Endpoint for image generation
   - Proper error handling and response formatting

2. **Enhance Gemini proxy**:
   - Add rate limiting
   - Improve error responses
   - Add logging

## Benefits of This Refactoring

1. **Security**: API keys never exposed to client
2. **Maintainability**: Centralized API communication logic
3. **Scalability**: Better rate limiting and error handling
4. **Observability**: Centralized logging and monitoring
5. **Reliability**: Consistent error handling and retry mechanisms

## Testing Approach

1. **Unit Tests**: Verify BFF service functions correctly
2. **Integration Tests**: Ensure client can communicate with BFF
3. **End-to-End Tests**: Validate complete AI functionality
4. **Error Handling Tests**: Verify proper error responses

## Rollout Strategy

1. **Phase 1**: Implement BFF endpoints and server-side logic
2. **Phase 2**: Refactor client-side services to use BFF exclusively
3. **Phase 3**: Remove unused direct API call code
4. **Phase 4**: Update documentation and run final tests\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\openrouter_gemini_bff_refactoring_plan.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\pass-Error-No-more-than-12-Serverless-Functions-can-be-added-to-a-Deployment-on-the-Hobby-plan.md ---\nYou are an expert Next.js developer specializing in backend optimization and best practices.

I am refactoring my Next.js application to reduce the number of Serverless Functions for deployment on Vercel's Hobby plan, to pass the error "Error: No more than 12 Serverless Functions can be added to a Deployment on the Hobby plan". My current setup has multiple files for different HTTP methods for the same API endpoint, and I need to combine them into a single file.

Your task is to take the code from the separate files I provide and merge them into one consolidated API route. This new file must use a `switch` statement based on `req.method` to correctly route requests to the appropriate logic.

**Here is a clear example of the transformation I need:**

-----

**BEFORE:**
I have two separate files:

*File 1: `/pages/api/users/getAll.js`*

```javascript
// Handles GET requests
export default function handler(req, res) {
  const users = [{ id: 1, name: 'John Doe' }];
  res.status(200).json(users);
}
```

*File 2: `/pages/api/users/create.js`*

```javascript
// Handles POST requests
export default function handler(req, res) {
  const { name } = req.body;
  // Logic to create a new user...
  res.status(201).json({ id: 2, name: name });
}
```

**AFTER:**
I want a single, combined file:

*New File: `/pages/api/users.js`*

```javascript
// Handles multiple HTTP methods
export default function handler(req, res) {
  switch (req.method) {
    case 'GET':
      // Logic from getAll.js
      const users = [{ id: 1, name: 'John Doe' }];
      res.status(200).json(users);
      break;
    case 'POST':
      // Logic from create.js
      const { name } = req.body;
      // Logic to create a new user...
      res.status(201).json({ id: 2, name: name });
      break;
    default:
      // Handle any other HTTP method
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

-----

**Now, please perform this same refactoring on my actual files in "api" folder.**

Merge all necessary imports, consolidate the logic inside a `switch` statement, and include the default 405 error handler.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\pass-Error-No-more-than-12-Serverless-Functions-can-be-added-to-a-Deployment-on-the-Hobby-plan.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Prompt Refactor a Full-Stack Project for Vercel Deployment.md ---\n
### **Prompt: Refactor a Full-Stack Project for Vercel Deployment**

**[START PROMPT]**

**Role:** You are an expert Full-stack software engineer with deep experience in React, Node.js, and the Vercel platform. Your task is to refactor an existing project to make it fully compatible with Vercel's Serverless Functions architecture.

-----

**Project Context:**

The current project is a full-stack application with the following structure:

  * **Frontend**: The React source code is located in the project's root directory.
  * **Backend**: A traditional Node.js/Express server is located in a `/server` subdirectory. All backend logic, including API routes, is defined within the `server/index.js` file.

This is the current directory structure:

```
/
├── server/
│   ├── index.js         // The main Express server file
│   └── (other files...)
├── src/
│   ├── components/
│   └── App.tsx          // Example frontend file
├── package.json
└── ...
```

Here is a code snippet from the `server/index.js` file:

```javascript
const express = require('express');
const cors = require('cors');
const app = express();
app.use(cors());
app.use(express.json());

// API route to get a list of users
app.get('/api/users', (req, res) => {
  // ... logic to get users from the database
  res.status(200).json({ users: [...] });
});

// API route to create a new post
app.post('/api/posts', (req, res) => {
  const { title, content } = req.body;
  // ... logic to save the post to the database
  res.status(201).json({ message: 'Post created successfully', post: ... });
});

const PORT = 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

-----

**Primary Goal:**

Refactor the entire project to be deployable on Vercel. This involves removing the traditional Express server and converting all API routes into individual Serverless Functions within an `/api` directory.

-----

**Step-by-Step Instructions:**

1.  **Create the `/api` directory**: In the project's root directory, create a new directory named `/api`.
2.  **Split the Routes**: Read the `server/index.js` file, identify all API routes (e.g., `app.get('/api/users')`, `app.post('/api/posts')`). For each route, perform the following:
      * Create a new JavaScript/TypeScript file inside the `/api` directory. The filename must correspond to the endpoint. For example, `/api/users` becomes `api/users.js`.
      * For dynamic routes like `/api/users/:id`, create the corresponding directory structure: `api/users/[id].js`.
3.  **Convert the Route Source Code**: In each newly created serverless function file, rewrite the route's logic.
      * Each file must `export default` a `handler` function that accepts two parameters: `request` and `response`.
      * Handle different HTTP methods (GET, POST, PUT, DELETE) within the handler function by checking `request.method`.
      * Retrieve data from `request.body` (for POST/PUT) or `request.query` (for URL parameters).
      * Completely remove the Express `app` instance and the `app.listen()` command.
4.  **Move Shared Logic**: If there is shared logic (e.g., database connections, authentication functions), propose creating a `/lib` or `/utils` directory in the project root and move that code there. The serverless functions will import from this directory.
5.  **Create `vercel.json` file**: Create a `vercel.json` file in the root directory with a basic `rewrites` configuration to ensure API requests are routed correctly.
6.  **Update `package.json`**: List the dependencies that are no longer needed after removing the Express server (e.g., `express`, `cors`, `nodemon`) and suggest the command to uninstall them.

-----

**Output Format:**

Present the result as a complete refactoring guide. Provide "before" and "after" code snippets for at least two routes to clearly illustrate the changes.

**Example of Desired Output Format:**

**1. Proposed New Directory Structure:**
*(Display the directory tree structure after refactoring)*

**2. Source Code Refactoring Steps:**

  * **Converting the `GET /api/users` route:**
      * **Before (in `server/index.js`):**
        ```javascript
        // (Old code snippet here)
        ```
      * **After (create file `api/users.js`):**
        ```javascript
        // (New serverless function code here)
        ```
  * **Converting the `POST /api/posts` route:**
      * **Before (in `server/index.js`):**
        ```javascript
        // (Old code snippet here)
        ```
      * **After (create file `api/posts.js`):**
        ```javascript
        // (New serverless function code here)
        ```

**3. Create `vercel.json` file:**
*(Provide the content for the `vercel.json` file)*

**4. Dependency Cleanup:**
*(List the packages to be removed and provide the `npm uninstall` command)*

**[END PROMPT]**\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Prompt Refactor a Full-Stack Project for Vercel Deployment.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Refactor-a-Vite-Project-for-Vercel-Compatibility.md ---\n**Role:** You are an expert software engineer specializing in modern web development with Vite, React, and Vercel. Your task is to refactor a project's file structure to resolve a deployment conflict on Vercel.

-----

**Project Context:**
The current project is a Vite-based React application. The main entry point file (`index.tsx`) and its associated CSS (`index.css`) are located in the project's root directory, alongside `index.html` and `package.json`. This structure causes a conflict with Vercel's routing rules, where a root `index.tsx` file is incorrectly treated as a Serverless Function, causing `500` errors.

**Current (Problematic) Directory Structure:**

```
/
├── api/
│   └── (serverless functions...)
├── index.css
├── index.html
├── index.tsx  <-- The problematic file
├── package.json
└── ... (other config files)
```

**Content of `index.html`:**

```html
<!doctype html>
<html lang="en">
  <head>
    ...
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
```

-----

**Primary Goal:**
Refactor the project to follow the standard Vite project structure by moving all frontend source files into a `/src` directory. This will resolve the conflict with Vercel's deployment rules and allow the project to build and run correctly.

-----

**Step-by-Step Instructions:**

1.  **Create a `/src` Directory:** In the project's root, create a new directory named `src`.

2.  **Move Frontend Source Files:** Move all relevant frontend source files from the root directory into the new `/src` directory. Based on the project context, this includes at least:

      * `index.tsx`
      * `index.css`
      * *(Also move any other component files like `App.tsx`, or folders like `/components`, if they exist in the root)*

3.  **Update `index.html`:** Modify the `index.html` file in the root directory. Update the path in the `<script>` tag to point to the new location of `index.tsx`.

      * **Find this line:**
        ```html
        <script type="module" src="/index.tsx"></script>
        ```
      * **Change it to:**
        ```html
        <script type="module" src="/src/index.tsx"></script>
        ```

-----

**Output Format:**
Please provide a summary of the actions taken and show the final, corrected code for the `index.html` file.

**Example of Desired Output:**
"I have restructured the project as requested.

1.  A new `/src` directory has been created.
2.  The files `index.tsx` and `index.css` have been moved into the `/src` directory.
3.  The `index.html` file has been updated to reflect the new path.

Here is the updated content for `index.html`:

```html
<!doctype html>
<html lang="en">
  <head>
    ...
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
```

"\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Refactor-a-Vite-Project-for-Vercel-Compatibility.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Sales-Funnel-Campaign-Generator.md ---\n### **Prompt: New Feature Specification for an AI-Powered Sales Funnel Campaign Generator**

**1. Feature Name:**
AI-Powered Sales Funnel Campaign Generator

**2. Objective & Goal:**
To evolve beyond single post and media plan generation by introducing a strategic, multi-stage campaign builder. This feature will empower users to automatically generate a comprehensive content strategy based on a classic 4-stage sales funnel (Awareness, Prospect/Consideration, Decision, Action). The goal is to help users move customers from initial contact to conversion by creating targeted content for each stage of their journey, leveraging the app's existing features like Personas and the Affiliate Vault.

**3. Core User Story:**
"As a Social Media Manager, I want to automatically generate a complete, multi-stage sales funnel campaign for a specific product or goal, so that I can strategically guide my audience from awareness to purchase without having to manually plan content for each stage of the customer journey."

**4. Detailed Functional Requirements & User Flow:**

**4.1. Entry Point:**
-   A new button, "Create Funnel Campaign," will be added within the **"Media Plan"** tab, next to the "New Plan" button.

**4.2. The Funnel Campaign Wizard (Modal Interface):**
When the user clicks the button, a multi-step wizard will appear:

**Step 1: Define Campaign Goal**
-   **Campaign Name:** A text field for the user to name their campaign (e.g., "Q4 Dark Roast Coffee Launch").
-   **Primary Objective/Product:** The user can choose one of two options:
    -   **Promote a Product:** A dropdown menu dynamically populated with items from the user's **"Affiliate Vault"**. Selecting a product will make it the central focus of the "Decision" stage content.
    -   **General Goal:** A text prompt field where the user can describe a broader goal (e.g., "Increase newsletter sign-ups for our marketing agency").
-   **Target Audience:** A mandatory dropdown to select a pre-defined **"Persona"**. The AI will use this persona to tailor the tone, style, and content for all generated posts.
-   **Campaign Duration:** A selection for the campaign length (e.g., 1 Week, 2 Weeks, 1 Month). This will determine the total number of posts generated.

**Step 2: AI Generation & Review**
-   After the user clicks "Generate Funnel," the system will use AI to create a new, structured **Media Plan**.
-   This Media Plan will be automatically populated with post ideas, but critically, these posts will be categorized and tagged into four distinct sections corresponding to the sales funnel stages:
    -   **Stage 1: Awareness (Top-of-Funnel):**
        -   **Content Type:** The AI will generate educational, engaging, and non-promotional content ideas. Examples: "5 surprising benefits of dark roast coffee," "A poll: How do you take your morning coffee?", "Behind-the-scenes look at our bean sourcing."
        -   **Goal:** To attract the target Persona and build brand recognition.
    -   **Stage 2: Prospect / Consideration (Middle-of-Funnel):**
        -   **Content Type:** The AI will generate content designed to nurture leads and build trust. It should suggest creating content that drives traffic to a user-provided link (like a blog or landing page). Examples: "Read our new blog post: A deep dive into coffee roasting profiles," "Download our free guide to brewing the perfect espresso," "Webinar announcement: A Q&A with our head roaster."
        -   **Goal:** To capture user interest and establish authority.
    -   **Stage 3: Decision (Bottom-of-Funnel):**
        -   **Content Type:** The AI will generate direct, persuasive content focused on the product selected from the **Affiliate Vault** or the user's general goal. Examples: "Why our Dark Roast is the top choice for coffee lovers," "Limited Time Offer: Get 20% off your first subscription box," "Customer Testimonial: See what Jane Doe says about our coffee." The affiliate link should be automatically suggested for inclusion in these posts.
        -   **Goal:** To convert interested prospects into customers.
    -   **Stage 4: Action / Retention (Post-Purchase):**
        -   **Content Type:** The AI will generate content to reinforce the purchase decision and build community. Examples: "Thank you to all our new subscribers! Show us how you're enjoying your coffee with #SocialSyncCoffee," "Ask for reviews: Loved your purchase? Leave us a review!", "User-generated content prompt: What's the most creative way you've used our beans?"
        -   **Goal:** To create loyal customers and brand advocates.

**4.3. Output & Integration with Existing Features:**
-   The output will be a single, new **Media Plan** in the user's feed.
-   Inside the plan, posts will be visually distinguished (e.g., with colored tags or section headers like "Awareness Stage") to indicate which part of the funnel they belong to.
-   Crucially, **every generated post must be a standard `Post` object**. This ensures that the user can click on any post and use the existing **"Refine Content"** and **"Generate Image"** buttons to perfect it.
-   The entire generated plan can be scheduled (single or bulk) and published using the existing **Scheduling and Publishing** functionality.

**5. Key Technical & UI/UX Considerations:**
-   **Backend:** A new BFF endpoint (e.g., `POST /api/campaign/generate-funnel`) needs to be created to handle the logic for this multi-stage generation. It will orchestrate multiple calls to the AI service (e.g., Gemini) with different instructions for each funnel stage.
-   **UI:** The wizard should be clean and intuitive. The output Media Plan must clearly and visually separate the posts by their funnel stage.
-   **Data Model:** No major changes to the Airtable schema are expected, as the feature leverages existing `MediaPlan`, `Post`, `Persona`, and `AffiliateVault` structures. A new field on the `Post` object, such as `funnelStage`, could be added to store the stage tag.

**6. Acceptance Criteria:**
-   A user can successfully generate a new Media Plan from the "Create Funnel Campaign" wizard.
-   The generated Media Plan contains posts that are clearly categorized into the four funnel stages (Awareness, Consideration, Decision, Action).
-   The content of the posts in each stage logically aligns with the purpose of that stage.
-   If a product from the Affiliate Vault is selected, the "Decision" stage posts are clearly focused on promoting that specific product.
-   All generated posts are fully editable using the existing "Refine Content" and "Generate Image" features.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\Sales-Funnel-Campaign-Generator.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\scalability_and_performance_improvements.md ---\n# Scalability and Performance Improvements for SocialSync Pro

Here is a list of 10 key recommendations to enhance the application's scalability, performance, and robustness for large-scale use.

## Core Architectural Enhancements

### 1. ✅ Introduce a Backend-for-Frontend (BFF) Layer
*   **Problem:** The current architecture has the client-side application communicating directly with numerous third-party services (Airtable, Gemini, Facebook, Cloudinary). This is not scalable and poses significant security risks by exposing API keys.
*   **Solution:** Create a dedicated backend service (e.g., using Node.js with Express) that acts as an intermediary. The frontend makes requests to the BFF, and the BFF securely handles all communication with external APIs. This centralizes logic, protects credentials, and allows for server-side caching.
*   **Status:** IMPLEMENTED - A comprehensive BFF layer has been added to SocialSync Pro. It includes:
    * Secure proxy endpoints for all external services (Gemini, Airtable, Cloudinary, Facebook)
    * Fallback mechanism to direct API calls if BFF is unavailable
    * Self-signed HTTPS for local development
    * Comprehensive error handling and logging
    * Health check endpoint for monitoring

### 2. ✅ Implement Advanced Frontend Rendering Optimization
*   **Problem:** Loading many components and large lists of data (posts, assets) can slow down the initial page load and make the UI feel sluggish.
*   **Solution:**
    *   **Code-Splitting:** Use `React.lazy()` to split code by routes or large components, so users only download the code for the view they are accessing.
    *   **List Virtualization:** Use a library like `TanStack Virtual` to render only the visible items in long lists, dramatically improving performance for users with large amounts of data.

### 3. Adopt a Robust Data Fetching and Caching Strategy
*   **Problem:** The application likely re-fetches the same data repeatedly, putting unnecessary load on third-party services and making the app feel slow.
*   **Solution:** Integrate a modern data-fetching library like **TanStack Query**. It provides an out-of-the-box caching mechanism that handles data fetching, background refetching, and request deduplication, leading to a faster user experience and fewer API calls.

## Advanced Backend and Infrastructure

### 4. Establish an Asynchronous Job Queue
*   **Problem:** Long-running operations like bulk scheduling or complex AI content generation can lead to request timeouts and a poor user experience.
*   **Solution:** Implement a background job processing system using a queue (e.g., **BullMQ**, **RabbitMQ**). The BFF adds a "job" to the queue and responds instantly. A separate "worker" service processes the job asynchronously.

### 5. Migrate from Airtable to a Scalable Production Database
*   **Problem:** Airtable is not designed for high-traffic production use. It has strict API rate limits and lacks the performance and query capabilities of a dedicated database.
*   **Solution:** Migrate core application data to a scalable database like **PostgreSQL** or **MongoDB**. The BFF would interact with this database for all primary data operations.

### 6. Optimize Asset Handling and Delivery
*   **Problem:** Inefficiently loading images and videos slows down the user experience and increases bandwidth costs.
*   **Solution:** Leverage a full CDN strategy for your assets (e.g., via Cloudinary). Serve responsive images for different devices, use modern formats like WebP/AVIF, and lazy-load media content.

## Frontend and Development Workflow

### 7. Implement a Formalized State Management Solution
*   **Problem:** Managing global client-side state (e.g., open modals, UI toggles) with props becomes unmanageable and error-prone as the application grows.
*   **Solution:** Adopt a dedicated library for managing global client state. Good options include **Zustand** (lightweight), **Redux Toolkit** (structured), or **Jotai** (atomic).

### 8. Enhance the Testing Strategy with End-to-End (E2E) Tests
*   **Problem:** Unit and integration tests don't always catch bugs that arise from real user workflows.
*   **Solution:** Introduce an E2E testing framework like **Cypress** or **Playwright** to automate and validate complete user journeys (e.g., from login to scheduling a post).

### 9. Establish a CI/CD (Continuous Integration/Continuous Deployment) Pipeline
*   **Problem:** Manually testing and deploying the application is slow and prone to human error.
*   **Solution:** Automate your workflow with a platform like **GitHub Actions**. Create a pipeline to automatically run tests, checks, and builds on every code push, and deploy automatically on merges.

### 10. Integrate Real-Time Functionality with WebSockets
*   **Problem:** The application is not currently interactive in real-time; users must refresh to see updates.
*   **Solution:** Use **WebSockets** (e.g., with **Socket.IO**) to allow the server to push updates to clients. This is ideal for notifications, live status updates, and future collaborative features.
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\scalability_and_performance_improvements.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\settings-management-flow.txt ---\nThis settings management flow is designed to provide a flexible yet controlled experience, beginning with a global configuration and allowing for specific customization at the brand level.

1. Admin Configuration
The process begins in the AdminPage, where an Admin establishes the foundational settings for the entire application.

Global Defaults: The Admin defines the default settings that act as a baseline template. These configurations are stored in the Admin_Settings table.

Service & Model Management: The Admin curates a list of available AI services and their associated models. These are managed in the AI_Services and AI_Models tables and represent the complete set of options that can be offered to users.

2. Brand Initialization
When a new brand is created in the system, its settings are not created from scratch. Instead, they are automatically initialized by copying the current global defaults from the Admin_Settings table. This ensures every new brand starts with a consistent, pre-configured baseline.

3. User Customization
Users can tailor settings specifically for their brand through the Settings modal.

Loading Current Settings: When a user opens the modal, it first fetches and displays that brand's currently saved settings. On first open, this will be the initial defaults. On subsequent opens, it will be their previously saved customizations.

Modification and Saving: The user can modify any setting, including selecting different AI services and models from the list managed by the Admin. Upon saving, these changes are updated and stored specifically for that brand, overriding the initial defaults.


How would this flow handle user roles and permissions?

What are the potential challenges with this approach?

How does this handle versioning of settings?

4. Use cases:
Use Case 1: Admin Establishes or Updates Global Defaults
This flow covers the initial setup and any subsequent changes to the application's baseline settings.

User Action (UI): The Admin navigates to the AdminPage. They change one or more setting values (e.g., toggle a feature on, change a text label, set a default quota) and click the "Save Global Settings" button.

Application Logic: The frontend application collects all the setting values from the form. It then makes an API call (e.g., PUT /api/admin/settings) to the backend, sending the complete set of default settings in the request body. After receiving a success confirmation, the UI might show a "Settings Saved" notification.

Database Interaction: The backend server receives the API request. It validates the data and then executes an UPDATE query on the Admin_Settings table. This single query overwrites the existing default values with the new ones provided by the Admin.

Use Case 2: Admin Manages Available AI Services
This covers adding or removing the AI service options that will be available to users.

User Action (UI): In the AdminPage, the Admin navigates to the "Manage Services" section.

To Add: They click "Add New Service," fill out a form with the service name, description, and perhaps model associations, then click "Save."

To Remove: They find an existing service in the list and click the "Remove" or "Delete" icon next to it, then confirm the action in a prompt.

Application Logic:

On Add: The frontend sends a POST /api/admin/services request with the new service's data.

On Remove: The frontend sends a DELETE /api/admin/services/{service_id} request.

In both cases, upon a successful response, the frontend UI automatically refreshes the list to reflect the change.

Database Interaction:

On Add: The backend executes an INSERT statement to add a new record to the AI_Services table (and potentially the AI_Models table if models are added simultaneously).

On Remove: The backend executes a DELETE statement to remove the corresponding record from the AI_Services table. It might also need to handle cascading deletes or prevent deletion if the service is currently in use by brands.

Use Case 3: A New Brand is Created
This is the automated flow that provisions a new brand with its initial settings.

User Action (UI): This is typically triggered by a different system action, like an Admin filling out a "Create New Brand" form or a new customer completing a signup flow. The final action is clicking "Create Brand."

Application Logic: When the brand creation process is triggered on the backend, the application's business logic performs a critical internal step before finalizing the creation. It first queries the database for the current global defaults. It then uses this data to construct a new settings object specifically for the brand-to-be-created.

Database Interaction: This involves a sequence of operations:

SELECT * FROM Admin_Settings: The application first reads the single row of global default settings.

INSERT INTO Brands (...): The new brand record is created in the Brands table.

INSERT INTO Brand_Settings (...): A new record is created in a Brand_Settings table (or similar). This record stores the copied default settings and is explicitly linked to the newly created brand's ID.

Use Case 4: User Customizes Their Brand's Settings
This is the core flow for brand-level personalization.

User Action (UI): A User logs into their brand's account and clicks the "Settings" button. The Settings modal appears.

Application Logic (on Modal Open): The frontend initiates two parallel API calls to efficiently gather all necessary data:

Fetch user-specific settings: GET /api/brands/{brand_id}/settings

Fetch available options: GET /api/services and GET /api/models
The application then populates the modal's form fields. It uses the data from the first call to set the current values and the data from the second call to populate the dropdown menus (e.g., the list of available AI models).

Database Interaction (on Modal Open):

The first API call triggers a SELECT * FROM Brand_Settings WHERE brand_id = ? to get that specific brand's saved settings.

The second API call triggers a SELECT * FROM AI_Services and SELECT * FROM AI_Models to retrieve all possible options curated by the Admin.

User Action (UI - Saving Changes): The user changes a value in the modal (e.g., selects a different AI service from a dropdown) and clicks "Save Changes."

Application Logic (on Save): The frontend gathers the new values from the modal form and sends a PUT /api/brands/{brand_id}/settings request with the updated data. On success, it displays a confirmation message and closes the modal.

Database Interaction (on Save): The backend receives the request and executes an UPDATE Brand_Settings SET ... WHERE brand_id = ?, overwriting that brand's specific settings with the new, customized values. The global defaults in Admin_Settings are completely unaffected.






\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\settings-management-flow.txt ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Business_Requirements_Document.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Business_Requirements_Document.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Project_Plan.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Project_Plan.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] SocialSync_Pro_Feature_Descriptions.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] SocialSync_Pro_Feature_Descriptions.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] System_Architecture_Document.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] System_Architecture_Document.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Test_Plan_and_Strategy.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] Test_Plan_and_Strategy.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] User_Manual.md ---\n[Binary or unreadable file: Contents omitted.]\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\feature_descriptions\[doc] User_Manual.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\check-migration-status.js ---\n#!/usr/bin/env node

/**
 * Migration Status Checker Script
 * 
 * This script checks the status of your migration from Airtable to MongoDB.
 * 
 * Usage:
 * 1. Set your MongoDB connection string in environment variable:
 *    - MONGODB_URI=your_mongodb_connection_string
 * 
 * 2. Run the script:
 *    node scripts/check-migration-status.js
 */

import { MongoClient } from 'mongodb';
import fs from 'fs/promises';
import path from 'path';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: join(__dirname, '..', '.env.local') });

// Configuration
const MONGODB_URI = process.env.MONGODB_URI || process.env.DATABASE_URL;

// Validate configuration
if (!MONGODB_URI) {
  console.error('Error: Please set MONGODB_URI or DATABASE_URL environment variable');
  console.error('You can set it in .env.local file or as an environment variable');
  process.exit(1);
}

// Expected collections in SocialSync Pro
const EXPECTED_COLLECTIONS = [
  'brands',
  'brandValues',
  'keyMessages',
  'logoConcepts',
  'mediaPlanGroups',
  'mediaPlanPosts',
  'affiliateProducts',
  'personas',
  'trends',
  'ideas',
  'socialAccounts',
  'aiServices',
  'aiModels',
  'adminSettings',
  'brandSettings'
];

async function checkMigrationStatus() {
  let client;
  
  try {
    console.log('Checking migration status...');
    
    // Connect to MongoDB
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('✓ Connected to MongoDB');
    
    const db = client.db();
    
    // Check if exported data exists
    const exportDir = path.join(import.meta.dirname, '..', 'exports');
    let exportExists = false;
    let exportedFiles = [];
    
    try {
      exportedFiles = await fs.readdir(exportDir);
      exportExists = exportedFiles.length > 0;
      console.log(`✓ Export directory exists with ${exportedFiles.length} files`);
    } catch (error) {
      console.log('⚠ Export directory does not exist or is empty');
    }
    
    // Check MongoDB collections
    const collections = await db.listCollections().toArray();
    const collectionNames = collections.map(c => c.name);
    
    console.log(`
MongoDB Collections Status:`);
    let migratedCollections = 0;
    
    for (const expectedCollection of EXPECTED_COLLECTIONS) {
      if (collectionNames.includes(expectedCollection)) {
        const count = await db.collection(expectedCollection).countDocuments();
        console.log(`  ✓ ${expectedCollection}: ${count} documents`);
        if (count > 0) migratedCollections++;
      } else {
        console.log(`  ✗ ${expectedCollection}: Collection missing`);
      }
    }
    
    // Determine overall status
    console.log(`
Migration Status Summary:`);
    
    if (migratedCollections === EXPECTED_COLLECTIONS.length) {
      console.log(`  ✓ All collections have been migrated`);
      console.log(`  ✓ Migration appears to be COMPLETE`);
    } else if (migratedCollections > 0) {
      console.log(`  ⚠ ${migratedCollections}/${EXPECTED_COLLECTIONS.length} collections have data`);
      console.log(`  ⚠ Migration appears to be PARTIALLY COMPLETE`);
    } else {
      console.log(`  ✗ No migrated collections found`);
      console.log(`  ✗ Migration has NOT BEEN STARTED`);
    }
    
    if (exportExists) {
      console.log(`  ✓ Export data is available (${exportedFiles.length} files)`);
    } else {
      console.log(`  ⚠ No export data found`);
    }
    
    // Recommendations
    console.log(`
Recommendations:`);
    
    if (migratedCollections === 0 && !exportExists) {
      console.log(`  1. Run 'npm run migrate:dry-run' to export your Airtable data`);
      console.log(`  2. Run 'npm run migrate' to perform a full migration`);
    } else if (migratedCollections === 0 && exportExists) {
      console.log(`  1. Run 'npm run migrate' to import your exported data to MongoDB`);
    } else if (migratedCollections > 0 && migratedCollections < EXPECTED_COLLECTIONS.length) {
      console.log(`  1. Check for migration errors in the console output`);
      console.log(`  2. Run 'npm run migrate' again to complete the migration`);
    } else if (migratedCollections === EXPECTED_COLLECTIONS.length) {
      console.log(`  1. Your migration is complete!`);
      console.log(`  2. Update your application to use MongoDB`);
    }
    
  } catch (error) {
    console.error('✗ Migration status check failed:', error);
    process.exit(1);
  } finally {
    if (client) {
      await client.close();
      console.log('✓ Disconnected from MongoDB');
    }
  }
}

// Run check if script is executed directly
const scriptPath = fileURLToPath(import.meta.url);
const argv1Path = process.argv[1];

// Normalize paths for comparison
const normalizedScriptPath = scriptPath.replace(/\\\\/g, '/');
const normalizedArgv1Path = argv1Path.replace(/\\\\/g, '/');

const isDirectExecution = normalizedScriptPath === normalizedArgv1Path;

if (isDirectExecution) {
  checkMigrationStatus();
}

export default checkMigrationStatus;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\check-migration-status.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\init-mongodb-database.js ---\n#!/usr/bin/env node

/**
 * Initialize MongoDB Database Script
 * 
 * This script initializes the MongoDB database with proper collections and indexes.
 * 
 * Usage:
 * 1. Set your MongoDB connection string in environment variable:
 *    - MONGODB_URI=your_mongodb_connection_string
 * 
 * 2. Run the script:
 *    node scripts/init-mongodb-database.js
 */

import { MongoClient } from 'mongodb';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: join(__dirname, '..', '.env.local') });

// Configuration
const MONGODB_URI = process.env.MONGODB_URI || process.env.DATABASE_URL;

// Validate configuration
if (!MONGODB_URI) {
  console.error('Error: Please set MONGODB_URI or DATABASE_URL environment variable');
  console.error('You can set it in .env.local file or as an environment variable');
  process.exit(1);
}

// Check if the MongoDB URI is a placeholder
if (MONGODB_URI.includes('<') && MONGODB_URI.includes('>')) {
  console.error('Error: Your MONGODB_URI contains placeholder values (< >)');
  console.error('Please replace the placeholder values in your MongoDB connection string');
  process.exit(1);
}

// Define collections and their indexes
const COLLECTIONS = [
  {
    name: 'brands',
    indexes: [
      { key: { brandId: 1 }, unique: true },
      { key: { name: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'brandValues',
    indexes: [
      { key: { brandId: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'keyMessages',
    indexes: [
      { key: { brandId: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'logoConcepts',
    indexes: [
      { key: { brandId: 1 } },
      { key: { logoId: 1 }, unique: true },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'mediaPlanGroups',
    indexes: [
      { key: { brandId: 1 } },
      { key: { planId: 1 }, unique: true },
      { key: { name: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'mediaPlanPosts',
    indexes: [
      { key: { mediaPlanId: 1 } },
      { key: { postId: 1 }, unique: true },
      { key: { brandId: 1 } },
      { key: { week: 1 } },
      { key: { scheduledAt: 1 } },
      { key: { status: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'affiliateProducts',
    indexes: [
      { key: { brandId: 1 } },
      { key: { linkId: 1 }, unique: true },
      { key: { productId: 1 } },
      { key: { productName: 1 } },
      { key: { providerName: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'personas',
    indexes: [
      { key: { brandId: 1 } },
      { key: { personaId: 1 }, unique: true },
      { key: { nickName: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'trends',
    indexes: [
      { key: { brandId: 1 } },
      { key: { trendId: 1 }, unique: true },
      { key: { industry: 1 } },
      { key: { topic: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'ideas',
    indexes: [
      { key: { trendId: 1 } },
      { key: { ideaId: 1 }, unique: true },
      { key: { productId: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'socialAccounts',
    indexes: [
      { key: { personaId: 1 } },
      { key: { accountId: 1 }, unique: true },
      { key: { platform: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'aiServices',
    indexes: [
      { key: { serviceId: 1 }, unique: true },
      { key: { name: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'aiModels',
    indexes: [
      { key: { serviceId: 1 } },
      { key: { modelId: 1 }, unique: true },
      { key: { name: 1 } },
      { key: { provider: 1 } },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'adminSettings',
    indexes: [
      { key: { settingId: 1 }, unique: true },
      { key: { createdAt: -1 } }
    ]
  },
  {
    name: 'brandSettings',
    indexes: [
      { key: { brandId: 1 }, unique: true },
      { key: { createdAt: -1 } }
    ]
  }
];

async function initializeDatabase() {
  let client;
  
  try {
    console.log('Initializing MongoDB database...');
    
    // Connect to MongoDB
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('✓ Connected to MongoDB');
    
    const db = client.db();
    
    // Create collections and indexes
    for (const collectionSpec of COLLECTIONS) {
      const { name, indexes } = collectionSpec;
      
      console.log(`\nSetting up collection: ${name}`);
      
      // Create collection if it doesn't exist
      try {
        await db.createCollection(name);
        console.log(`  ✓ Created collection ${name}`);
      } catch (error) {
        if (error.codeName === 'NamespaceExists') {
          console.log(`  ✓ Collection ${name} already exists`);
        } else {
          throw error;
        }
      }
      
      // Create indexes
      const collection = db.collection(name);
      for (const indexSpec of indexes) {
        try {
          await collection.createIndex(indexSpec.key, { ...indexSpec, background: true });
          console.log(`  ✓ Created index on ${Object.keys(indexSpec.key).join(', ')}`);
        } catch (error) {
          console.log(`  ⚠ Warning: Could not create index on ${Object.keys(indexSpec.key).join(', ')}: ${error.message}`);
        }
      }
    }
    
    console.log('\n✓ MongoDB database initialization completed successfully!');
  } catch (error) {
    console.error('✗ MongoDB database initialization failed:', error);
    process.exit(1);
  } finally {
    if (client) {
      await client.close();
      console.log('✓ Disconnected from MongoDB');
    }
  }
}

// Run initialization if script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  initializeDatabase();
}

export default initializeDatabase;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\init-mongodb-database.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\migrate-airtable-to-mongodb.js ---\n#!/usr/bin/env node

/**
 * Airtable to MongoDB Migration Script
 * 
 * This script migrates data from Airtable to MongoDB without changing the application code.
 * It preserves the same data structure and relationships while converting to MongoDB format.
 * 
 * Usage:
 * 1. Set your Airtable credentials in environment variables:
 *    - AIRTABLE_PAT=your_airtable_personal_access_token
 *    - AIRTABLE_BASE_ID=your_airtable_base_id
 * 
 * 2. Set your MongoDB connection string in environment variable:
 *    - MONGODB_URI=your_mongodb_connection_string
 * 
 * 3. Run the script:
 *    node scripts/migrate-airtable-to-mongodb.js
 *    
 *    For dry run (export only):
 *    node scripts/migrate-airtable-to-mongodb.js --dry-run
 */

import fs from 'fs/promises';
import path from 'path';
import { MongoClient } from 'mongodb';
import Airtable from 'airtable';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: join(__dirname, '..', '.env.local') });

// Configuration
const AIRTABLE_PAT = process.env.AIRTABLE_PAT;
const AIRTABLE_BASE_ID = process.env.AIRTABLE_BASE_ID;
const MONGODB_URI = process.env.MONGODB_URI || process.env.DATABASE_URL;
const DRY_RUN = process.argv.includes('--dry-run');

// Validate configuration
if (!AIRTABLE_PAT || !AIRTABLE_BASE_ID) {
  console.error('Error: Please set AIRTABLE_PAT and AIRTABLE_BASE_ID environment variables');
  console.error('You can set them in .env.local file or as environment variables');
  process.exit(1);
}

if (!DRY_RUN && (!MONGODB_URI || (MONGODB_URI.includes('<') && MONGODB_URI.includes('>')))) {
  console.error('Error: Please set a valid MONGODB_URI environment variable');
  console.error('You can set it in .env.local file or as an environment variable');
  console.error('Make sure to replace placeholder values (< >) with actual credentials');
  process.exit(1);
}

// Initialize Airtable
const airtable = new Airtable({ apiKey: AIRTABLE_PAT });
const base = airtable.base(AIRTABLE_BASE_ID);

// MongoDB collections mapping (Airtable table names to MongoDB collection names)
const COLLECTION_MAPPING = {
  'Brands': 'brands',
  'Brand_Values': 'brandValues',
  'Key_Messages': 'keyMessages',
  'Logo_Concepts': 'logoConcepts',
  'Media_Plans': 'mediaPlanGroups',
  'Posts': 'mediaPlanPosts',
  'Affiliate_Products': 'affiliateProducts',
  'Personas': 'personas',
  'Trends': 'trends',
  'Ideas': 'ideas',
  'Social_Accounts': 'socialAccounts',
  'AI_Services': 'aiServices',
  'AI_Models': 'aiModels',
  'Admin_Settings': 'adminSettings',
  'Brand_Settings': 'brandSettings'
};

// Field mappings for special transformations
const FIELD_MAPPINGS = {
  'Brands': {
    'brand_id': 'brandId',
    'name': 'name',
    'mission': 'mission',
    'usp': 'usp',
    'target_audience': 'targetAudience',
    'personality': 'personality',
    'color_palette_json': 'colorPaletteJson',
    'font_recs_json': 'fontRecsJson',
    'unified_profile_json': 'unifiedProfileJson',
    'logo_url': 'logoUrl'
  },
  'Brand_Values': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'text': 'text'
  },
  'Key_Messages': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'text': 'text'
  },
  'Logo_Concepts': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'logo_id': 'logoId',
    'style': 'style',
    'prompt': 'prompt',
    'image_key': 'imageKey',
    'image_url': 'imageUrl'
  },
  'Media_Plans': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'plan_id': 'planId',
    'name': 'name',
    'prompt': 'prompt',
    'source': 'source',
    'product_images_json': 'productImagesJson',
    'persona': 'personaId' // This will be transformed to reference the persona record ID
  },
  'Posts': {
    'media_plan': 'mediaPlanId', // This will be transformed to reference the media plan record ID
    'post_id': 'postId',
    'title': 'title',
    'week': 'week',
    'theme': 'theme',
    'platform': 'platform',
    'content_type': 'contentType',
    'content': 'content',
    'description': 'description',
    'hashtags': 'hashtags',
    'cta': 'cta',
    'media_prompt': 'mediaPrompt',
    'script': 'script',
    'image_key': 'imageKey',
    'image_url': 'imageUrl',
    'video_key': 'videoKey',
    'video_url': 'videoUrl',
    'media_order': 'mediaOrder',
    'source_urls': 'sourceUrls',
    'scheduled_at': 'scheduledAt',
    'published_at': 'publishedAt',
    'published_url': 'publishedUrl',
    'auto_comment': 'autoComment',
    'status': 'status',
    'is_pillar': 'isPillar',
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'promoted_products': 'promotedProductIds' // This will be transformed to reference product record IDs
  },
  'Affiliate_Products': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'link_id': 'linkId',
    'product_id': 'productId',
    'product_name': 'productName',
    'price': 'price',
    'sales_volume': 'salesVolume',
    'provider_name': 'providerName',
    'commission_rate': 'commissionRate',
    'commission_value': 'commissionValue',
    'product_link': 'productLink',
    'promotion_link': 'promotionLink',
    'product_avatar': 'productAvatar',
    'product_description': 'productDescription',
    'features': 'features',
    'use_cases': 'useCases',
    'customer_reviews': 'customerReviews',
    'product_rating': 'productRating',
    'product_image_links': 'productImageLinks'
  },
  'Personas': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'persona_id': 'personaId',
    'nick_name': 'nickName',
    'main_style': 'mainStyle',
    'activity_field': 'activityField',
    'outfit_description': 'outfitDescription',
    'avatar_image_key': 'avatarImageKey',
    'avatar_image_url': 'avatarImageUrl'
  },
  'Trends': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'trend_id': 'trendId',
    'industry': 'industry',
    'topic': 'topic',
    'keywords': 'keywords',
    'links_json': 'linksJson',
    'notes': 'notes',
    'analysis': 'analysis',
    'created_at': 'createdAt'
  },
  'Ideas': {
    'trend': 'trendId', // This will be transformed to reference the trend record ID
    'idea_id': 'ideaId',
    'title': 'title',
    'description': 'description',
    'target_audience': 'targetAudience',
    'product_id': 'productId'
  },
  'Social_Accounts': {
    'persona': 'personaId', // This will be transformed to reference the persona record ID
    'account_id': 'accountId',
    'platform': 'platform',
    'credentials_json': 'credentialsJson'
  },
  'AI_Services': {
    'service_id': 'serviceId',
    'name': 'name',
    'description': 'description'
  },
  'AI_Models': {
    'service': 'serviceId', // This will be transformed to reference the service record ID
    'model_id': 'modelId',
    'name': 'name',
    'provider': 'provider',
    'capabilities': 'capabilities'
  },
  'Admin_Settings': {
    'setting_id': 'settingId',
    'language': 'language',
    'total_posts_per_month': 'totalPostsPerMonth',
    'media_prompt_suffix': 'mediaPromptSuffix',
    'affiliate_content_kit': 'affiliateContentKit',
    'text_generation_model': 'textGenerationModel',
    'image_generation_model': 'imageGenerationModel',
    'text_model_fallback_order_json': 'textModelFallbackOrderJson',
    'vision_models_json': 'visionModelsJson'
  },
  'Brand_Settings': {
    'brand': 'brandId', // This will be transformed to reference the brand record ID
    'language': 'language',
    'total_posts_per_month': 'totalPostsPerMonth',
    'media_prompt_suffix': 'mediaPromptSuffix',
    'affiliate_content_kit': 'affiliateContentKit',
    'text_generation_model': 'textGenerationModel',
    'image_generation_model': 'imageGenerationModel',
    'text_model_fallback_order_json': 'textModelFallbackOrderJson',
    'vision_models_json': 'visionModelsJson'
  }
};

/**
 * Fetch all records from an Airtable table
 */
async function fetchAirtableRecords(tableName) {
  console.log(`Fetching records from Airtable table: ${tableName}`);
  const records = [];
  
  return new Promise((resolve, reject) => {
    base(tableName).select({
      // You can add view or filter options here if needed
    }).eachPage(function page(pageRecords, fetchNextPage) {
      // This function will get called for each page of records
      records.push(...pageRecords.map(record => ({
        id: record.id,
        fields: record.fields
      })));
      
      // To fetch the next page of records, call fetchNextPage.
      // If there are more records, `page` will get called again.
      // If there are no more records, `done` will get called.
      fetchNextPage();
    }, function done(err) {
      if (err) {
        console.error(`Error fetching records from ${tableName}:`, err);
        reject(err);
      } else {
        console.log(`Fetched ${records.length} records from ${tableName}`);
        resolve(records);
      }
    });
  });
}

/**
 * Transform Airtable records to MongoDB documents
 */
function transformRecords(records, tableName) {
  console.log(`Transforming ${records.length} records from ${tableName}`);
  
  return records.map(record => {
    const transformed = {
      _id: record.id, // Preserve Airtable record ID
      ...transformFields(record.fields, tableName)
    };
    
    // Add timestamps
    transformed.createdAt = new Date();
    transformed.updatedAt = new Date();
    
    return transformed;
  });
}

/**
 * Transform field names and values
 */
function transformFields(fields, tableName) {
  const transformed = {};
  const fieldMapping = FIELD_MAPPINGS[tableName] || {};
  
  for (const [airtableField, value] of Object.entries(fields)) {
    const mappedFieldName = fieldMapping[airtableField] || airtableField;
    
    // Handle special field transformations
    if (airtableField === 'brand' && Array.isArray(value)) {
      // Brand field is a linked record, extract the record ID
      transformed[mappedFieldName] = value[0]; // Take the first linked record ID
    } else if (airtableField === 'persona' && Array.isArray(value)) {
      // Persona field is a linked record, extract the record ID
      transformed[mappedFieldName] = value[0]; // Take the first linked record ID
    } else if (airtableField === 'media_plan' && Array.isArray(value)) {
      // Media plan field is a linked record, extract the record ID
      transformed[mappedFieldName] = value[0]; // Take the first linked record ID
    } else if (airtableField === 'trend' && Array.isArray(value)) {
      // Trend field is a linked record, extract the record ID
      transformed[mappedFieldName] = value[0]; // Take the first linked record ID
    } else if (airtableField === 'service' && Array.isArray(value)) {
      // Service field is a linked record, extract the record ID
      transformed[mappedFieldName] = value[0]; // Take the first linked record ID
    } else if (airtableField === 'promoted_products' && Array.isArray(value)) {
      // Promoted products field is an array of linked records, extract the record IDs
      transformed[mappedFieldName] = value; // Keep the array of record IDs
    } else {
      // Direct field mapping
      transformed[mappedFieldName] = value;
    }
  }
  
  return transformed;
}

/**
 * Insert documents into MongoDB collection
 */
async function insertDocuments(collection, documents) {
  if (documents.length === 0) {
    console.log(`No documents to insert into ${collection.collectionName}`);
    return;
  }
  
  console.log(`Inserting ${documents.length} documents into ${collection.collectionName}`);
  
  try {
    // Insert documents in batches to avoid memory issues
    const batchSize = 100;
    for (let i = 0; i < documents.length; i += batchSize) {
      const batch = documents.slice(i, i + batchSize);
      await collection.insertMany(batch);
      console.log(`Inserted batch ${Math.floor(i/batchSize) + 1} of ${Math.ceil(documents.length/batchSize)} into ${collection.collectionName}`);
    }
    
    console.log(`Successfully inserted ${documents.length} documents into ${collection.collectionName}`);
  } catch (error) {
    console.error(`Error inserting documents into ${collection.collectionName}:`, error);
    throw error;
  }
}

/**
 * Export Airtable data to JSON files
 */
async function exportAirtableData() {
  console.log('Starting Airtable data export...');
  
  const exportDir = path.join(import.meta.dirname, '..', 'exports');
  await fs.mkdir(exportDir, { recursive: true });
  
  const exportData = {};
  
  // Fetch data from all tables
  for (const [tableName, collectionName] of Object.entries(COLLECTION_MAPPING)) {
    try {
      const records = await fetchAirtableRecords(tableName);
      exportData[collectionName] = records;
      
      // Save to individual JSON files
      const filePath = path.join(exportDir, `${collectionName}.json`);
      await fs.writeFile(filePath, JSON.stringify(records, null, 2));
      console.log(`Exported ${records.length} records to ${filePath}`);
    } catch (error) {
      console.error(`Failed to export ${tableName}:`, error);
    }
  }
  
  // Save all data to a single file
  const allDataFilePath = path.join(exportDir, 'airtable-export.json');
  await fs.writeFile(allDataFilePath, JSON.stringify(exportData, null, 2));
  console.log(`Exported all data to ${allDataFilePath}`);
  
  return exportData;
}

/**
 * Transform and import data to MongoDB
 */
async function importDataToMongoDB(airtableData) {
  if (DRY_RUN) {
    console.log('Skipping MongoDB import in dry-run mode');
    return;
  }
  
  console.log('Starting data import to MongoDB...');
  
  let client;
  
  try {
    // Connect to MongoDB
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('Connected to MongoDB');
    
    const db = client.db();
    
    // Transform and import data for each collection
    for (const [tableName, collectionName] of Object.entries(COLLECTION_MAPPING)) {
      const airtableRecords = airtableData[collectionName];
      
      if (!airtableRecords || airtableRecords.length === 0) {
        console.log(`No records found for ${collectionName}, skipping...`);
        continue;
      }
      
      // Transform records
      const mongoDocuments = transformRecords(airtableRecords, tableName);
      
      // Get or create collection
      const collection = db.collection(collectionName);
      
      // Insert documents
      await insertDocuments(collection, mongoDocuments);
    }
    
    console.log('Data import to MongoDB completed successfully!');
  } catch (error) {
    console.error('Error importing data to MongoDB:', error);
    throw error;
  } finally {
    if (client) {
      await client.close();
      console.log('Disconnected from MongoDB');
    }
  }
}

/**
 * Main migration function
 */
async function migrate() {
  console.log(`Starting Airtable to MongoDB migration (${DRY_RUN ? 'DRY RUN' : 'FULL MIGRATION'})...`);
  
  try {
    // Step 1: Export data from Airtable
    const airtableData = await exportAirtableData();
    
    // Step 2: Import data to MongoDB
    await importDataToMongoDB(airtableData);
    
    console.log('Migration completed successfully!');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

// Run migration if script is executed directly
const scriptPath = fileURLToPath(import.meta.url);
const argv1Path = process.argv[1];

// Normalize paths for comparison
const normalizedScriptPath = scriptPath.replace(/\\/g, '/');
const normalizedArgv1Path = argv1Path.replace(/\\/g, '/');

const isDirectExecution = normalizedScriptPath === normalizedArgv1Path;

if (isDirectExecution) {
  migrate();
}

export {
  fetchAirtableRecords,
  transformRecords,
  importDataToMongoDB,
  migrate
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\migrate-airtable-to-mongodb.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\MIGRATION_COMPLETE_GUIDE.md ---\n# SocialSync Pro MongoDB Migration - Complete Guide

## Table of Contents
1. [Overview](#overview)
2. [Benefits of Migration](#benefits-of-migration)
3. [Migration Tools](#migration-tools)
4. [Preparation](#preparation)
5. [Migration Process](#migration-process)
6. [Verification](#verification)
7. [Post-Migration](#post-migration)
8. [Troubleshooting](#troubleshooting)

## Overview

This guide provides complete instructions for migrating your SocialSync Pro data from Airtable to MongoDB. The migration preserves all your existing data while switching the underlying database technology for improved performance and cost-effectiveness.

## Benefits of Migration

### Performance Improvements
- **5-10x Faster Queries**: MongoDB's native indexing outperforms Airtable's API
- **Improved Pagination**: Native database pagination for large datasets
- **Better Concurrency**: Handle more simultaneous users without rate limiting

### Cost Savings
- **Eliminate Airtable Limits**: No more record count restrictions ($20/month base cost)
- **Reduced API Calls**: More efficient data retrieval reduces API usage
- **Lower Monthly Costs**: MongoDB Atlas free tier often suffices for small teams

### Enhanced Features
- **Advanced Querying**: Complex queries previously impossible with Airtable
- **Better Analytics**: More sophisticated reporting capabilities
- **Improved Reliability**: Fewer timeout errors and rate limiting issues

## Migration Tools

All migration tools are located in the `scripts/` directory:

1. **Connection Test**: `npm run test:mongodb`
2. **Database Initialization**: `npm run init:mongodb`
3. **Dry Run Migration**: `npm run migrate:dry-run`
4. **Full Migration**: `npm run migrate`
5. **Migration Status Check**: `npm run check:migration`
6. **Implementation Test**: `npm run test:mongodb:impl`

## Preparation

### 1. Environment Setup

Create a `.env` file in your project root:

```env
# Airtable credentials
AIRTABLE_PAT=your_airtable_personal_access_token
AIRTABLE_BASE_ID=your_airtable_base_id

# MongoDB connection
MONGODB_URI=your_mongodb_connection_string
```

### 2. MongoDB Setup

1. Create a MongoDB Atlas account (or use an existing one)
2. Create a new cluster (free tier is sufficient for most users)
3. Whitelist your IP address (or 0.0.0.0/0 for development)
4. Create a database user with read/write permissions
5. Get your connection string from the "Connect" button

### 3. Airtable Access

Ensure your Airtable Personal Access Token (PAT) has access to your SocialSync Pro base.

## Migration Process

### Step 1: Test Connections

```bash
# Test MongoDB connection
npm run test:mongodb

# Optional: Initialize MongoDB database structure
npm run init:mongodb
```

### Step 2: Dry Run Migration

Perform a test migration to see what data will be exported:

```bash
npm run migrate:dry-run
```

This exports your Airtable data to JSON files in the `exports/` directory without importing to MongoDB.

### Step 3: Review Exported Data

Check the `exports/` directory to verify your data was correctly exported:

```bash
ls -la exports/
```

### Step 4: Full Migration

Run the complete migration:

```bash
npm run migrate
```

This exports data from Airtable and imports it into MongoDB.

### Step 5: Check Migration Status

Verify the migration was successful:

```bash
npm run check:migration
```

## Verification

### 1. Check MongoDB Collections

Use MongoDB Compass or a similar tool to verify your data:

1. Connect to your MongoDB instance
2. Check that all expected collections exist
3. Verify document counts match expectations
4. Spot-check sample documents for data integrity

### 2. Run Application Tests

1. Start your SocialSync Pro application
2. Navigate to various sections to verify data loads correctly
3. Perform CRUD operations to ensure data persistence works
4. Test export/import functionality

### 3. Performance Comparison

Compare loading times before and after migration:
- Brand Kit loading
- Media Plan rendering
- Strategy Hub data loading
- Affiliate Vault access

## Post-Migration

### 1. Update Application Configuration

Modify your application to use MongoDB instead of Airtable:

1. Update environment variables to point to MongoDB
2. Remove Airtable-specific configuration
3. Verify all integrations still work correctly

### 2. Monitor Performance

1. Watch for any error messages in the console
2. Monitor response times for data-intensive operations
3. Check MongoDB Atlas dashboard for resource utilization

### 3. Clean Up

1. Archive exported JSON files (keep as backup)
2. Update documentation to reflect MongoDB usage
3. Notify team members of the migration completion

## Troubleshooting

### Common Issues

#### 1. Authentication Errors
```
Error: Please set MONGODB_URI environment variable
```
**Solution**: Verify your `.env` file contains the correct MongoDB URI

#### 2. Connection Timeouts
```
MongoNetworkError: connection timed out
```
**Solution**: 
- Check your internet connection
- Verify MongoDB Atlas IP whitelist includes your address
- Check if your corporate firewall blocks MongoDB connections

#### 3. Rate Limiting
```
Error: Rate limit exceeded
```
**Solution**: 
- This comes from Airtable during export
- The migration script automatically handles rate limiting with delays
- Large databases may take longer to export

#### 4. Missing Collections
```
Warning: Collection brands not found
```
**Solution**: 
- Run `npm run init:mongodb` to create all expected collections
- Verify your MongoDB connection string points to the correct database

### Getting Help

If you encounter issues:

1. **Check Console Output**: Look for specific error messages
2. **Verify Environment Variables**: Ensure all required variables are set
3. **Test Connections Separately**: Use `npm run test:mongodb` to isolate MongoDB issues
4. **Check Export Files**: Verify data was exported correctly in dry-run mode
5. **Contact Support**: Reach out for assistance with persistent issues

## Rollback Plan

If issues occur after migration:

1. **Revert to Airtable**: Update environment variables to point back to Airtable
2. **Restore from Backup**: Use exported JSON files to restore data if needed
3. **Contact Support**: Reach out for assistance with any migration issues

## Support Resources

- [MIGRATION_GUIDE.md](../MIGRATION_GUIDE.md) - Complete migration instructions
- [MIGRATION_SUMMARY.md](../MIGRATION_SUMMARY.md) - Overview of benefits and process
- [scripts/README.md](README.md) - Tool-specific documentation
- Individual script files - Detailed implementation notes

## Next Steps

Once migration is complete:

1. Begin enjoying MongoDB performance benefits
2. Explore advanced querying capabilities
3. Implement enhanced analytics features
4. Consider horizontal scaling for future growth

The migration preserves all your hard work while unlocking the superior performance and capabilities of MongoDB.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\MIGRATION_COMPLETE_GUIDE.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\README.md ---\n# SocialSync Pro Database Migration Tools

This directory contains tools to help you migrate your SocialSync Pro data from Airtable to MongoDB.

## Available Tools

### 1. Test MongoDB Connection
Verifies that your MongoDB connection string is working correctly.

```bash
npm run test:mongodb
```

### 2. Initialize MongoDB Database
Sets up the MongoDB database with proper collections and indexes.

```bash
npm run init:mongodb
```

### 3. Dry Run Migration
Exports data from Airtable to JSON files without importing to MongoDB. This is useful for verifying what data will be migrated.

```bash
npm run migrate:dry-run
```

### 4. Full Migration
Exports data from Airtable and imports it into MongoDB.

```bash
npm run migrate
```

## Environment Variables

Create a `.env` file in the project root with:

```env
# Airtable credentials
AIRTABLE_PAT=your_airtable_personal_access_token
AIRTABLE_BASE_ID=your_airtable_base_id

# MongoDB connection
MONGODB_URI=your_mongodb_connection_string
```

## Migration Process

1. **Test your MongoDB connection**:
   ```bash
   npm run test:mongodb
   ```

2. **Initialize MongoDB database** (optional but recommended):
   ```bash
   npm run init:mongodb
   ```

3. **Perform a dry run** to see what data will be exported:
   ```bash
   npm run migrate:dry-run
   ```

4. **Check the exported data** in the `exports/` directory.

5. **Run the full migration**:
   ```bash
   npm run migrate
   ```

## What Data Gets Migrated?

The migration handles all core SocialSync Pro data:
- Brands and brand assets
- Media plans and posts
- Affiliate products
- Personas and social accounts
- Trends and ideas
- AI services and models
- Settings

## After Migration

Once migration is complete, your application will use MongoDB for all data operations while maintaining full compatibility with the existing codebase.

## Troubleshooting

If you encounter issues:

1. **Verify your environment variables** are set correctly
2. **Check MongoDB connection** with `npm run test:mongodb`
3. **Ensure your Airtable PAT** has access to the base
4. **Check the console output** for specific error messages

## Support

For additional help, refer to the main MIGRATION_GUIDE.md file in the project root.\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\README.md ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-connection.js ---\n#!/usr/bin/env node

/**
 * Test MongoDB Connection Script
 * 
 * This script tests the connection to MongoDB using the connection URI.
 * 
 * Usage:
 * 1. Set your MongoDB connection string in environment variable:
 *    - MONGODB_URI=your_mongodb_connection_string
 * 
 * 2. Run the script:
 *    node scripts/test-mongodb-connection.js
 */

import { MongoClient } from 'mongodb';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: join(__dirname, '..', '.env.local') });

// Configuration
const MONGODB_URI = process.env.MONGODB_URI || process.env.DATABASE_URL;

console.log('Debug: Script started');
console.log('Debug: MONGODB_URI =', MONGODB_URI ? 'Set' : 'Not set');

// Validate configuration
if (!MONGODB_URI) {
  console.error('Error: Please set MONGODB_URI or DATABASE_URL environment variable');
  console.error('You can set it in .env.local file or as an environment variable');
  process.exit(1);
}

// Check if the MongoDB URI is a placeholder
if (MONGODB_URI.includes('<') && MONGODB_URI.includes('>')) {
  console.error('Error: Your MONGODB_URI contains placeholder values (< >)');
  console.error('Please replace the placeholder values in your MongoDB connection string:');
  console.error('- Replace <tk100mil_db_user> with your actual MongoDB username');
  console.error('- Replace <2SYS0fc5FjRZwBiN> with your actual MongoDB password');
  console.error('');
  console.error('Your current MONGODB_URI:');
  console.error(MONGODB_URI);
  process.exit(1);
}

console.log('Debug: About to check if script should run');

// Check if script is executed directly
const scriptPath = fileURLToPath(import.meta.url);
const argv1Path = process.argv[1];
console.log('Debug: scriptPath =', scriptPath);
console.log('Debug: argv1Path =', argv1Path);

// Normalize paths for comparison
const normalizedScriptPath = scriptPath.replace(/\\/g, '/');
const normalizedArgv1Path = argv1Path.replace(/\\/g, '/');

const isDirectExecution = normalizedScriptPath === normalizedArgv1Path;
console.log('Debug: isDirectExecution =', isDirectExecution);
console.log('Debug: normalizedScriptPath =', normalizedScriptPath);
console.log('Debug: normalizedArgv1Path =', normalizedArgv1Path);

async function testConnection() {
  let client;
  
  try {
    console.log('Testing MongoDB connection...');
    console.log(`Using MongoDB URI: ${MONGODB_URI.replace(/(mongodb\+srv:\/\/)([^:]+):([^@]+)(@.*)/, '$1****:****$4')}`);
    
    // Connect to MongoDB
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('✓ Connected to MongoDB successfully');
    
    // Get database info
    const db = client.db();
    const dbName = db.databaseName;
    console.log(`✓ Database name: ${dbName}`);
    
    // List collections
    const collections = await db.listCollections().toArray();
    console.log(`✓ Found ${collections.length} collections:`);
    collections.forEach((collection, index) => {
      console.log(`  ${index + 1}. ${collection.name}`);
    });
    
    console.log('\n✓ MongoDB connection test completed successfully!');
  } catch (error) {
    console.error('✗ MongoDB connection test failed:', error.message);
    console.error('');
    console.error('Troubleshooting tips:');
    console.error('1. Check that your MongoDB URI is correct');
    console.error('2. Ensure your IP address is whitelisted in MongoDB Atlas');
    console.error('3. Verify your username and password are correct');
    console.error('4. Make sure your MongoDB cluster is running');
    process.exit(1);
  } finally {
    if (client) {
      await client.close();
      console.log('✓ Disconnected from MongoDB');
    }
  }
}

// Run test if script is executed directly
if (isDirectExecution) {
  console.log('Debug: Running test connection');
  testConnection();
} else {
  console.log('Debug: Script imported as module, not running test');
}

export default testConnection;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-connection.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-implementation.js ---\n#!/usr/bin/env node

/**
 * Test MongoDB Implementation Script
 * 
 * This script tests that the MongoDB implementation is working correctly
 * by performing basic operations on a test collection.
 * 
 * Usage:
 * 1. Set your MongoDB connection string in environment variable:
 *    - MONGODB_URI=your_mongodb_connection_string
 * 
 * 2. Run the script:
 *    node scripts/test-mongodb-implementation.js
 */

import { MongoClient } from 'mongodb';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables from .env.local
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: join(__dirname, '..', '.env.local') });

// Configuration
const MONGODB_URI = process.env.MONGODB_URI || process.env.DATABASE_URL;

// Validate configuration
if (!MONGODB_URI) {
  console.error('Error: Please set MONGODB_URI or DATABASE_URL environment variable');
  console.error('You can set it in .env.local file or as an environment variable');
  process.exit(1);
}

async function testImplementation() {
  let client;
  
  try {
    console.log('Testing MongoDB implementation...');
    
    // Connect to MongoDB
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('✓ Connected to MongoDB');
    
    const db = client.db();
    
    // Test collection operations
    const testCollection = db.collection('test_collection');
    
    // Test document insertion
    const testDocument = {
      name: 'Test Document',
      value: 42,
      createdAt: new Date(),
      tags: ['test', 'mongodb', 'implementation']
    };
    
    const insertResult = await testCollection.insertOne(testDocument);
    console.log('✓ Inserted test document:', insertResult.insertedId);
    
    // Test document retrieval
    const retrievedDocument = await testCollection.findOne({ _id: insertResult.insertedId });
    console.log('✓ Retrieved test document:', retrievedDocument.name, retrievedDocument.value);
    
    // Test document update
    const updateResult = await testCollection.updateOne(
      { _id: insertResult.insertedId },
      { $set: { value: 100, updatedAt: new Date() } }
    );
    console.log('✓ Updated test document:', updateResult.modifiedCount, 'document(s) modified');
    
    // Test document deletion
    const deleteResult = await testCollection.deleteOne({ _id: insertResult.insertedId });
    console.log('✓ Deleted test document:', deleteResult.deletedCount, 'document(s) deleted');
    
    // Test index creation
    await testCollection.createIndex({ name: 1 });
    console.log('✓ Created index on name field');
    
    // Test aggregation pipeline
    const pipeline = [
      { $match: { value: { $gte: 0 } } },
      { $group: { _id: null, count: { $sum: 1 } } }
    ];
    
    const aggregationResult = await testCollection.aggregate(pipeline).toArray();
    console.log('✓ Aggregation pipeline executed successfully');
    
    console.log('\n✓ MongoDB implementation test completed successfully!');
  } catch (error) {
    console.error('✗ MongoDB implementation test failed:', error);
    process.exit(1);
  } finally {
    if (client) {
      await client.close();
      console.log('✓ Disconnected from MongoDB');
    }
  }
}

// Run test if script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  testImplementation();
}

export default testImplementation;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\scripts\test-mongodb-implementation.js ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\App.tsx ---\nimport React, { useState, useCallback, useEffect, useRef, useReducer } from 'react';
import saveAs from 'file-saver';
import IdeaProfiler from './components/IdeaProfiler';
import BrandProfiler from './components/BrandProfiler';
import MainDisplay from './components/MainDisplay';
import AdminPage from './components/AdminPage';
import { ActiveTab } from './components/Header';
import Loader from './components/Loader';
import AirtableLoadModal from './components/AirtableLoadModal';
import SettingsModal from './components/SettingsModal';
import PersonaConnectModal from './components/PersonaConnectModal';
import Toast from './components/Toast';
import { generateImage } from './services/geminiService';
import { createDocxBlob, createMediaPlanXlsxBlob } from './services/exportService';
import { suggestProductsForPost } from './services/khongminhService';
import { generateImageWithOpenRouter } from './services/openrouterService';
import { textGenerationService } from './services/textGenerationService';
import { generateImageWithCloudflare } from './services/cloudflareService';
import {
    createOrUpdateBrandRecord,
    saveAffiliateLinks,
    deleteAffiliateLink as deleteAffiliateLinkFromAirtable,
    saveMediaPlanGroup,
    updateMediaPlanPostInAirtable,
    bulkUpdatePostSchedules,
    loadProjectFromAirtable,
    listMediaPlanGroupsForBrand,
    loadMediaPlan,
    syncAssetMedia,
    savePersona,
    deletePersonaFromAirtable,
    saveTrend,
    deleteTrendFromAirtable,
    saveIdeas,
    assignPersonaToPlanInAirtable,
    checkAirtableCredentials,
    fetchAffiliateLinksForBrand,
    loadIdeasForTrend,
    checkIfProductExistsInAirtable,
} from './services/databaseService';

// Lazy loading functions
import {
    loadStrategyHub,
    loadAffiliateVault,
    loadPersonas,
    loadMediaPlanGroups,
    loadMediaPlanPosts,
    loadInitialData,
} from './services/lazyLoadService';
import { uploadMediaToCloudinary } from './services/cloudinaryService';
import { schedulePost as socialApiSchedulePost, directPost, SocialAccountNotConnectedError } from './services/socialApiService';
import { getPersonaSocialAccounts } from './services/socialAccountService';
import type { BrandInfo, GeneratedAssets, Settings, MediaPlanGroup, MediaPlan, MediaPlanPost, AffiliateLink, SchedulingPost, MediaPlanWeek, LogoConcept, Persona, PostStatus, Trend, Idea, PostInfo, FacebookTrend, FacebookPostIdea } from '../types';
import { Button } from './components/ui';
import { configService, AiModelConfig } from './services/configService';

const isVisionModel = (modelName: string): boolean => {
    // Cloudflare and OpenRouter models in this app are currently text-to-image or have different input methods
    // that are handled by their respective service files. This check is primarily for Gemini/Google models.
    // If future vision models are added from other providers, they should be included here.
    return configService.getAiModelConfig().visionModels.includes(modelName);
};

// --- STATE MANAGEMENT REFACTOR (useReducer) ---

type AssetsAction =
  | { type: 'INITIALIZE_ASSETS'; payload: GeneratedAssets }
  | { type: 'ADD_MEDIA_PLAN'; payload: MediaPlanGroup }
  | { type: 'UPDATE_POST'; payload: { planId: string; weekIndex: number; postIndex: number; updates: Partial<MediaPlanPost> } }
  | { type: 'UPDATE_PLAN'; payload: { planId: string; plan: MediaPlan } }
  | { type: 'UPDATE_ASSET_IMAGE'; payload: { oldImageKey: string; newImageKey: string; postInfo?: PostInfo } }
  | { type: 'ADD_OR_UPDATE_AFFILIATE_LINK'; payload: AffiliateLink }
  | { type: 'DELETE_AFFILIATE_LINK'; payload: string }
  | { type: 'IMPORT_AFFILIATE_LINKS'; payload: AffiliateLink[] }
  | { type: 'BULK_UPDATE_ASSET_IMAGES', payload: { postInfo: PostInfo, newImageKey: string }[] }
  | { type: 'BULK_SCHEDULE_POSTS', payload: { updates: { postId: string; scheduledAt: string; status: 'scheduled' }[] } }
  | { type: 'SAVE_PERSONA'; payload: Persona }
  | { type: 'DELETE_PERSONA'; payload: string }
  | { type: 'SAVE_TREND'; payload: Trend }
  | { type: 'DELETE_TREND'; payload: string }
  | { type: 'ADD_IDEAS'; payload: Idea[] }
  | { type: 'SET_IDEAS'; payload: Idea[] }
  | { type: 'ADD_CONTENT_PACKAGE'; payload: MediaPlanGroup }
  | { type: 'ASSIGN_PERSONA_TO_PLAN'; payload: { planId: string; personaId: string | null; } }
  | { type: 'SET_FACEBOOK_TRENDS'; payload: FacebookTrend[] }
  | { type: 'ADD_FACEBOOK_POST_IDEAS'; payload: FacebookPostIdea[] }
  | { type: 'SET_SELECTED_PLATFORMS'; payload: string[] };

export const assetsReducer = (state: GeneratedAssets | null, action: AssetsAction): GeneratedAssets | null => {
    switch (action.type) {
        case 'INITIALIZE_ASSETS':
            return action.payload;
        
        case 'ADD_MEDIA_PLAN': {
            if (!state) return state;
            return {
                ...state,
                mediaPlans: [...state.mediaPlans, action.payload]
            };
        }

        case 'UPDATE_POST': {
            if (!state) return state;
            const { planId, weekIndex, postIndex, updates } = action.payload;
            const newState = JSON.parse(JSON.stringify(state));
            const planIndex = newState.mediaPlans.findIndex((p: MediaPlanGroup) => p.id === planId);
            
            if (planIndex !== -1) {
                const postToUpdate = newState.mediaPlans[planIndex].plan[weekIndex]?.posts[postIndex];
                if (postToUpdate) {
                    newState.mediaPlans[planIndex].plan[weekIndex].posts[postIndex] = { ...postToUpdate, ...updates };
                }
            }
            return newState;
        }
        
        case 'UPDATE_PLAN': {
            if (!state) return state;
            const { planId, plan } = action.payload;
            const newState = JSON.parse(JSON.stringify(state));
            const planIndex = newState.mediaPlans.findIndex((p: MediaPlanGroup) => p.id === planId);
            
            if (planIndex !== -1) {
                newState.mediaPlans[planIndex].plan = plan;
            }
            return newState;
        }
        
        case 'UPDATE_ASSET_IMAGE': {
            if (!state) return state;
            const { oldImageKey, newImageKey, postInfo } = action.payload;
            const newState = JSON.parse(JSON.stringify(state));

            if (postInfo) {
                const plan = newState.mediaPlans.find((p: MediaPlanGroup) => p.id === postInfo.planId);
                if (plan) {
                    const post = plan.plan[postInfo.weekIndex]?.posts[postInfo.postIndex];
                    if (post?.id === postInfo.post.id) {
                        post.imageKey = newImageKey;
                        if (!post.mediaOrder) post.mediaOrder = [];
                        if (!post.mediaOrder.includes('image')) post.mediaOrder.push('image');
                    }
                }
            } else if (oldImageKey?.startsWith('logo_')) {
                const logo = newState.coreMediaAssets.logoConcepts.find((l: LogoConcept) => l.imageKey === oldImageKey);
                if (logo) logo.imageKey = newImageKey;
            } else if (oldImageKey?.startsWith('profile_')) {
                if (newState.unifiedProfileAssets.profilePictureImageKey === oldImageKey) {
                    newState.unifiedProfileAssets.profilePictureImageKey = newImageKey;
                }
            } else if (oldImageKey?.startsWith('cover_')) {
                if (newState.unifiedProfileAssets.coverPhotoImageKey === oldImageKey) {
                    newState.unifiedProfileAssets.coverPhotoImageKey = newImageKey;
                }
            }
            return newState;
        }

        case 'ADD_OR_UPDATE_AFFILIATE_LINK': {
            if (!state) return state;
            const newLink = action.payload;
            const existingLinks = state.affiliateLinks || [];
            const index = existingLinks.findIndex(l => l.id === newLink.id);
            let updatedLinks;

            if (index > -1) {
                updatedLinks = [...existingLinks];
                updatedLinks[index] = newLink;
            } else {
                updatedLinks = [newLink, ...existingLinks];
            }
            return { ...state, affiliateLinks: updatedLinks };
        }

        case 'DELETE_AFFILIATE_LINK': {
             if (!state) return state;
             const linkId = action.payload;
             const updatedLinks = (state.affiliateLinks || []).filter(l => l.id !== linkId);
             return { ...state, affiliateLinks: updatedLinks };
        }

        case 'IMPORT_AFFILIATE_LINKS': {
            if (!state) return state;
            return { ...state, affiliateLinks: [...(state.affiliateLinks || []), ...action.payload] };
        }
        
        case 'BULK_UPDATE_ASSET_IMAGES': {
            if (!state) return state;
            const newState = JSON.parse(JSON.stringify(state));
            const updatesMap = new Map(action.payload.map(u => [u.postInfo.post.id, u.newImageKey]));
        
            newState.mediaPlans.forEach((plan: MediaPlanGroup) => {
                plan.plan.forEach((week: MediaPlanWeek) => {
                    week.posts.forEach((post: MediaPlanPost) => {
                        if (updatesMap.has(post.id)) {
                            post.imageKey = updatesMap.get(post.id)!;
                            if (!post.mediaOrder) post.mediaOrder = [];
                            if (!post.mediaOrder.includes('image')) {
                                (post.mediaOrder as ('image' | 'video')[]).push('image');
                            }
                        }
                    });
                });
            });
        
            return newState;
        }

        case 'BULK_SCHEDULE_POSTS': {
            if (!state) return state;
            const { updates } = action.payload;
            const newState = JSON.parse(JSON.stringify(state));
            const updatesMap = new Map(updates.map(u => [u.postId, { scheduledAt: u.scheduledAt, status: u.status }]));
            
            newState.mediaPlans.forEach((plan: MediaPlanGroup) => {
                plan.plan.forEach((week: MediaPlanWeek) => {
                    week.posts.forEach((post: MediaPlanPost) => {
                        if (updatesMap.has(post.id)) {
                            const update = updatesMap.get(post.id)!;
                            post.scheduledAt = update.scheduledAt;
                            post.status = update.status;
                        }
                    });
                });
            });

            return newState;
        }

        case 'SAVE_PERSONA': {
            if (!state) return state;
            const newPersona = action.payload;
            const existingPersonas = state.personas || [];
            const index = existingPersonas.findIndex(p => p.id === newPersona.id);
            let updatedPersonas;

            if (index > -1) {
                updatedPersonas = [...existingPersonas];
                updatedPersonas[index] = newPersona;
            } else {
                updatedPersonas = [newPersona, ...existingPersonas];
            }
            return { ...state, personas: updatedPersonas };
        }

        case 'DELETE_PERSONA': {
            if (!state) return state;
            const personaId = action.payload;
            const updatedPersonas = (state.personas || []).filter(p => p.id !== personaId);
            return { ...state, personas: updatedPersonas };
        }

        case 'SAVE_TREND': {
            if (!state) return state;
            const newTrend = action.payload;
            const existingTrends = state.trends || [];
            const index = existingTrends.findIndex(t => t.id === newTrend.id);
            let updatedTrends;

            if (index > -1) {
                updatedTrends = [...existingTrends];
                updatedTrends[index] = newTrend;
            } else {
                updatedTrends = [newTrend, ...existingTrends];
            }
            return { ...state, trends: updatedTrends };
        }

        case 'DELETE_TREND': {
            if (!state) return state;
            const trendId = action.payload;
            const updatedTrends = (state.trends || []).filter(t => t.id !== trendId);
            return { ...state, trends: updatedTrends };
        }

        case 'ADD_IDEAS': {
            if (!state) return state;
            const newIdeas = action.payload;
            if (newIdeas.length === 0) return state;
            const trendId = newIdeas[0].trendId;
            const existingIdeas = state.ideas || [];
            // Filter out any old ideas for this trend before adding new ones
            const otherIdeas = existingIdeas.filter(i => i.trendId !== trendId);
            return { ...state, ideas: [...otherIdeas, ...newIdeas] };
        }
        
        case 'ADD_CONTENT_PACKAGE': {
            if (!state) return state;
            // Content packages are now just MediaPlanGroups with a specific source
            return {
                ...state,
                mediaPlans: [...(state.mediaPlans || []), action.payload]
            };
        }

        case 'SET_SELECTED_PLATFORMS': {
            if (!state) return state;
            return { ...state, selectedPlatforms: action.payload };
        }

        case 'ASSIGN_PERSONA_TO_PLAN': {
            if (!state) return state;
            const { planId, personaId } = action.payload;
            const newState = JSON.parse(JSON.stringify(state));
            const planIndex = newState.mediaPlans.findIndex((p: MediaPlanGroup) => p.id === planId);
            if (planIndex === -1) return state;

            const planToUpdate = newState.mediaPlans[planIndex];
            const oldPersonaId = planToUpdate.personaId;
            const allPersonas = newState.personas || [];
            
            const oldPersona = allPersonas.find((p: Persona) => p.id === oldPersonaId);
            const newPersona = allPersonas.find((p: Persona) => p.id === personaId);

            planToUpdate.personaId = personaId || undefined;

            // Update image prompts for all posts in the plan
            planToUpdate.plan.forEach((week: MediaPlanWeek) => {
                week.posts.forEach((post: MediaPlanPost) => {
                    if (post.mediaPrompt) {
                        let prompt = Array.isArray(post.mediaPrompt) ? post.mediaPrompt[0] : post.mediaPrompt;
                        // 1. Remove old prefix if it exists
                        if (oldPersona && prompt.startsWith(`${oldPersona.outfitDescription}, `)) {
                            prompt = prompt.substring(`${oldPersona.outfitDescription}, `.length);
                        }
                        // 2. Add new prefix if a new persona is assigned
                        if (newPersona) {
                            prompt = `${newPersona.outfitDescription}, ${prompt}`;
                        }
                        post.mediaPrompt = prompt;
                    }
                });
            });

            return newState;
        }

        case 'SET_IDEAS': {
            if (!state) return state;
            console.log("DEBUG: SET_IDEAS called with:", action.payload);
            return { ...state, ideas: action.payload };
        }

        case 'ADD_FACEBOOK_POST_IDEAS': {
            if (!state) return state;
            const newIdeas = action.payload;
            if (newIdeas.length === 0) return state;
            const existingIdeas = state.facebookPostIdeas || [];
            return { ...state, facebookPostIdeas: [...existingIdeas, ...newIdeas] };
        }

        default:
            return state;
    }
};

// Helper functions for file serialization

const base64ToFile = (base64Data: string, filename: string, mimeType: string): File => {
    if (!base64Data || typeof base64Data !== 'string') {
        console.error('Invalid base64 data provided to base64ToFile:', filename);
        return new File([], filename, { type: mimeType });
    }
    const parts = base64Data.split(',');
    // Added a check to ensure the data URL is valid before processing.
    if (parts.length < 2 || !parts[1]) {
      console.error('Invalid data URL format in project file:', filename);
      // Return an empty file to prevent a crash on corrupted data.
      return new File([], filename, { type: mimeType });
    }
    // Clean the base64 part by removing any whitespace.
    const cleanedBase64 = parts[1].replace(/\s/g, '');
    const byteString = atob(cleanedBase64);
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    const blob = new Blob([ab], { type: mimeType });
    return new File([blob], filename, { type: mimeType });
};

const initialGeneratedAssets: GeneratedAssets = {
    mediaPlans: [],
    personas: [],
    trends: [],
    ideas: [],
    affiliateLinks: [],
    coreMediaAssets: {
        logoConcepts: [],
    },
    unifiedProfileAssets: {
        profilePictureImageKey: null,
        coverPhotoImageKey: null,
    },
    facebookPostIdeas: [],
    selectedPlatforms: []
};

const App: React.FC = () => {
    const [currentStep, setCurrentStep] = useState<'idea' | 'profile' | 'assets'>('idea');
    const [brandInfo, setBrandInfo] = useState<BrandInfo | null>(null);
    const [generatedAssets, dispatchAssets] = useReducer(assetsReducer, null);
    const [loaderContent, setLoaderContent] = useState<{ title: string; steps: string[]; } | null>(null);
    const [isExporting, setIsExporting] = useState<boolean>(false);
    const [isSaving, setIsSaving] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [successMessage, setSuccessMessage] = useState<string | null>(null);
    const [waitMessage, setWaitMessage] = useState<string | null>(null);
    const [generatedImages, setGeneratedImages] = useState<Record<string, string>>({});
    const [generatedVideos, setGeneratedVideos] = useState<Record<string, string>>({});
    const [generatingImageKeys, setGeneratingImageKeys] = useState<Set<string>>(new Set());
    const [uploadingImageKeys, setUploadingImageKeys] = useState<Set<string>>(new Set());
    const [generatingPromptKeys, setGeneratingPromptKeys] = useState<Set<string>>(new Set());
    const [analyzingPostIds, setAnalyzingPostIds] = useState<Set<string>>(new Set());
    const [khongMinhSuggestions, setKhongMinhSuggestions] = useState<Record<string, AffiliateLink[]>>({});
    const [generatingCommentPostIds, setGeneratingCommentPostIds] = useState<Set<string>>(new Set());
    // Global product images removed, now managed per-plan.
    
    const [settings, setSettings] = useState<Settings>({
        language: 'English',
        totalPostsPerMonth: 30,
        mediaPromptSuffix: '',
        affiliateContentKit: '',
        textGenerationModel: 'gemini-1.5-flash',
        imageGenerationModel: '@cf/stabilityai/stable-diffusion-xl-base-1.0'
    });
    const [aiModelConfig, setAiModelConfig] = useState<AiModelConfig | null>(null);
    
    // Admin authentication state
    const [isAdminAuthenticated, setIsAdminAuthenticated] = useState<boolean>(false);
    const [adminPassword, setAdminPassword] = useState<string>('');
    
    // Integration States
    const [isAirtableLoadModalOpen, setIsAirtableLoadModalOpen] = useState<boolean>(false);
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState<boolean>(false);
    const [isPersonaConnectModalOpen, setIsPersonaConnectModalOpen] = useState<boolean>(false);
    const [personaToConnect, setPersonaToConnect] = useState<Persona | null>(null);
    const [platformToConnect, setPlatformToConnect] = useState<string | null>(null);
    const personaConnectSuccessCallback = useRef<(() => void) | null>(null);
    const [isSavingSettings, setIsSavingSettings] = useState<boolean>(false);
    const [airtableBrandId, setAirtableBrandId] = useState<string | null>(null);
    const [integrationsVersion, setIntegrationsVersion] = useState(0);

    // Auto-Save State
    const autoSaveTimeoutRef = useRef<number | null>(null);

    // Ref to store the product trend ID to select in StrategyDisplay
    
    // State to track the product trend to select (for passing to MainDisplay)
    const [productTrendToSelect, setProductTrendToSelect] = useState<string | null>(null);

    // Log environment variables for debugging
    useEffect(() => {
        // console.log("Environment variables at startup:", import.meta.env);
        // Check BFF health instead of directly accessing environment variables
        import('./services/bffService').then(({ checkBffHealth }) => {
            checkBffHealth().then(health => {
                if (health.services.gemini) {
                    console.log("Gemini API Key is configured on the BFF");
                } else {
                    console.log("Gemini API Key is not configured on the BFF");
                }
            }).catch(error => {
                console.log("Failed to check BFF health:", error);
            });
        }).catch(error => {
            console.log("Failed to import BFF service:", error);
        });
    }, []);

    // Lazy loading callbacks for MainDisplay component
    const handleLoadStrategyHubData = useCallback(async () => {
        // If no brand ID, we can't load data from Airtable
        if (!airtableBrandId) {
            // For local projects without Airtable integration, we still want to show the UI
            // but with empty data. The components will handle this case.
            console.log("No Airtable brand ID, skipping strategy hub data load");
            return Promise.resolve();
        }
        
        try {
            const { trends, ideas } = await loadStrategyHub(airtableBrandId);
            
            // Update the assets with the loaded data
            dispatchAssets({ 
                type: 'INITIALIZE_ASSETS', 
                payload: {
                    ...generatedAssets!,
                    trends,
                    ideas
                }
            });
            return Promise.resolve();
        } catch (error) {
            console.error("Failed to load strategy hub data:", error);
            setError(error instanceof Error ? error.message : "Could not load strategy hub data.");
            return Promise.reject(error);
        }
    }, [airtableBrandId, generatedAssets, dispatchAssets, setError]);

    const handleLoadAffiliateVaultData = useCallback(async () => {
        // If no brand ID, we can't load data from Airtable
        if (!airtableBrandId) {
            // For local projects without Airtable integration, we still want to show the UI
            // but with empty data. The components will handle this case.
            console.log("No Airtable brand ID, skipping affiliate vault data load");
            return Promise.resolve();
        }
        
        try {
            const affiliateLinks = await loadAffiliateVault(airtableBrandId);
            
            // Update the assets with the loaded data
            dispatchAssets({ 
                type: 'INITIALIZE_ASSETS', 
                payload: {
                    ...generatedAssets!,
                    affiliateLinks
                }
            });
            return Promise.resolve();
        } catch (error) {
            console.error("Failed to load affiliate vault data:", error);
            setError(error instanceof Error ? error.message : "Could not load affiliate vault data.");
            return Promise.reject(error);
        }
    }, [airtableBrandId, generatedAssets, dispatchAssets, setError]);

    const handleLoadPersonasData = useCallback(async () => {
        // If no brand ID, we can't load data from Airtable
        if (!airtableBrandId) {
            // For local projects without Airtable integration, we still want to show the UI
            // but with empty data. The components will handle this case.
            console.log("No Airtable brand ID, skipping personas data load");
            return Promise.resolve();
        }
        
        try {
            const personas = await loadPersonas(airtableBrandId);
            
            // Update the assets with the loaded data
            dispatchAssets({ 
                type: 'INITIALIZE_ASSETS', 
                payload: {
                    ...generatedAssets!,
                    personas
                }
            });
            return Promise.resolve();
        } catch (error) {
            console.error("Failed to load personas data:", error);
            setError(error instanceof Error ? error.message : "Could not load personas data.");
            return Promise.reject(error);
        }
    }, [airtableBrandId, generatedAssets, dispatchAssets, setError]);

    // Set brandId in configService when it changes
    useEffect(() => {
        if (airtableBrandId) {
            configService.setBrandId(airtableBrandId).then(() => {
                // Update the settings state after the brand config is loaded
                const updatedSettings = configService.getAppSettings();
                setSettings(updatedSettings);
                setAiModelConfig(configService.getAiModelConfig());
            }).catch(error => {
                console.error("Failed to set brand ID:", error);
            });
        } else {
            // Reset to default settings when no brand is selected
            setSettings(configService.getAppSettings());
            setAiModelConfig(configService.getAiModelConfig());
        }
    }, [airtableBrandId]);

    // Media Plan On-Demand Loading State
    const [mediaPlanGroupsList, setMediaPlanGroupsList] = useState<{id: string, name: string, prompt: string, productImages?: { name: string, type: string, data: string }[]}[]>([]);
    const [activePlanId, setActivePlanId] = useState<string | null>(null);
    const [activeTab, setActiveTab] = useState<ActiveTab>('brandKit');
    
    // Reset productTrendToSelect when we switch away from the strategy tab
    useEffect(() => {
        if (activeTab !== 'strategyHub' && productTrendToSelect) {
            setProductTrendToSelect(null);
        }
    }, [activeTab, productTrendToSelect]);
    
    // Wizard state
    const [initialWizardPrompt, setInitialWizardPrompt] = useState<string | null>(null);
    const [initialProductId, setInitialProductId] = useState<string | null>(null);
    const [personaIdForWizard, setPersonaIdForWizard] = useState<string | null>(null);
    const [optionsForWizard, setOptionsForWizard] = useState<{ tone: string; style: string; length: string } | null>(null);
    const [isWizardOpen, setIsWizardOpen] = useState<boolean>(false);
    
    // Selection & Scheduling State
    const [selectedPostIds, setSelectedPostIds] = useState<Set<string>>(new Set());
    const [schedulingPost, setSchedulingPost] = useState<SchedulingPost | null>(null);
    const [isBulkScheduleModalOpen, setIsBulkScheduleModalOpen] = useState<boolean>(false);
    const [isScheduling, setIsScheduling] = useState<boolean>(false);

    // Bulk Action State
    const [bulkActionStatus, setBulkActionStatus] = useState<{ title: string; steps: string[]; currentStep: number } | null>(null);

    // Credential Assurance Workflow
    const onModalCloseRef = useRef<(() => void) | null>(null);
    
    const [autoSaveStatus, setAutoSaveStatus] = useState<'idle' | 'saving' | 'saved' | 'error'>('idle');

    // Strategy Hub State
    const [isGeneratingFacebookTrends, setIsGeneratingFacebookTrends] = useState(false);
    const [isGeneratingFacebookPostIdeas, setIsGeneratingFacebookPostIdeas] = useState(false);

    const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
    const [areCredentialsSet, setAreCredentialsSet] = useState(false);
    const [viewingPost, setViewingPost] = useState<PostInfo | null>(null);

    const [isConfigLoaded, setIsConfigLoaded] = useState(false);

    useEffect(() => {
        const loadInitialConfig = async () => {
            try {
                await configService.initializeConfig();
                setSettings(configService.getAppSettings());
                setAiModelConfig(configService.getAiModelConfig());
                const areSet = await checkAirtableCredentials();
                console.log('areCredentialsSet', areSet);
                setAreCredentialsSet(areSet);
                if (areSet) {
                    setToast({ message: 'Successfully connected to outer services.', type: 'success' });
                } else {
                    setToast({ message: 'Failed to connect to outer services. Please check your credentials.', type: 'error' });
                }
            } catch (error) {
                console.error("Failed to load initial configuration:", error);
                setError("Failed to load initial configuration. Please check your Database setup.");
            } finally {
                setIsConfigLoaded(true);
            }
        };
        loadInitialConfig();
    }, []);

    const isLoading = !!loaderContent;
    const isPerformingBulkAction = !!bulkActionStatus;


    const updateAutoSaveStatus = useCallback((status: 'saving' | 'saved' | 'error') => {
        setAutoSaveStatus(status);
        if (autoSaveTimeoutRef.current) {
            clearTimeout(autoSaveTimeoutRef.current);
        }
        if (status === 'saved' || status === 'error') {
            autoSaveTimeoutRef.current = window.setTimeout(() => {
                setAutoSaveStatus('idle');
            }, 3000);
        }
    }, []);

    const executeTextGenerationWithFallback = useCallback(async <T extends unknown>(
        generationTask: (model: string) => Promise<T>,
        preferredModel: string
    ): Promise<T> => {
        console.log("Preferred model:", preferredModel);
        
        // Use textModelFallbackOrder from aiModelConfig if available, otherwise use an empty array
        const textModelFallbackOrder = aiModelConfig?.textModelFallbackOrder || [];
        const modelsToTry = [
            preferredModel, 
            ...textModelFallbackOrder.filter((m: string) => m !== preferredModel)
        ];
        console.log("Models to try:", modelsToTry);

        let lastError: Error | null = null;
        let rateLimitErrorCount = 0;
        const RATE_LIMIT_THRESHOLD = 2; 

        for (const model of modelsToTry) {
            try {
                console.log(`Attempting text generation with model: ${model}`);
                
                if (model.startsWith('gemini-') && !model.includes('free')) {
                    // Check BFF health instead of directly accessing environment variables
                    try {
                        const { checkBffHealth } = await import('./services/bffService');
                        const health = await checkBffHealth();
                        console.log(`Checking Gemini API key for model ${model}:`, health.services.gemini ? "Key exists on BFF" : "Key is missing on BFF");
                        if (!health.services.gemini) {
                            console.log(`Skipping ${model} because Gemini API key is not configured on BFF`);
                            throw new Error("Gemini API key is not configured on the BFF. Please check your server .env file and restart the BFF server.");
                        }
                    } catch (error) {
                        console.log(`Failed to check BFF health for model ${model}:`, error);
                        throw new Error("Failed to check BFF health. Please ensure the BFF server is running.");
                    }
                }
                
                const result = await generationTask(model);
                
                if (model !== preferredModel) {
                    setSettings(prev => ({ ...prev, textGenerationModel: model }));
                }
                
                return result;
            } catch (error: any) {
                console.error(`Text generation failed with model ${model}:`, error);
                lastError = error;
                
                // Special handling for rate limit errors
                if (error.message && (error.message.includes('429') || error.message.includes('rate limit'))) {
                    rateLimitErrorCount++;
                    if (rateLimitErrorCount >= RATE_LIMIT_THRESHOLD) {
                        console.log(`Rate limit threshold (${RATE_LIMIT_THRESHOLD}) reached. Waiting before next attempt...`);
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
                    }
                }
                
                // If it's a model-specific error (e.g., unsupported model), continue to the next model
                if (error.message && (error.message.includes('not supported') || error.message.includes('invalid model'))) {
                    console.log(`Skipping model ${model} due to model-specific error.`);
                    continue;
                }
                
                // For other errors, we might want to stop trying other models
                // unless it's a rate limit error
                if (!(error.message && (error.message.includes('429') || error.message.includes('rate limit')))) {
                    console.log("Non-rate limit error encountered. Stopping fallback attempts.");
                    break;
                }
            }
        }
        
        // If we get here, all models failed
        console.error("All text generation models failed.", lastError);
        throw lastError || new Error("All text generation models failed.");
    }, [aiModelConfig, setSettings]);

    const ensureAirtableProject = useCallback(async (assetsToSave?: GeneratedAssets): Promise<string | null> => {
        const assets = assetsToSave || generatedAssets;
        
        if (!areCredentialsSet) return null;

        if (airtableBrandId) return airtableBrandId;
    
        if (!assets) throw new Error("Cannot create Airtable project without assets.");
    
        updateAutoSaveStatus('saving');
        console.log("Creating new project record in Airtable...");
        
        const newPublicUrls = await uploadMediaToCloudinary(generatedImages);
        const allImageUrls = { ...generatedImages, ...newPublicUrls };

        const newBrandId = await createOrUpdateBrandRecord(
            assets,
            allImageUrls,
            null
        );
        
        setAirtableBrandId(newBrandId);
        setGeneratedImages(allImageUrls); 

        if (assets.mediaPlans && assets.mediaPlans.length > 0) {
            console.log(`Saving initial media plan...`);
            try {
                await saveMediaPlanGroup(assets.mediaPlans[0], allImageUrls, newBrandId);
                console.log(`Initial media plan saved successfully.`);
            } catch (error) {
                console.error(`Failed to save initial media plan:`, error);
                setError(error instanceof Error ? error.message : "Could not save the initial media plan.");
                // Decide if you want to throw the error, or just log it and continue
            }
        }

        console.log("New project record created with Brand ID:", newBrandId);
        updateAutoSaveStatus('saved');
        return newBrandId;
    }, [airtableBrandId, generatedAssets, generatedImages, updateAutoSaveStatus]);

    
    const handleSetProductImages = () => {
        // This function is now a stub, as product images are managed locally in the wizard.
        // It could be repurposed for brand-level product images if it needed in the future.
        console.warn("handleSetProductImages is deprecated for plan-specific images.");
    };

    
    const setLanguage = async (lang: string) => {
        await configService.updateAppSettings({ ...settings, language: lang });
        setSettings(configService.getAppSettings());
    }

    const handleGenerateProfile = useCallback(async (idea: string) => {
        setLoaderContent({
            title: settings?.language === 'Việt Nam' ? "AI đang xây dựng hồ sơ..." : "AI is building your profile...",
            steps: [
                "Analyzing your business idea...",
                "Generating a creative brand name...",
                "Defining a powerful mission statement...",
                "Identifying core values and personality...",
                "Finalizing brand profile..."
            ]
        });
        setError(null);
        try {
            const generationTask = (model: string) => {
                return textGenerationService.generateBrandProfile(idea, settings.language, model);
            };
            const profile = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            setBrandInfo(profile);
            setCurrentStep('profile');
        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : "Failed to generate brand profile.");
        } finally {
            setLoaderContent(null);
        }
    }, [settings?.textGenerationModel, settings?.language, executeTextGenerationWithFallback]);

    const handleGenerateKit = useCallback(async (info: BrandInfo) => {
        setBrandInfo(info);
        const kitSteps = settings?.language === 'Việt Nam' ? [
            "Phân tích hồ sơ thương hiệu của bạn...",
            "Xây dựng nền tảng thương hiệu cốt lõi...",
            "Thiết kế các ý tưởng logo và bảng màu...",
            "Tạo tài sản hồ sơ mạng xã hội...",
            "Xây dựng kế hoạch truyền thông 4 tuần ban đầu...",
            "Hoàn thiện tài sản..."
        ] : [
            "Analyzing your brand profile...",
            "Crafting core brand foundation...",
            "Designing logo concepts & color palette...",
            "Generating social media profile assets...",
            "Building initial 4-week media plan...",
            "Finalizing assets..."
        ];
        setLoaderContent({
            title: settings?.language === 'Việt Nam' ? "AI đang xây dựng bộ thương hiệu của bạn..." : "AI is building your brand kit...",
            steps: kitSteps
        });
        setError(null);
        try {
            const generationTask = (model: string) => {
                return textGenerationService.generateBrandKit(info, settings.language, model);
            };
            const kit = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);

            const fullAssets: GeneratedAssets = { ...kit, affiliateLinks: [], personas: [], trends: [], ideas: [] };
            dispatchAssets({ type: 'INITIALIZE_ASSETS', payload: fullAssets });

            const firstPlan = kit.mediaPlans[0];
            if (firstPlan) {
                setMediaPlanGroupsList([{ id: firstPlan.id, name: firstPlan.name, prompt: firstPlan.prompt, productImages: firstPlan.productImages || [] }]);
                setActivePlanId(firstPlan.id);
            } else {
                setMediaPlanGroupsList([]);
                setActivePlanId(null);
            }

            setCurrentStep('assets');
            setActiveTab(firstPlan ? 'mediaPlan' : 'brandKit');

            ensureAirtableProject(fullAssets).catch(err => {
                console.error("Failed to auto-create Airtable project:", err);
                setError(err instanceof Error ? err.message : "Could not create initial Airtable project.");
            });
        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : "An unknown error occurred.");
        } finally {
            setLoaderContent(null);
        }
    }, [settings?.language, settings?.textGenerationModel, ensureAirtableProject, executeTextGenerationWithFallback]);

    const handleGenerateMediaPlanGroup = useCallback((
        prompt: string, 
        useSearch: boolean, 
        totalPosts: number, 
        selectedPlatforms: string[],
        options: { tone: string; style: string; length: string; includeEmojis: boolean; },
        selectedProductId: string | null, 
        personaId: string | null
    ) => {
        // Wrap the async logic in an async IIFE
        (async () => {
            if (!generatedAssets?.brandFoundation) {
                setError("Cannot generate plan without a Brand Foundation.");
                return;
            }
            
            const planSteps = settings?.language === 'Việt Nam' ? [
                `Phân tích mục tiêu của bạn: "${prompt.substring(0, 50)}..."`,
                "Thiết lập chủ đề hàng tuần...",
                "Soạn thảo bài đăng...",
                "Tạo các hashtag hấp dẫn và CTA...",
                "Hoàn thiện kế hoạch..."
            ] : [
                `Analyzing your goal: "${prompt.substring(0, 50)}..."`,
                "Establishing weekly themes...",
                "Drafting posts...",
                "Generating engaging hashtags and CTAs...",
                "Finalizing plan..."
            ];

            setLoaderContent({ title: settings?.language === 'Việt Nam' ? "Đang tạo kế hoạch truyền thông..." : "Generating media plan...", steps: planSteps });
            setError(null);
            try {
                const persona = personaId ? generatedAssets.personas?.find(p => p.id === personaId) ?? null : null;
                const selectedProduct = selectedProductId ? generatedAssets.affiliateLinks?.find(link => link.id === selectedProductId) ?? null : null;
                
                const generationTask = async (model: string) => {
                    return textGenerationService.generateMediaPlanGroup(
                        generatedAssets.brandFoundation,
                        prompt,
                        settings.language,
                        totalPosts,
                        useSearch,
                        selectedPlatforms,
                        options,
                        settings.affiliateContentKit,
                        model,
                        persona,
                        selectedProduct
                    );
                };
                const newGroup = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
                
                // Append mediaPromptSuffix to each post's mediaPrompt
                const mediaPromptSuffix = settings.mediaPromptSuffix;
                const updatedPlan = newGroup.plan.map(week => ({
                    ...week,
                    posts: week.posts.map(post => {
                        if (post.mediaPrompt) {
                            if (Array.isArray(post.mediaPrompt)) {
                                // For carousel posts, append suffix to each prompt in the array
                                return {
                                    ...post,
                                    mediaPrompt: post.mediaPrompt.map(prompt => prompt + mediaPromptSuffix)
                                };
                            } else {
                                // For single prompts, append the suffix
                                return {
                                    ...post,
                                    mediaPrompt: post.mediaPrompt + mediaPromptSuffix
                                };
                            }
                        }
                        return post;
                    })
                }));

                const updatedGroup = {
                    ...newGroup,
                    plan: updatedPlan
                };
                

                dispatchAssets({ type: 'ADD_MEDIA_PLAN', payload: updatedGroup });
                setMediaPlanGroupsList(prev => [...prev, { id: updatedGroup.id, name: updatedGroup.name, prompt: updatedGroup.prompt, productImages: updatedGroup.productImages }]);
                setActivePlanId(updatedGroup.id);
                setKhongMinhSuggestions({});
                
                updateAutoSaveStatus('saving');
                const brandId = await ensureAirtableProject();
                if (!brandId) {
                    setAutoSaveStatus('idle');
                    setLoaderContent(null); 
                    setError("Airtable credentials not configured. Media plan not saved.");
                    return;
                }

                const newPublicUrls = await uploadMediaToCloudinary(generatedImages);
                const allImageUrls = { ...generatedImages, ...newPublicUrls };

                await saveMediaPlanGroup(updatedGroup, allImageUrls, brandId);
                setGeneratedImages(allImageUrls); 
                updateAutoSaveStatus('saved');
                setLoaderContent(null); 

            } catch (err) {
                console.error(err);
                setError(err instanceof Error ? err.message : "Failed to generate media plan.");
                updateAutoSaveStatus('error');
                setLoaderContent(null); 
            }
        })();
    }, [generatedAssets, settings, ensureAirtableProject, generatedImages, updateAutoSaveStatus, executeTextGenerationWithFallback]);

    // New handler for creating funnel campaign plans
    const handleCreateFunnelCampaignPlan = useCallback(async (planShell: MediaPlanGroup & { wizardData?: any }) => {
        if (!generatedAssets?.brandFoundation) {
            setError("Cannot generate plan without a Brand Foundation.");
            return;
        }

        const { wizardData } = planShell;
        if (!wizardData) {
            setError("Funnel campaign wizard data is missing.");
            return;
        }

        const {
            campaignDuration,
            primaryObjective,
            generalGoal,
            selectedProductId,
            selectedPersonaId,
        } = wizardData;

        const calculateTotalPosts = () => {
            switch (campaignDuration) {
              case '1-week': return 7;
              case '2-weeks': return 14;
              case '1-month': return 30;
              default: return 30;
            }
        };

        const totalPosts = calculateTotalPosts();
        const persona = selectedPersonaId ? generatedAssets.personas?.find(p => p.id === selectedPersonaId) ?? null : null;
        const selectedProduct = selectedProductId ? generatedAssets.affiliateLinks?.find(link => link.id === selectedProductId) ?? null : null;

        const prompt = primaryObjective === 'product' && selectedProduct 
            ? `Generate a full ${campaignDuration} marketing funnel campaign to promote the product "${selectedProduct.productName}". The campaign should include awareness, consideration, decision, and action stages, totaling approximately ${totalPosts} posts.` 
            : `Generate a full ${campaignDuration} marketing funnel campaign for the general goal: "${generalGoal}". The campaign should include awareness, consideration, decision, and action stages, totaling approximately ${totalPosts} posts.`;

        setLoaderContent({
            title: "Generating Funnel Campaign...",
            steps: [
                "Analyzing campaign goals...",
                "Structuring funnel stages (Awareness, Consideration, Decision)...",
                "Generating content for each stage...",
                "Finalizing campaign plan..."
            ]
        });
        setError(null);

        try {
            const generationTask = (model: string) => {
                return textGenerationService.generateMediaPlanGroup(
                    generatedAssets.brandFoundation,
                    prompt,
                    settings.language,
                    totalPosts,
                    true, // useSearch
                    ['Facebook', 'Instagram', 'TikTok', 'YouTube'], // Default platforms for funnel
                    { tone: 'persuasive', style: 'storytelling', length: 'medium', includeEmojis: true }, // Default options
                    settings.affiliateContentKit,
                    model,
                    persona,
                    selectedProduct
                );
            };
            const newGeneratedPlan = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);

            const finalPlan: MediaPlanGroup = {
                ...planShell,
                prompt: prompt,
                plan: newGeneratedPlan.plan,
                name: newGeneratedPlan.name || planShell.name, 
            };
            delete (finalPlan as any).wizardData;

            // Add the new plan to the assets
            dispatchAssets({ type: 'ADD_MEDIA_PLAN', payload: finalPlan });
            
            // Update the media plan groups list
            setMediaPlanGroupsList(prev => [...prev, { 
                id: finalPlan.id, 
                name: finalPlan.name, 
                prompt: finalPlan.prompt, 
                productImages: finalPlan.productImages,
                source: finalPlan.source
            }]);
            
            // Set the new plan as the active plan
            setActivePlanId(finalPlan.id);
            
            // Save to Airtable if connected
            updateAutoSaveStatus('saving');
            const brandId = await ensureAirtableProject();
            if (brandId) {
                const newPublicUrls = await uploadMediaToCloudinary(generatedImages);
                const allImageUrls = { ...generatedImages, ...newPublicUrls };
                
                await saveMediaPlanGroup(finalPlan, allImageUrls, brandId);
                setGeneratedImages(allImageUrls);
                updateAutoSaveStatus('saved');
            } else {
                updateAutoSaveStatus('idle');
            }
            
            setSuccessMessage(settings.language === 'Việt Nam' 
                ? "Chiến dịch funnel đã được tạo thành công!" 
                : "Funnel campaign created successfully!");
            setTimeout(() => setSuccessMessage(null), 3000);
            
        } catch (err) {
            console.error("Failed to create funnel campaign plan:", err);
            setError(err instanceof Error ? err.message : "Failed to create funnel campaign plan.");
            updateAutoSaveStatus('error');
        } finally {
            setLoaderContent(null);
        }
    }, [generatedAssets, settings, ensureAirtableProject, generatedImages, updateAutoSaveStatus, executeTextGenerationWithFallback]);

    const handleBackToIdea = useCallback(() => {
        setCurrentStep('idea');
        setActiveTab('brandKit');
        setBrandInfo(null);
        dispatchAssets({ type: 'INITIALIZE_ASSETS', payload: null! });
        setGeneratedImages({});
        setAirtableBrandId(null);
        setMediaPlanGroupsList([]);
        setActivePlanId(null);
        setError(null);
        setSuccessMessage(null);
    }, []);

    const handleSetImage = useCallback(async (dataUrl: string, imageKey: string, postInfo?: PostInfo) => {
        const randomSuffix = Math.random().toString(36).substring(2, 10);
        let baseKey = imageKey;
        
        if (postInfo) {
            baseKey = `media_plan_post_${postInfo.post.id}`;
        } else {
            const keyParts = imageKey.split('_');
            if (keyParts.length >= 2) {
                baseKey = `${keyParts[0]}_${keyParts[1]}`;
            }
        }
        const newImageKey = `${baseKey}_${randomSuffix}`;
        
        setGeneratedImages(prev => ({ ...prev, [newImageKey]: dataUrl }));

        const action: AssetsAction = { type: 'UPDATE_ASSET_IMAGE', payload: { oldImageKey: imageKey, newImageKey, postInfo } };
        dispatchAssets(action);
        
        if (airtableBrandId && generatedAssets) {
            updateAutoSaveStatus('saving');
            try {

                const publicUrls = await uploadMediaToCloudinary({ [newImageKey]: dataUrl });
                const publicUrl = publicUrls[newImageKey];

                if (publicUrl) {
                    if (postInfo) {
                        const mediaOrder: ('image' | 'video')[] = postInfo.post.mediaOrder?.includes('image') ? postInfo.post.mediaOrder : [...(postInfo.post.mediaOrder || []), 'image'];
                        const updatedPost = { ...postInfo.post, imageKey: newImageKey, mediaOrder };
                        await updateMediaPlanPostInAirtable(updatedPost, airtableBrandId, publicUrl);
                    } else {
                        const updatedAssets = assetsReducer(generatedAssets, action);
                        if (updatedAssets) {
                            await syncAssetMedia(publicUrls, airtableBrandId, updatedAssets);
                        }
                    }
                    setGeneratedImages(prev => ({ ...prev, ...publicUrls }));
                    updateAutoSaveStatus('saved');
                } else {
                    throw new Error("Image upload to Cloudinary failed, public URL not received.");
                }
            } catch (e) {
                const message = e instanceof Error ? e.message : 'Could not save new image.';
                console.error("Explicit image save failed:", e);
                setError(message);
                updateAutoSaveStatus('error');
            }
        }
    }, [generatedAssets, airtableBrandId, updateAutoSaveStatus, setError]);

    const handleSetVideo = useCallback(async (dataUrl: string, key: string, postInfo: PostInfo) => {
        const randomSuffix = Math.random().toString(36).substring(2, 10);
        const newVideoKey = `media_plan_post_video_${postInfo.post.id}_${randomSuffix}`;
        
        setGeneratedVideos(prev => ({...prev, [newVideoKey]: dataUrl}));
        
        const mediaOrder: ('image' | 'video')[] = postInfo.post.mediaOrder?.includes('video') ? postInfo.post.mediaOrder : [...(postInfo.post.mediaOrder || []), 'video'];
        const updates: Partial<MediaPlanPost> = { videoKey: newVideoKey, mediaOrder };
        
        dispatchAssets({ type: 'UPDATE_POST', payload: { planId: postInfo.planId, weekIndex: postInfo.weekIndex, postIndex: postInfo.postIndex, updates } });

        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            try {
            

                const publicUrls = await uploadMediaToCloudinary({ [newVideoKey]: dataUrl });
                const publicUrl = publicUrls[newVideoKey];

                if (publicUrl) {
                    await updateMediaPlanPostInAirtable({ ...postInfo.post, ...updates }, airtableBrandId, undefined, publicUrl);
                    setGeneratedVideos(prev => ({ ...prev, ...publicUrls }));
                    updateAutoSaveStatus('saved');
                }
            } catch (e) {
                const message = e instanceof Error ? e.message : 'Could not save new video.';
                console.error("Video save failed:", e);
                setError(message);
                updateAutoSaveStatus('error');
            }
        }
    }, [airtableBrandId, updateAutoSaveStatus, setError]);

    const generateSingleImageCore = useCallback(async (mediaPrompt: string, settings: Settings, aspectRatio: "1:1" | "16:9" = "1:1", postInfo?: PostInfo): Promise<string> => {
        let imagesToUse: File[] = [];
        if (postInfo && 'planId' in postInfo && generatedAssets) {
            const planGroup = generatedAssets.mediaPlans.find(p => p.id === postInfo.planId);
            const serializedImages = planGroup?.productImages || [];
            if (isVisionModel(settings.imageGenerationModel) && serializedImages.length > 0) {
                imagesToUse = serializedImages.map(img => base64ToFile(img.data, img.name, img.type));
            }
        }
    
        const model = settings.imageGenerationModel;
        if (model.startsWith('@cf/')) {
            return generateImageWithCloudflare(mediaPrompt, model, imagesToUse);
        } else if (model.startsWith('imagen-')) {
            return generateImage(mediaPrompt, settings.mediaPromptSuffix, model, aspectRatio, imagesToUse);
        } else {
            return generateImageWithOpenRouter(mediaPrompt, settings.mediaPromptSuffix, model, aspectRatio, imagesToUse);
        }
    }, [generatedAssets]);

    const handleGenerateImage = useCallback(async (mediaPrompt: string, imageKey: string, aspectRatio: "1:1" | "16:9" = "1:1", postInfo?: PostInfo) => {
        setGeneratingImageKeys(prev => new Set(prev).add(imageKey));
        setError(null);
    
        try {
            if (!settings) {
                setError("Application settings not loaded.");
                return;
            }
            const dataUrl = await generateSingleImageCore(mediaPrompt, settings, aspectRatio, postInfo);
            
            const randomSuffix = Math.random().toString(36).substring(2, 10);
            let baseKey = imageKey;
            
            if (postInfo) {
                baseKey = `media_plan_post_${postInfo.post.id}`;
            } else {
                const keyParts = imageKey.split('_');
                if (keyParts.length >= 2) {
                    baseKey = `${keyParts[0]}_${keyParts[1]}`;
                }
            }
            const newImageKey = `${baseKey}_${randomSuffix}`;

            setGeneratedImages(prev => ({ ...prev, [newImageKey]: dataUrl }));
            const action: AssetsAction = { type: 'UPDATE_ASSET_IMAGE', payload: { oldImageKey: imageKey, newImageKey, postInfo } };
            dispatchAssets(action);
    
            if (airtableBrandId && dataUrl.startsWith('data:image') && generatedAssets) {
                updateAutoSaveStatus('saving');
                try {
                    // With BFF, we no longer need to check credentials on the frontend
                    // All credential management is handled by the BFF
                    
                    const publicUrls = await uploadMediaToCloudinary({ [newImageKey]: dataUrl });
                    // Even if Cloudinary upload is skipped (due to missing env vars), we should still save the image locally
                    const publicUrl = publicUrls[newImageKey];

                    if (postInfo) {
                        const mediaOrder: ('image' | 'video')[] = postInfo.post.mediaOrder?.includes('image') ? postInfo.post.mediaOrder : [...(postInfo.post.mediaOrder || []), 'image'];
                        const updatedPost = { ...postInfo.post, imageKey: newImageKey, mediaOrder };
                        await updateMediaPlanPostInAirtable(updatedPost, airtableBrandId, publicUrl);
                    } else {
                        const updatedAssets = assetsReducer(generatedAssets, action);
                        if (updatedAssets) {
                            await syncAssetMedia(publicUrls, airtableBrandId, updatedAssets);
                        }
                    }
                    setGeneratedImages(prev => ({ ...prev, ...publicUrls }));
                    updateAutoSaveStatus('saved');
                } catch (e) {
                    const message = e instanceof Error ? e.message : 'Could not save new image.';
                    console.error("Explicit image save failed:", e);
                    setError(message);
                    updateAutoSaveStatus('error');
                }
            }
        } catch (err) {
            console.error(`Failed to generate image for key ${imageKey}:`, err);
            setError(err instanceof Error ? err.message : "Failed to generate image.");
        } finally {
            setGeneratingImageKeys(prev => {
                const newSet = new Set(prev);
                newSet.delete(imageKey);
                return newSet;
            });
        }
    }, [settings, airtableBrandId, generatedAssets, updateAutoSaveStatus, generateSingleImageCore]);
    
    const handleGenerateMediaPrompt = useCallback(async (postInfo: PostInfo): Promise<MediaPlanPost | null> => {
        if (!('planId' in postInfo) || !generatedAssets?.brandFoundation) return null;

        const { planId, weekIndex, postIndex, post } = postInfo;
        const planGroup = generatedAssets.mediaPlans.find(p => p.id === planId);
        const persona = planGroup?.personaId ? (generatedAssets.personas || []).find(p => p.id === planGroup.personaId) ?? null : null;

        const postKey = `${planId}_${weekIndex}_${postIndex}`;
        setGeneratingPromptKeys(prev => new Set(prev).add(postKey));
        setError(null);
        
        try {
            const generationTask = (model: string) => {
                const commonArgs = [
                    { title: post.title, content: post.content, contentType: post.contentType },
                    generatedAssets.brandFoundation,
                    settings.language,
                    model,
                    persona,
                    settings.mediaPromptSuffix
                ] as const;

                return textGenerationService.generateMediaPromptForPost(...commonArgs);
            };
            const newPrompt = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            
            const updates = { mediaPrompt: newPrompt };
            dispatchAssets({ type: 'UPDATE_POST', payload: { planId, weekIndex, postIndex, updates } });
            
            const updatedPost = { ...post, ...updates };

            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                try {
                    await updateMediaPlanPostInAirtable(updatedPost, airtableBrandId);
                    updateAutoSaveStatus('saved');
                } catch (e) {
                    setError(e instanceof Error ? e.message : 'Could not save new prompt.');
                    updateAutoSaveStatus('error');
                }
            }
            return updatedPost;
        } catch (err) {
            console.error("Failed to generate media prompt:", err);
            setError(err instanceof Error ? err.message : "Failed to generate prompt.");
        } finally {
            setGeneratingPromptKeys(prev => {
                const newSet = new Set(prev);
                newSet.delete(postKey);
                return newSet;
            });
        }
        return null;
    }, [generatedAssets, settings, airtableBrandId, updateAutoSaveStatus, executeTextGenerationWithFallback]);

    const handleRefinePost = useCallback(async (text: string): Promise<string> => {
        const generationTask = (model: string) => {
            return textGenerationService.refinePostContent(text, model);
        };
        try {
            const refinedText = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            return refinedText;
        } catch (err) {
            console.error("Failed to refine post content:", err);
            setError(err instanceof Error ? err.message : "Failed to refine post content.");
            return text; // Return original text on failure
        }
    }, [settings.textGenerationModel, executeTextGenerationWithFallback]);

    const handleUpdatePost = useCallback((postInfo: PostInfo) => {
        const { planId, weekIndex, postIndex, post } = postInfo;
        dispatchAssets({ type: 'UPDATE_POST', payload: { planId, weekIndex, postIndex, updates: post } });

        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            updateMediaPlanPostInAirtable(postInfo.post, airtableBrandId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => {
                    setError(e.message);
                    updateAutoSaveStatus('error');
                });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleGenerateAffiliateComment = useCallback(async (postInfo: PostInfo): Promise<MediaPlanPost | null> => {
        if (!generatedAssets?.brandFoundation || !('planId' in postInfo)) return null;

        const { planId, weekIndex, postIndex, post } = postInfo;
        
        const productIds = post.promotedProductIds || [];
        const products = (generatedAssets.affiliateLinks || []).filter(link => productIds.includes(link.id));

        if (products.length === 0) {
            setError("No promoted products found to generate a comment.");
            return null;
        }

        setGeneratingCommentPostIds(prev => new Set(prev).add(post.id));
        setError(null);
        try {
            const generationTask = (model: string) => {
                const commonArgs = [
                    post,
                    products,
                    generatedAssets.brandFoundation,
                    settings.language,
                    model,
                ] as const;

                return textGenerationService.generateAffiliateComment(...commonArgs);
            };

            const newComment = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            const updates = { autoComment: newComment };
            dispatchAssets({ type: 'UPDATE_POST', payload: { planId, weekIndex, postIndex, updates } });

            const updatedPost = { ...post, ...updates };
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                try {
                    await updateMediaPlanPostInAirtable(updatedPost, airtableBrandId);
                    updateAutoSaveStatus('saved');
                } catch (e) {
                    setError(e instanceof Error ? e.message : 'Could not save new comment.');
                    updateAutoSaveStatus('error');
                }
            }
            return updatedPost;
        } catch (err) {
            console.error("Failed to generate affiliate comment:", err);
            setError(err instanceof Error ? err.message : "Failed to generate comment.");
        } finally {
            setGeneratingCommentPostIds(prev => {
                const newSet = new Set(prev);
                newSet.delete(post.id);
                return newSet;
            });
        }
        return null;
    }, [generatedAssets, settings, airtableBrandId, updateAutoSaveStatus, executeTextGenerationWithFallback]);

    // Trend & Idea Hub Handlers
    const handleSaveTrend = useCallback((trend: Trend) => {
        const payload = { ...trend, brandId: airtableBrandId || '' };
        dispatchAssets({ type: 'SAVE_TREND', payload });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            saveTrend(payload, airtableBrandId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleDeleteTrend = useCallback((trendId: string) => {
        dispatchAssets({ type: 'DELETE_TREND', payload: trendId });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            deleteTrendFromAirtable(trendId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleGenerateIdeas = useCallback(async (trend: Trend, useSearch: boolean) => {
        setLoaderContent({ title: "Generating Viral Ideas...", steps: ["Analyzing trend...", "Brainstorming concepts...", "Finalizing ideas..."] });
        try {
            const generationTask = (model: string) => {
                return textGenerationService.generateViralIdeas(trend, settings.language, useSearch, model);
            };
            const newIdeaData = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            const newIdeas: Idea[] = newIdeaData.map(idea => ({
                ...idea,
                id: crypto.randomUUID(),
                trendId: trend.id,
            }));
            
            dispatchAssets({ type: 'ADD_IDEAS', payload: newIdeas });
            
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                saveIdeas(newIdeas)
                    .then(() => updateAutoSaveStatus('saved'))
                    .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
            }
        } catch (err) {
            console.error("Failed to generate ideas:", err);
            setError(err instanceof Error ? err.message : "Failed to generate ideas.");
        } finally {
            setLoaderContent(null);
        }
    }, [settings, airtableBrandId, updateAutoSaveStatus, executeTextGenerationWithFallback]);
    
    const handleGenerateContentPackage = useCallback(async (
        idea: Idea,
        personaId: string | null,
        selectedProductId: string | null,
        options: { tone: string; style: string; length: string; includeEmojis: boolean; }
    ) => {
        if (!generatedAssets?.brandFoundation) return;

        const pillarPlatform = 'YouTube'; // Hardcoded
        
        // Debug logging
        console.log('Content package generation - input:', {
            idea,
            selectedProductId,
            generatedAssets
        });
        
        let selectedProduct = null;
        if (selectedProductId && generatedAssets.affiliateLinks) {
            selectedProduct = generatedAssets.affiliateLinks.find(link => link.id === selectedProductId) ?? null;
        } else if (idea.productId && generatedAssets.affiliateLinks) {
            // If no selectedProductId was passed, try to use the one from the idea
            selectedProduct = generatedAssets.affiliateLinks.find(link => link.id === idea.productId) ?? null;
        }
        
        // Validate selectedProduct
        if (selectedProduct && !selectedProduct.id) {
            console.warn('Selected product has no ID, setting to null:', selectedProduct);
            selectedProduct = null;
        }
        
        console.log('Content package generation - selectedProduct:', selectedProduct);

        // If a product was selected, verify it exists in Airtable
        if (selectedProduct && airtableBrandId) {
            const productExists = await checkIfProductExistsInAirtable(selectedProduct.id);
            if (!productExists) {
                console.warn(`Selected product ${selectedProduct.id} not found in Airtable. Saving it now.`);
                // Save the product to Airtable
                await saveAffiliateLinks([selectedProduct], airtableBrandId);
            }
        }

        setLoaderContent({ 
            title: settings.language === 'Việt Nam' ? "Đang tạo Gói Nội Dung..." : "Generating Content Package...",
            steps: [
                settings.language === 'Việt Nam' ? "Soạn nội dung trụ cột..." : "Crafting pillar content...",
                settings.language === 'Việt Nam' ? "Tạo các gợi ý hình ảnh..." : "Generating image prompts...",
                settings.language === 'Việt Nam' ? "Hoàn thiện gói nội dung..." : "Finalizing content package..."
            ]
        });

        try {
            const newPackage = await textGenerationService.generateContentPackage(
                idea,
                generatedAssets.brandFoundation,
                settings.language,
                settings.affiliateContentKit,
                settings.textGenerationModel,
                personaId ? (generatedAssets.personas || []).find(p => p.id === personaId) ?? null : null,
                pillarPlatform,
                options,
                selectedProduct
            );

            dispatchAssets({ type: 'ADD_CONTENT_PACKAGE', payload: newPackage });
            setMediaPlanGroupsList(prev => [...prev, { id: newPackage.id, name: newPackage.name, prompt: newPackage.prompt, source: newPackage.source, personaId: newPackage.personaId }]);
            setActivePlanId(newPackage.id);
            setActiveTab('mediaPlan');

            // Save to Airtable if we have a brand ID
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                
                // Extract image URLs from posts for saving
                const allImageUrls: Record<string, string> = {};
                newPackage.plan.forEach(week => {
                    week.posts.forEach(post => {
                        if (post.imageKey && generatedImages[post.imageKey]) {
                            allImageUrls[post.imageKey] = generatedImages[post.imageKey];
                        }
                    });
                });

                await saveMediaPlanGroup(newPackage, allImageUrls, airtableBrandId);
                updateAutoSaveStatus('saved');
                
                // Show success message
                setSuccessMessage(settings.language === 'Việt Nam' ? "Gói nội dung đã được lưu thành công!" : "Content package saved successfully!");
                setTimeout(() => setSuccessMessage(null), 4000);
            }

        } catch (err) {
            console.error("Failed to generate content package:", err);
            setError(err instanceof Error ? err.message : "Failed to generate content package.");
            
            // Update auto-save status to error if we were saving
            if (airtableBrandId) {
                updateAutoSaveStatus('error');
            }
        } finally {
            setLoaderContent(null);
        }
    }, [generatedAssets, settings, dispatchAssets, setError, setLoaderContent, setActivePlanId, setActiveTab, setMediaPlanGroupsList, airtableBrandId, generatedImages, updateAutoSaveStatus, saveMediaPlanGroup]);

    const handleGenerateFacebookTrends = useCallback(async (industry: string) => {
        if (!airtableBrandId) {
            setError("Please save your project to Airtable before generating trends.");
            return;
        }
        setIsGeneratingFacebookTrends(true);
        setError(null);
        try {
            const generationTask = (model: string) => {
                return textGenerationService.generateFacebookTrends(industry, settings.language, model);
            };
            const newTrendsData = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);

            const newTrends: Trend[] = newTrendsData.map(trend => ({
                ...trend,
                id: crypto.randomUUID(),
                brandId: airtableBrandId,
            }));

            for (const trend of newTrends) {
                dispatchAssets({ type: 'SAVE_TREND', payload: trend });
            }
            
            // Save all new trends to Airtable in one batch
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                Promise.all(newTrends.map(trend => saveTrend(trend, airtableBrandId)))
                    .then(() => {
                        updateAutoSaveStatus('saved');
                        setSuccessMessage(`Successfully found and saved ${newTrends.length} new trends.`);
                        setTimeout(() => setSuccessMessage(null), 4000);
                    })
                    .catch(e => {
                        setError(e.message);
                        updateAutoSaveStatus('error');
                    });
            }

        } catch (err) {
            console.error("Failed to generate Facebook trends:", err);
            setError(err instanceof Error ? err.message : "Failed to generate Facebook trends.");
        } finally {
            setIsGeneratingFacebookTrends(false);
        }
    }, [settings, airtableBrandId, updateAutoSaveStatus, executeTextGenerationWithFallback]);

    // New function for generating ideas from a product
    const handleGenerateIdeasFromProduct = useCallback(async (product: AffiliateLink) => {
        setLoaderContent({ title: "Generating Content Ideas...", steps: ["Analyzing product...", "Brainstorming concepts...", "Finalizing ideas..."] });
        console.log("User configured model:", settings.textGenerationModel);
        
        if ((settings.textGenerationModel).startsWith('gemini-') && !(settings.textGenerationModel).includes('free')) {
            // Check BFF health instead of directly accessing environment variables
            try {
                const { checkBffHealth } = await import('./services/bffService');
                const health = await checkBffHealth();
                if (!health.services.gemini) {
                    setError("Gemini API key is not configured on the BFF. Please check your server .env file and restart the BFF server.");
                    setLoaderContent(null);
                    return;
                }
            } catch (error) {
                setError("Failed to check BFF health. Please ensure the BFF server is running.");
                setLoaderContent(null);
                return;
            }
        }
        
        try {
            const generationTask = (model: string) => {
                console.log("Attempting to generate ideas with model:", model);
                return textGenerationService.generateIdeasFromProduct(product, settings.language, model);
            };
            const newIdeaData = await executeTextGenerationWithFallback(generationTask, settings.textGenerationModel);
            
            if (!Array.isArray(newIdeaData) || newIdeaData.length === 0) {
                throw new Error("Failed to generate ideas: No valid ideas returned from AI service.");
            }
            
            for (let i = 0; i < newIdeaData.length; i++) {
                const idea = newIdeaData[i];
                if (!idea.title || !idea.description || !idea.targetAudience) {
                    console.error("Invalid idea structure:", idea);
                    throw new Error(`Idea ${i + 1} is missing required fields. Please try again.`);
                }
            }
            
            const newIdeas: Idea[] = newIdeaData.map(idea => ({
                ...idea,
                id: crypto.randomUUID(),
                trendId: 'product-' + product.id, 
                productId: product.id, 
            }));
            
            dispatchAssets({ type: 'ADD_IDEAS', payload: newIdeas });
            
            const productTrendId = 'product-' + product.id;
            const existingTrends = generatedAssets?.trends || [];
            const productTrendExists = existingTrends.some(trend => trend.id === productTrendId);
            
            let productTrend: Trend;
            if (!productTrendExists) {
                productTrend = {
                    id: productTrendId,
                    brandId: airtableBrandId || '',
                    industry: 'Product Ideas',
                    topic: `Ideas for: ${product.productName}`,
                    keywords: [product.productName, product.providerName],
                    links: [{ title: 'Product Link', url: product.productLink }],
                    notes: `Generated ideas for affiliate product: ${product.productName}`,
                    analysis: `Affiliate product ideas for ${product.productName}`,
                    createdAt: new Date().toISOString(),
                };
                dispatchAssets({ type: 'SAVE_TREND', payload: productTrend });
                
                if (airtableBrandId) {
                    updateAutoSaveStatus('saving');
                    try {
                        await saveTrend(productTrend, airtableBrandId);
                        updateAutoSaveStatus('saved');
                    } catch (e) {
                        console.error("Failed to save trend to Airtable:", e);
                        setError(e instanceof Error ? e.message : "Failed to save trend to Airtable.");
                        updateAutoSaveStatus('error');
                    }
                }
            } else {
                productTrend = existingTrends.find(trend => trend.id === productTrendId)!;
            }
            
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                try {
                    await saveIdeas(newIdeas);
                    updateAutoSaveStatus('saved');
                } catch (e) {
                    console.error("Failed to save ideas to Airtable:", e);
                    setError(e instanceof Error ? e.message : "Failed to save ideas to Airtable.");
                    updateAutoSaveStatus('error');
                }
            }
            
            setSuccessMessage(`Generated ${newIdeas.length} ideas from ${product.productName}`);
            setTimeout(() => setSuccessMessage(null), 3000);
            
            setActiveTab('strategy');
            setProductTrendToSelect(productTrendId);
        } catch (err) {
            console.error("Failed to generate ideas from product:", err);
            let errorMessage = "Failed to generate ideas from product. Please check your API keys and try again.";
            if (err instanceof Error) {
                if (err.message.includes('rate limit')) {
                    errorMessage = "All models are currently rate limited. Please try again later or configure a different model in Settings.";
                } else if (err.message.includes('API Key')) {
                    errorMessage = "Please configure your API keys in the Integrations panel.";
                } else {
                    errorMessage = err.message;
                }
            }
            setError(errorMessage);
            setLoaderContent(null);
        } finally {
            setLoaderContent(null);
        }
    }, [settings, airtableBrandId, updateAutoSaveStatus, executeTextGenerationWithFallback, generatedAssets, setActiveTab]);

    const handleSaveProjectToFile = useCallback(() => {
        if (!generatedAssets) {
            setError("No assets to save.");
            return;
        }

        setIsSaving(true);
        setError(null);
        try {
            const projectData = {
                version: '2.0',
                createdAt: new Date().toISOString(),
                assets: generatedAssets,
                settings: settings,
                generatedImages: generatedImages,
                generatedVideos: generatedVideos,
                airtableBrandId: airtableBrandId,
            };

            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
            const fileName = `${generatedAssets.brandFoundation.brandName.replace(/\s+/g, '_') || 'SocialSync_Project'}.ssproj`;
            saveAs(blob, fileName);
            setSuccessMessage("Project saved successfully!");
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (err) {
            console.error("Failed to save project:", err);
            setError(err instanceof Error ? err.message : "Could not save project to file.");
        } finally {
            setIsSaving(false);
        }
    }, [generatedAssets, settings, generatedImages, generatedVideos, airtableBrandId]);

    const handleLoadProjectFile = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setLoaderContent({ title: "Loading Project...", steps: ["Reading file...", "Parsing data...", "Initializing assets..."] });
        setError(null);

        try {
            const text = await file.text();
            const projectData = JSON.parse(text);

            if (!projectData.assets || !projectData.settings) {
                throw new Error("Invalid project file format. Missing 'assets' or 'settings' key.");
            }
            
            dispatchAssets({ type: 'INITIALIZE_ASSETS', payload: projectData.assets });
            setSettings(projectData.settings);
            setGeneratedImages(projectData.generatedImages || {});
            setGeneratedVideos(projectData.generatedVideos || {});
            setAirtableBrandId(projectData.airtableBrandId || null);
            
            if (projectData.assets.personas) {
                projectData.assets.personas = projectData.assets.personas.map((p: Persona) => ({
                    ...p,
                    socialAccounts: getPersonaSocialAccounts(p.id),
                }));
            }

            const firstPlan = projectData.assets.mediaPlans?.[0];
            if (firstPlan) {
                setMediaPlanGroupsList(projectData.assets.mediaPlans.map((p: MediaPlanGroup) => ({ id: p.id, name: p.name, prompt: p.prompt, productImages: p.productImages || [] })));
                setActivePlanId(firstPlan.id);
                await handleSelectPlan(firstPlan.id, projectData.assets); // Call handleSelectPlan to load full plan data
                console.log("Loaded project with first plan:", firstPlan.id);
            } else {
                setMediaPlanGroupsList([]);
                setActivePlanId(null);
            }
            const bf = projectData.assets.brandFoundation;
            setBrandInfo({ name: bf.brandName, mission: bf.mission, values: (bf.values || []).join(', '), audience: bf.targetAudience, personality: bf.personality });
            setCurrentStep('assets');
            setActiveTab(firstPlan ? 'mediaPlan' : 'brandKit');

        } catch (err) {
            console.error("Failed to load project file:", err);
            setError(err instanceof Error ? err.message : "Could not read or parse project file.");
        } finally {
            setLoaderContent(null);
            if (event.target) {
                event.target.value = '';
            }
        }
    }, []);

    const handleSelectPlan = useCallback(async (planId: string, assetsToUse?: GeneratedAssets, plansList?: {id: string, name: string, prompt: string, productImages?: { name: string, type: string, data: string }[]}[]) => {
        // Use provided assets or fall back to current generatedAssets
        const currentAssets = assetsToUse || generatedAssets;
        if (!currentAssets?.brandFoundation) {
            setError("Cannot load plan without brand foundation.");
            return;
        }
        
        // Check if the plan is already loaded
        const existingPlan = currentAssets.mediaPlans?.find((p: MediaPlanGroup) => p.id === planId);
        if (existingPlan && existingPlan.plan) {
            // Plan is already loaded, just set it as active
            setActivePlanId(planId);
            return;
        }
        
        // Plan is not loaded yet, show loading indicator and fetch it with pagination
        setLoaderContent({ title: `Loading Plan...`, steps: ["Fetching plan details...", "Loading posts with pagination..."] });
        setError(null);
        try {
            // Load the first page of posts
            const { plan, imageUrls, videoUrls } = await loadMediaPlan(planId, currentAssets.brandFoundation, settings.language);
            if (!currentAssets) {
                throw new Error("Assets are not initialized.");
            }
            
            // Always update the plan with the loaded data
            // Check if the plan already exists in the assets
            const existingPlanIndex = currentAssets.mediaPlans.findIndex((p: MediaPlanGroup) => p.id === planId);

            // console.log(`Handling plan ID selection for ${planId}`);
            // console.log("Current plan:", plan);
            
            if (existingPlanIndex !== -1) {
                // If plan exists, update it with the loaded data
                dispatchAssets({ type: 'UPDATE_PLAN', payload: { planId, plan } });
            } else {
                // If plan doesn't exist, create it with the loaded data
                // Try to find plan metadata in plansList or mediaPlanGroupsList
                const planMetadata = (plansList || mediaPlanGroupsList).find(p => p.id === planId);
                let newPlanGroup: MediaPlanGroup;
                
                if (planMetadata) {
                    newPlanGroup = {
                        ...planMetadata,
                        plan: plan,
                    };
                } else {
                    console.warn(`Could not find metadata for planId ${planId} in plans list.`);
                    newPlanGroup = {
                        id: planId,
                        name: 'Loaded Plan',
                        prompt: 'Loaded on demand',
                        plan: plan,
                    };
                }
                
                dispatchAssets({ type: 'ADD_MEDIA_PLAN', payload: newPlanGroup });
            }
            
            setGeneratedImages(prev => ({...prev, ...imageUrls}));
            setGeneratedVideos(prev => ({...prev, ...videoUrls}));
            setActivePlanId(planId);
        } catch(err) {
            console.error(`Failed to load media plan ${planId}:`, err);
            setError(err instanceof Error ? err.message : "Could not load plan details.");
        } finally {
            setLoaderContent(null);
        }
    }, [generatedAssets, settings.language, mediaPlanGroupsList]);

    const handleLoadFromAirtable = useCallback(async (brandId: string) => {
        setLoaderContent({ title: "Loading from Airtable...", steps: ["Connecting...", "Fetching project data...", "Loading assets..."] });
        setError(null);
        try {
            // Step 1: Load initial project data for fast rendering
            const { brandSummary, brandKitData } = await loadInitialData(brandId);
            
            // Create a minimal assets object with just the brand kit data
            const initialAssets: GeneratedAssets = {
                brandFoundation: brandKitData.brandFoundation,
                coreMediaAssets: brandKitData.coreMediaAssets,
                unifiedProfileAssets: brandKitData.unifiedProfileAssets,
                mediaPlans: [], // Will be loaded lazily
                affiliateLinks: [], // Will be loaded lazily
                personas: [], // Will be loaded lazily
                trends: [], // Will be loaded lazily
                ideas: [], // Will be loaded lazily
                facebookTrends: [], // Will be loaded lazily
                facebookPostIdeas: [], // Will be loaded lazily
            };
            
            dispatchAssets({ type: 'INITIALIZE_ASSETS', payload: initialAssets });
            setAirtableBrandId(brandId);
            setCurrentStep('assets');
            setActiveTab('brandKit'); // Redirect to brandKit tab for instant rendering

            // Step 2: Load media plan groups list in background
            const loadedPlansList = await loadMediaPlanGroups(brandId);
            setMediaPlanGroupsList(loadedPlansList);
            
            if (loadedPlansList.length > 0) {
                setActivePlanId(loadedPlansList[0].id);
                // We don't load the full plan data yet - that will happen lazily when the user navigates to the media plan tab
            } else {
                setActivePlanId(null);
            }
            
            setIsAirtableLoadModalOpen(false);

        } catch (err) {
            console.error("Failed to load project from Airtable:", err);
            setError(err instanceof Error ? err.message : "Could not load project from Airtable.");
        } finally {
            setLoaderContent(null);
        }
    }, []);

    const handleExportBrandKit = useCallback(async () => {
        if (!generatedAssets) {
            setError("No assets to export.");
            return;
        }
        setIsExporting(true);
        setError(null);
        try {
            const blob = await createDocxBlob(generatedAssets, settings.language);
            const fileName = `${generatedAssets.brandFoundation.brandName.replace(/\s+/g, '_') || 'Brand_Kit'}.docx`;
            saveAs(blob, fileName);
            setSuccessMessage("Brand Kit exported successfully!");
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (err) {
            console.error("Failed to export brand kit:", err);
            setError(err instanceof Error ? err.message : "Could not export brand kit.");
        } finally {
            setIsExporting(false);
        }
    }, [generatedAssets, settings.language]);

    const handleExportMediaPlan = useCallback(async () => {
        if (!generatedAssets || !generatedAssets.mediaPlans || generatedAssets.mediaPlans.length === 0) {
            setError("No media plan to export.");
            return;
        }
        setIsExporting(true);
        setError(null);
        try {
            const blob = await createMediaPlanXlsxBlob(generatedAssets.mediaPlans, settings.language);
            const fileName = `${generatedAssets.brandFoundation.brandName.replace(/\s+/g, '_') || 'SocialSync'}_MediaPlan.xlsx`;
            saveAs(blob, fileName);
            setSuccessMessage("Media Plan exported successfully!");
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (err) {
            console.error("Failed to export media plan:", err);
            setError(err instanceof Error ? err.message : "Could not export media plan.");
        } finally {
            setIsExporting(false);
        }
    }, [generatedAssets, settings.language]);

    const handleRegenerateWeekImages = useCallback(async (planId: string, weekIndex: number) => {
        if (!generatedAssets) return;
        const plan = generatedAssets.mediaPlans.find(p => p.id === planId);
        if (!plan) return;

        const week = plan.plan[weekIndex];
        if (!week || !week.posts) return;

        const postsToGenerate = week.posts
            .map((post, postIndex) => ({
                planId,
                weekIndex,
                postIndex,
                post
            }))
            .filter(pInfo => pInfo.post.mediaPrompt && !Array.isArray(pInfo.post.mediaPrompt));

        if (postsToGenerate.length === 0) {
            setSuccessMessage("No posts with image prompts found in this week.");
            setTimeout(() => setSuccessMessage(null), 3000);
            return;
        }

        setBulkActionStatus({
            title: "Regenerating Week Images...",
            steps: postsToGenerate.map(p => `Generating image for "${p.post.title}"`),
            currentStep: 0
        });

        for (let i = 0; i < postsToGenerate.length; i++) {
            const postInfo = postsToGenerate[i];
            setBulkActionStatus(prev => prev ? { ...prev, currentStep: i } : null);
            try {
                if (!settings) {
                    setError("Application settings not loaded.");
                    return;
                }
                await handleGenerateImage(postInfo.post.mediaPrompt as string, postInfo.post.imageKey || postInfo.post.id, '1:1', postInfo);
            } catch (error) {
                console.error(`Failed to regenerate image for post ${postInfo.post.id}`, error);
            }
        }

        setBulkActionStatus(null);
        setSuccessMessage("Finished regenerating week images.");
        setTimeout(() => setSuccessMessage(null), 3000);
    }, [generatedAssets, handleGenerateImage, settings]);

    const handleAssignPersonaToPlan = useCallback(async (planId: string, personaId: string | null) => {
        if (!generatedAssets) return;
        const planToUpdate = generatedAssets.mediaPlans.find(p => p.id === planId);
        if (!planToUpdate) return;
    
        dispatchAssets({ type: 'ASSIGN_PERSONA_TO_PLAN', payload: { planId, personaId } });
    
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            try {
                
                const updatedState = assetsReducer(generatedAssets, { type: 'ASSIGN_PERSONA_TO_PLAN', payload: { planId, personaId } });
                const updatedPlan = updatedState?.mediaPlans.find(p => p.id === planId);
                if (updatedPlan) {
                    const allPostsInPlan = updatedPlan.plan.flatMap(w => w.posts);
                    await assignPersonaToPlanInAirtable(planId, personaId, allPostsInPlan, airtableBrandId);
                }
                updateAutoSaveStatus('saved');
            } catch (e) {
                const message = e instanceof Error ? e.message : 'Could not assign persona.';
                console.error("Failed to assign persona in Airtable:", e);
                setError(message);
                updateAutoSaveStatus('error');
            }
        }
    }, [generatedAssets, airtableBrandId, updateAutoSaveStatus]);

    const handleLoadIdeasForTrend = useCallback(async (trendId: string) => {
        if (!airtableBrandId) {
            console.warn("DEBUG: No airtableBrandId, cannot load ideas for trend");
            return;
        }
        
        console.log("DEBUG: Loading ideas for trend ID:", trendId);
        try {
            const ideas = await loadIdeasForTrend(trendId, airtableBrandId);
            console.log("DEBUG: Loaded ideas:", ideas);
            dispatchAssets({ type: 'ADD_IDEAS', payload: ideas });
        } catch (error) {
            console.error("DEBUG: Failed to load ideas for trend:", error);
        }
    }, [airtableBrandId]);

    const handleSaveAffiliateLink = useCallback((link: AffiliateLink) => {
        dispatchAssets({ type: 'ADD_OR_UPDATE_AFFILIATE_LINK', payload: link });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            saveAffiliateLinks([link], airtableBrandId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => {
                    setError(e.message);
                    updateAutoSaveStatus('error');
                });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleDeleteAffiliateLink = useCallback((linkId: string) => {
        dispatchAssets({ type: 'DELETE_AFFILIATE_LINK', payload: linkId });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            deleteAffiliateLinkFromAirtable(linkId, airtableBrandId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => {
                    setError(e.message);
                    updateAutoSaveStatus('error');
                });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleImportAffiliateLinks = useCallback((links: AffiliateLink[]) => {
        dispatchAssets({ type: 'IMPORT_AFFILIATE_LINKS', payload: links });
        if (airtableBrandId && links.length > 0) {
            updateAutoSaveStatus('saving');
            saveAffiliateLinks(links, airtableBrandId)
                .then(() => {
                    updateAutoSaveStatus('saved');
                    setSuccessMessage(`${links.length} links imported successfully!`);
                    setTimeout(() => setSuccessMessage(null), 3000);
                })
                .catch(e => {
                    setError(e.message);
                    updateAutoSaveStatus('error');
                });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleReloadAffiliateLinks = useCallback(async () => {
        if (!airtableBrandId) {
            setError("Cannot reload affiliate links: No brand selected or Airtable not connected.");
            return;
        }
        setLoaderContent({ title: "Reloading Affiliate Links...", steps: ["Fetching latest data..."] });
        setError(null);
        try {
            const latestAffiliateLinks = await fetchAffiliateLinksForBrand(airtableBrandId);
            dispatchAssets({ type: 'INITIALIZE_ASSETS', payload: { ...generatedAssets!, affiliateLinks: latestAffiliateLinks } });
            setSuccessMessage("Affiliate links reloaded successfully!");
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (err) {
            console.error("Failed to reload affiliate links:", err);
            setError(err instanceof Error ? err.message : "Could not reload affiliate links.");
        } finally {
            setLoaderContent(null);
        }
    }, [airtableBrandId, generatedAssets, dispatchAssets]);

    const handleAcceptSuggestion = useCallback((postInfo: PostInfo, productId: string) => {
        const currentPromotedIds = postInfo.post.promotedProductIds || [];
        if (currentPromotedIds.includes(productId)) return;
        const updatedPost = {
            ...postInfo.post,
            promotedProductIds: [...currentPromotedIds, productId],
        };
        handleUpdatePost({ ...postInfo, post: updatedPost });
    }, [handleUpdatePost]);

    const handleRunKhongMinhForPost = useCallback(async (postInfo: PostInfo) => {
        if (!generatedAssets?.affiliateLinks || generatedAssets.affiliateLinks.length === 0) {
            setError("No affiliate links available to make suggestions.");
            return;
        }
        setAnalyzingPostIds(prev => new Set(prev).add(postInfo.post.id));
        try {
            const suggestions = await suggestProductsForPost(postInfo.post, generatedAssets.affiliateLinks, 2);
            setKhongMinhSuggestions(prev => ({ ...prev, [postInfo.post.id]: suggestions }));
        } catch (err) {
            console.error("KhongMinh suggestion failed:", err);
            setError(err instanceof Error ? err.message : "Could not get suggestions.");
        } finally {
            setAnalyzingPostIds(prev => {
                const newSet = new Set(prev);
                newSet.delete(postInfo.post.id);
                return newSet;
            });
        }
    }, [generatedAssets?.affiliateLinks]);

    const handleTogglePostSelection = useCallback((postId: string) => {
        setSelectedPostIds(prev => {
            const newSet = new Set(prev);
            if (newSet.has(postId)) {
                newSet.delete(postId);
            } else {
                newSet.add(postId);
            }
            return newSet;
        });
    }, []);

    const handleSelectAllPosts = useCallback((posts: PostInfo[]) => {
        setSelectedPostIds(new Set(posts.map(p => p.post.id)));
    }, []);

    const handleSchedulePost = useCallback(async (postInfo: SchedulingPost, scheduledAt: string) => {
        const { planId, weekIndex, postIndex, post } = postInfo;
        const updates = { scheduledAt, status: 'scheduled' as PostStatus };
        
        setIsScheduling(true);
        try {
            const currentPlan = generatedAssets?.mediaPlans.find(p => p.id === planId);
            const personaId = currentPlan?.personaId;
            if (!personaId) {
                throw new Error("No persona assigned to this media plan. Cannot schedule post.");
            }
            await socialApiSchedulePost(personaId, post.platform, post, scheduledAt);
            dispatchAssets({ type: 'UPDATE_POST', payload: { planId, weekIndex, postIndex, updates } });
            
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                await updateMediaPlanPostInAirtable({ ...post, ...updates }, airtableBrandId);
                updateAutoSaveStatus('saved');
            }
            setSchedulingPost(null);
        } catch (err) {
            console.error("Failed to schedule post:", err);
            setError(err instanceof Error ? err.message : "Failed to schedule post.");
        } finally {
            setIsScheduling(false);
        }
    }, [airtableBrandId, updateAutoSaveStatus, generatedAssets]);

    const handlePublishPost = useCallback(async (postInfo: PostInfo) => {
        const { planId, weekIndex, postIndex, post } = postInfo;
        
        setIsScheduling(true); 
        try {
            const currentPlan = generatedAssets?.mediaPlans.find(p => p.id === planId);
            const personaId = currentPlan?.personaId;
            if (!personaId) {
                throw new Error("No persona assigned to this media plan. Cannot publish post.");
            }

            const imageUrl = post.imageKey ? generatedImages[post.imageKey] : undefined;
            const videoUrl = post.videoKey ? generatedVideos[post.videoKey] : undefined;

            console.log("Calling directPost with:", { personaId, post, imageUrl, videoUrl });
            const { publishedUrl } = await directPost(personaId, post.platform, post, imageUrl, videoUrl);
            
            const updates = { 
                status: 'published' as PostStatus, 
                publishedUrl: publishedUrl,
                publishedAt: new Date().toISOString(),
                scheduledAt: undefined, 
            };

            dispatchAssets({ type: 'UPDATE_POST', payload: { planId, weekIndex, postIndex, updates } });
            
            if (airtableBrandId) {
                updateAutoSaveStatus('saving');
                await updateMediaPlanPostInAirtable({ ...post, ...updates }, airtableBrandId);
                updateAutoSaveStatus('saved');
            }
            setSuccessMessage(`Post published successfully! URL: ${publishedUrl}`);
            setTimeout(() => setSuccessMessage(null), 5000);
            setViewingPost(null);
        } catch (err) {
            console.error("Failed to publish post:", err);
            if (err instanceof SocialAccountNotConnectedError) {
                const persona = generatedAssets?.personas?.find(p => p.id === err.personaId);
                if (persona) {
                    setPersonaToConnect(persona);
                    setPlatformToConnect(err.platform);
                    setIsPersonaConnectModalOpen(true);
                    personaConnectSuccessCallback.current = () => {
                        handlePublishPost(postInfo);
                        setPersonaToConnect(null);
                        setPlatformToConnect(null);
                    };
                } else {
                    setError(`Failed to publish: ${err.message}`);
                }
            } else {
                setError(err instanceof Error ? err.message : "Failed to publish post.");
            }
        } finally {
            setIsScheduling(false);
        }
    }, [airtableBrandId, updateAutoSaveStatus, generatedAssets, generatedImages, generatedVideos, setViewingPost]);

    const handlePostDrop = useCallback((postInfo: SchedulingPost, newDate: Date) => {
        const originalDate = postInfo.post.scheduledAt ? new Date(postInfo.post.scheduledAt) : new Date(newDate.setHours(10, 0, 0, 0));
        newDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds());
        handleSchedulePost(postInfo, newDate.toISOString());
    }, [handleSchedulePost]);

    

    
            

    const handleBulkSchedule = useCallback(async (startDate: string, intervalDays: number, intervalHours: number, intervalMinutes: number) => {
        if (selectedPostIds.size === 0 || !generatedAssets) return;
    
        setIsScheduling(true);
        setIsBulkScheduleModalOpen(false);
    
        const allPosts: SchedulingPost[] = generatedAssets.mediaPlans.flatMap(plan =>
            plan.plan.flatMap((week, weekIndex) =>
                week.posts.map((post, postIndex) => ({
                    planId: plan.id,
                    weekIndex,
                    postIndex,
                    post
                }))
            )
        ).filter(p => selectedPostIds.has(p.post.id));
    
        const scheduleTime = new Date(startDate);
        const updatesForState: { planId: string, weekIndex: number, postIndex: number, updates: Partial<MediaPlanPost> }[] = [];
        const updatesForAirtable: { postId: string; scheduledAt: string; status: 'scheduled' }[] = [];
    
        for (const postInfo of allPosts) {
            const currentScheduledAt = scheduleTime.toISOString();
            updatesForState.push({ ...postInfo, updates: { scheduledAt: currentScheduledAt, status: 'scheduled' } });
            updatesForAirtable.push({ postId: postInfo.post.id, scheduledAt: currentScheduledAt, status: 'scheduled' });
            scheduleTime.setDate(scheduleTime.getDate() + intervalDays);
            scheduleTime.setHours(scheduleTime.getHours() + intervalHours);
            scheduleTime.setMinutes(scheduleTime.getMinutes() + intervalMinutes);
        }
    
        updatesForState.forEach(u => dispatchAssets({ type: 'UPDATE_POST', payload: u }));
        
        dispatchAssets({ type: 'BULK_SCHEDULE_POSTS', payload: { updates: updatesForAirtable } });
    
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            try {
                await bulkUpdatePostSchedules(updatesForAirtable);
                updateAutoSaveStatus('saved');
            } catch (e) {
                setError(e instanceof Error ? e.message : 'Could not bulk schedule.');
                updateAutoSaveStatus('error');
            }
        }
    
        setSelectedPostIds(new Set());
        setIsScheduling(false);
    }, [generatedAssets, selectedPostIds, airtableBrandId, updateAutoSaveStatus]);

    const createBulkActionHandler = (
        title: string,
        stepGenerator: (post: MediaPlanPost) => string,
        action: (postInfo: PostInfo) => Promise<any>
    ) => async (posts: PostInfo[]) => {
        if (posts.length === 0) return;
    
        setBulkActionStatus({
            title,
            steps: posts.map(p => stepGenerator(p.post)),
            currentStep: 0,
        });
    
        for (let i = 0; i < posts.length; i++) {
            setBulkActionStatus(prev => prev ? { ...prev, currentStep: i } : null);
            try {
                await action(posts[i]);
            } catch (err) {
                console.error(`Error in bulk action for post ${posts[i].post.id}:`, err);
            }
        }
    
        setBulkActionStatus(null);
        setSelectedPostIds(new Set()); // Clear selection after action
    };

    const handleBulkGenerateImages = createBulkActionHandler(
        "Bulk Generating Images...",
        (post) => `Generating image for "${post.title}"`,
        (postInfo) => handleGenerateImage(postInfo.post.mediaPrompt!, postInfo.post.imageKey || postInfo.post.id, '1:1', postInfo)
    );

    const handleBulkSuggestPromotions = createBulkActionHandler(
        "Bulk Suggesting Promotions...",
        (post) => `Analyzing "${post.title}" for products`,
        handleRunKhongMinhForPost
    );

    const handleBulkGenerateComments = createBulkActionHandler(
        "Bulk Generating Comments...",
        (post) => `Generating comment for "${post.title}"`,
        handleGenerateAffiliateComment
    );
    
    const handleSavePersona = useCallback(async (persona: Persona) => {
        let personaToSave = { ...persona };
        
        updateAutoSaveStatus('saving');
        try {
            if (personaToSave.avatarImageUrl && personaToSave.avatarImageUrl.startsWith('data:') && personaToSave.avatarImageKey) {
                
                const publicUrls = await uploadMediaToCloudinary({ [personaToSave.avatarImageKey]: personaToSave.avatarImageUrl });
                const publicUrl = publicUrls[personaToSave.avatarImageKey];
                if (publicUrl) {
                    personaToSave.avatarImageUrl = publicUrl;
                    setGeneratedImages(prev => ({ ...prev, [personaToSave.avatarImageKey!]: publicUrl }));
                
                }
            }
            
            dispatchAssets({ type: 'SAVE_PERSONA', payload: personaToSave });
            
            if (airtableBrandId) {
                await savePersona(personaToSave, airtableBrandId);
            }
            updateAutoSaveStatus('saved');
        } catch(e: any) {
            setError(e.message);
            updateAutoSaveStatus('error');
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleUpdatePersona = useCallback(async (persona: Persona) => {
        dispatchAssets({ type: 'SAVE_PERSONA', payload: persona });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            try {
                await savePersona(persona, airtableBrandId);
                updateAutoSaveStatus('saved');
            } catch (e) {
                setError(e instanceof Error ? e.message : 'Could not update persona.');
                updateAutoSaveStatus('error');
            }
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleDeletePersona = useCallback((personaId: string) => {
        dispatchAssets({ type: 'DELETE_PERSONA', payload: personaId });
        if (airtableBrandId) {
            updateAutoSaveStatus('saving');
            deletePersonaFromAirtable(personaId, airtableBrandId)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
        }
    }, [airtableBrandId, updateAutoSaveStatus]);

    const handleSetPersonaImage = useCallback(async (personaId: string, photoId: string, dataUrl: string): Promise<string | undefined> => {
        const randomSuffix = Math.random().toString(36).substring(2, 10);
        const newImageKey = `persona_${personaId}_photo_${photoId}_${randomSuffix}`;
    
        setGeneratedImages(prev => ({ ...prev, [newImageKey]: dataUrl }));
        
        return newImageKey;
    }, []);

    

    const handleClosePersonaConnectModal = useCallback(() => {
        setIsPersonaConnectModalOpen(false);
        if (onModalCloseRef.current) {
            onModalCloseRef.current();
            onModalCloseRef.current = null;
        }
    }, []);

    const handleSocialAccountConnected = useCallback((updatedPersona: Persona) => {
        dispatchAssets({ type: 'SAVE_PERSONA', payload: updatedPersona });
        if (personaConnectSuccessCallback.current) {
            personaConnectSuccessCallback.current();
            personaConnectSuccessCallback.current = null;
        }
    }, [dispatchAssets]);
    
    // --- NEW FACEBOOK STRATEGY HANDLERS ---

    const handleGenerateFacebookPostIdeas = useCallback(async (trend: FacebookTrend) => {
        setIsGeneratingFacebookPostIdeas(true);
        setError(null);
        try {
            const newIdeaData = await textGenerationService.generatePostsForFacebookTrend(trend, settings.language, settings.textGenerationModel);
            const newIdeas: FacebookPostIdea[] = newIdeaData.map(i => ({ ...i, id: crypto.randomUUID(), trendId: trend.id }));
            dispatchAssets({ type: 'ADD_FACEBOOK_POST_IDEAS', payload: newIdeas });
        } catch (err) {
             console.error("Failed to generate Facebook post ideas:", err);
            setError(err instanceof Error ? err.message : "Failed to generate post ideas.");
        } finally {
            setIsGeneratingFacebookPostIdeas(false);
        }
    }, [settings]);

    const handleAddFacebookPostIdeaToPlan = useCallback((idea: FacebookPostIdea) => {
        // This is a placeholder for a more complex feature. For now, it creates a new plan with this single post idea.
        const newPost: MediaPlanPost = {
            id: crypto.randomUUID(),
            platform: 'Facebook',
            contentType: 'Image Post',
            title: idea.title,
            content: idea.content,
            hashtags: [],
            cta: idea.cta,
            mediaPrompt: idea.mediaPrompt,
            status: 'draft',
        };

        const newPlanGroup: MediaPlanGroup = {
            id: crypto.randomUUID(),
            name: `Plan from: ${idea.title.substring(0, 20)}...`,
            prompt: `Generated from Facebook Trend: ${idea.title}`,
            plan: [{
                week: 1,
                theme: 'Generated from Facebook Trend',
                posts: [newPost]
            }],
            source: 'wizard',
        };

        dispatchAssets({ type: 'ADD_MEDIA_PLAN', payload: newPlanGroup });
        setActiveTab('mediaPlan');
        setActivePlanId(newPlanGroup.id);
        setSuccessMessage('Post idea added to a new plan!');
        setTimeout(() => setSuccessMessage(null), 3000);

    }, []);

    // --- RENDER LOGIC ---
    // Check if we're on the admin route
    const isAdminRoute = window.location.pathname === '/admin';
    
    // If on admin route, show admin page if authenticated, otherwise show login
    if (isAdminRoute) {
        if (isAdminAuthenticated) {
            return <AdminPage />;
        } else {
            return (
                <div className="min-h-screen flex items-center justify-center bg-gray-50">
                    <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
                        <h1 className="text-2xl font-bold mb-6 text-center">Admin Login</h1>
                        <div className="space-y-4">
                            <input
                                type="password"
                                placeholder="Enter admin password"
                                value={adminPassword}
                                onChange={(e) => setAdminPassword(e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-green"
                            />
                            <Button 
                                onClick={() => {
                                    // Use environment variable for admin password, fallback to 'admin123'
                                    const adminPass = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';
                                    if (adminPassword === adminPass) {
                                        setIsAdminAuthenticated(true);
                                    } else {
                                        setError('Invalid password');
                                    }
                                }}
                                className="w-full"
                            >
                                Login
                            </Button>
                            {error && <p className="text-red-500 text-center">{error}</p>}
                        </div>
                    </div>
                </div>
            );
        }
    }
    
    if (isLoading || isPerformingBulkAction) {
        const content = isLoading ? loaderContent : bulkActionStatus;
        return <Loader title={content!.title} steps={content!.steps} currentStep={(content as any).currentStep} />;
    }
    
    if (error) {
        // Simple error overlay
        return (
            <div className="fixed inset-0 bg-red-50 flex flex-col items-center justify-center p-4 z-50">
                <div className="bg-white p-8 rounded-lg shadow-2xl border border-red-200 text-center max-w-lg">
                    <h2 className="text-2xl font-bold text-red-700">An Error Occurred</h2>
                    <p className="mt-2 text-gray-600 font-serif">{error}</p>
                    <pre className="mt-4 text-xs text-left bg-gray-100 p-2 rounded overflow-auto max-h-40">{error.toString()}</pre>
                    <Button onClick={() => setError(null)} className="mt-6">Close</Button>
                </div>
            </div>
        );
    }
    
    // Show loading screen while config is loading
    if (!isConfigLoaded) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="text-center">
                    <div className="w-16 h-16 border-4 border-brand-green border-t-transparent rounded-full animate-spin mx-auto"></div>
                    <p className="mt-4 text-gray-600">Loading application configuration...</p>
                </div>
            </div>
        );
    }

    switch (currentStep) {
        case 'idea':
            return (
                <>
                    <IdeaProfiler
                        onGenerateProfile={handleGenerateProfile}
                        isLoading={!!loaderContent}
                        onLoadProject={handleLoadProjectFile}
                        onLoadProjectFromAirtable={handleLoadFromAirtable}
                        language={settings.language}
                        setLanguage={setLanguage}
                        integrationsVersion={integrationsVersion}
                        areCredentialsSet={areCredentialsSet}
                    />
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                    
                </>
            );
        case 'profile':
            return (
                <BrandProfiler
                    initialBrandInfo={brandInfo!}
                    onGenerate={handleGenerateKit}
                    isLoading={!!loaderContent}
                    onBack={handleBackToIdea}
                    language={settings.language}
                />
            );
        case 'assets':
            if (generatedAssets) {
                 return (
                    <>
                        <MainDisplay
                            assets={generatedAssets}
                            onGenerateImage={handleGenerateImage}
                            onSetImage={handleSetImage}
                            generatedImages={generatedImages}
                            isGeneratingImage={(key) => generatingImageKeys.has(key)}
                            isUploadingImage={(key) => uploadingImageKeys.has(key)}
                            settings={settings}
                            onExportBrandKit={handleExportBrandKit}
                            isExportingBrandKit={isExporting}
                            onExportPlan={handleExportMediaPlan}
                            isExportingPlan={isExporting}
                            onGeneratePlan={handleGenerateMediaPlanGroup}
                            isGeneratingPlan={!!loaderContent}
                            onRegenerateWeekImages={handleRegenerateWeekImages}
                            onBulkGenerateImages={handleBulkGenerateImages}
                            onBulkSuggestPromotions={handleBulkSuggestPromotions}
                            onBulkGenerateComments={handleBulkGenerateComments}
                            productImages={[]}
                            onSetProductImages={handleSetProductImages}
                            onSaveProject={handleSaveProjectToFile}
                            isSavingProject={isSaving}
                            onStartOver={handleBackToIdea}
                            autoSaveStatus={autoSaveStatus}
                            onOpenSettings={() => setIsSettingsModalOpen(true)}
                            onOpenIntegrations={() => setIsAirtableLoadModalOpen(true)}
                            activeTab={activeTab}
                            setActiveTab={setActiveTab}
                            // Media Plan props
                            mediaPlanGroupsList={mediaPlanGroupsList}
                            onSelectPlan={handleSelectPlan}
                            // New prop to pass brandFoundation
                            brandFoundation={generatedAssets?.brandFoundation}
                            activePlanId={activePlanId}
                            onUpdatePost={handleUpdatePost}
                            onRefinePost={handleRefinePost}
                            onAssignPersonaToPlan={handleAssignPersonaToPlan}
                            // Affiliate Vault props
                            onSaveAffiliateLink={handleSaveAffiliateLink}
                            onDeleteAffiliateLink={handleDeleteAffiliateLink}
                            onImportAffiliateLinks={handleImportAffiliateLinks}
                            onReloadLinks={handleReloadAffiliateLinks}
                            // KhongMinh
                            analyzingPostIds={analyzingPostIds}
                            isAnyAnalysisRunning={analyzingPostIds.size > 0}
                            khongMinhSuggestions={khongMinhSuggestions}
                            onAcceptSuggestion={handleAcceptSuggestion}
                            onRunKhongMinhForPost={handleRunKhongMinhForPost}
                            // On-demand prompt generation
                            generatingPromptKeys={generatingPromptKeys}
                            onGeneratePrompt={handleGenerateMediaPrompt}
                            // Comment Generation
                            onGenerateAffiliateComment={handleGenerateAffiliateComment}
                            generatingCommentPostIds={generatingCommentPostIds}
                            // Selection & Scheduling
                            selectedPostIds={selectedPostIds}
                            onTogglePostSelection={handleTogglePostSelection}
                            onSelectAllPosts={handleSelectAllPosts}
                            onClearSelection={() => setSelectedPostIds(new Set())}
                            onOpenScheduleModal={setSchedulingPost}
                            onPublishPost={handlePublishPost}
                            isScheduling={isScheduling}
                            onSchedulePost={handleSchedulePost}
                            onPostDrop={handlePostDrop}
                            schedulingPost={schedulingPost}
                            onOpenBulkScheduleModal={() => setIsBulkScheduleModalOpen(true)}
                            isBulkScheduleModalOpen={isBulkScheduleModalOpen}
                            onCloseBulkScheduleModal={() => setIsBulkScheduleModalOpen(false)}
                            onBulkSchedule={handleBulkSchedule}
                            // Personas
                            onSavePersona={handleSavePersona}
                            onDeletePersona={handleDeletePersona}
                            onSetPersonaImage={handleSetPersonaImage}
                            onUpdatePersona={handleUpdatePersona}
                            // Strategy Hub
                            onSaveTrend={handleSaveTrend}
                            onDeleteTrend={handleDeleteTrend}
                            onGenerateIdeas={handleGenerateIdeas}
                            onGenerateContentPackage={handleGenerateContentPackage}
                            onGenerateFacebookTrends={handleGenerateFacebookTrends}
                            isGeneratingTrendsFromSearch={isGeneratingFacebookTrends}
                            onLoadIdeasForTrend={handleLoadIdeasForTrend}
                            // Video
                            generatedVideos={generatedVideos}
                            onSetVideo={handleSetVideo}
                             // New Facebook Strategy Props
                            onGenerateFacebookPostIdeas={handleGenerateFacebookPostIdeas}
                            onAddFacebookPostIdeaToPlan={handleAddFacebookPostIdeaToPlan}
                            isGeneratingFacebookPostIdeas={isGeneratingFacebookPostIdeas}
                            // Funnel Campaign Props
                            onCreateFunnelCampaignPlan={handleCreateFunnelCampaignPlan}
                            // Lazy loading props
                            isStrategyHubDataLoaded={!!(generatedAssets?.trends && generatedAssets?.ideas)}
                            onLoadStrategyHubData={handleLoadStrategyHubData}
                            isLoadingStrategyHubData={false}
                            isAffiliateVaultDataLoaded={!!generatedAssets?.affiliateLinks}
                            onLoadAffiliateVaultData={handleLoadAffiliateVaultData}
                            isLoadingAffiliateVaultData={false}
                            isPersonasDataLoaded={!!generatedAssets?.personas}
                            onLoadPersonasData={handleLoadPersonasData}
                            isLoadingPersonasData={false}
                        />
                        {successMessage && (
                            <div className="fixed bottom-5 right-5 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg animate-fade-in-out">
                                {successMessage}
                            </div>
                        )}
                        {waitMessage && (
                            <div className="fixed bottom-5 left-5 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg flex items-center gap-2">
                                <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                                {waitMessage}
                            </div>
                        )}
                        <AirtableLoadModal 
                            isOpen={isAirtableLoadModalOpen}
                            onClose={() => setIsAirtableLoadModalOpen(false)}
                            onLoadProject={handleLoadFromAirtable}
                            language={settings.language}
                        />
                        <SettingsModal
                            isOpen={isSettingsModalOpen}
                            onClose={() => setIsSettingsModalOpen(false)}
                            brandId={airtableBrandId || ''}
                        />
                        

                        <PersonaConnectModal
                            isOpen={isPersonaConnectModalOpen}
                            onClose={handleClosePersonaConnectModal}
                            language={settings.language}
                            personaToConnect={personaToConnect}
                            platformToConnect={platformToConnect}
                            onSocialAccountConnected={handleSocialAccountConnected}
                        />
                    </>
                );
            }
            // Fallback if assets are somehow null
            return <div>Loading assets...</div>;
        default:
            return <div>Invalid state</div>;
    }
};

export default App;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\App.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.css ---\n/* Global styles for SocialSync Pro */

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f8f9fa;
}

html, body, #root {
  height: 100%;
}

* {
  box-sizing: border-box;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Utility classes */
.text-center {
  text-align: center;
}

.flex {
  display: flex;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.w-full {
  width: 100%;
}

.h-full {
  height: 100%;
}

.p-4 {
  padding: 1rem;
}

.m-4 {
  margin: 1rem;
}\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.css ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.tsx ---\nimport './polyfills.ts';
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
    throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\index.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\polyfills.ts ---\n// This file contains polyfills to make Node.js-specific libraries work in the browser.

// Polyfill for 'fs' module to prevent AWS SDK from crashing in browser environments.
// This is a workaround for environments where the SDK incorrectly attempts to access
// the filesystem. It simulates a "file not found" error, which the SDK can handle
// gracefully, allowing it to proceed with the explicitly provided credentials.
// This is applied unconditionally to override any partial polyfills from the environment (e.g., unenv).

type Callback = (err: Error | null, data: null) => void;

const fsPolyfill = {
    // @ts-ignore
    readFile: (path: string, options: object | Callback, callback?: Callback) => {
        const cb = typeof options === 'function' ? options : callback;
        if (typeof cb !== 'function') {
            console.error("fs.readFile polyfill called without a callback.");
            return;
        }
        const err = new Error(`ENOENT: no such file or directory, open '${path}'`);
        // @ts-ignore
        err.code = 'ENOENT';
        // Defer the callback to simulate async I/O.
        setTimeout(() => cb(err, null), 0);
    },
    // @ts-ignore
    readFileSync: (path: string, options?: any) => {
        const err = new Error(`ENOENT: no such file or directory, open '${path}'`);
        // @ts-ignore
        err.code = 'ENOENT';
        throw err;
    },
};

// Forcefully override any existing 'fs' polyfill on the global object.
// @ts-ignore
globalThis.fs = fsPolyfill;

// Polyfill for 'process.env' to allow setting environment variables at runtime in the browser console.
// This is necessary for services that read credentials dynamically.
// We must attach it to `window` so it's globally available.
if (typeof (window as any).process === 'undefined') {
  (window as any).process = {};
}
if (typeof (window as any).process.env === 'undefined') {
  (window as any).process.env = {};
}
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\polyfills.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\sampleAIServices.ts ---\n// Sample AI services data
const sampleAIServices = [
  {
    id: '1',
    name: 'Google AI',
    description: "Google's artificial intelligence platform",
    models: [
      {
        id: '1-1',
        name: 'Gemini Pro',
        provider: 'Google',
        capabilities: ['text', 'image', 'code']
      },
      {
        id: '1-2',
        name: 'Gemini Ultra',
        provider: 'Google',
        capabilities: ['text', 'image', 'code', 'audio', 'video']
      }
    ]
  },
  {
    id: '2',
    name: 'OpenAI',
    description: "OpenAI's language models",
    models: [
      {
        id: '2-1',
        name: 'GPT-4',
        provider: 'OpenAI',
        capabilities: ['text', 'code']
      },
      {
        id: '2-2',
        name: 'GPT-4 Vision',
        provider: 'OpenAI',
        capabilities: ['text', 'image', 'code']
      }
    ]
  },
  {
    id: '3',
    name: 'Anthropic',
    description: "Anthropic's Claude models",
    models: [
      {
        id: '3-1',
        name: 'Claude 3 Opus',
        provider: 'Anthropic',
        capabilities: ['text', 'image', 'code']
      },
      {
        id: '3-2',
        name: 'Claude 3 Sonnet',
        provider: 'Anthropic',
        capabilities: ['text', 'code']
      }
    ]
  }
];

export default sampleAIServices;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\sampleAIServices.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AdminPage.tsx ---\nimport React, { useState, useEffect } from 'react';
import { Button, Input } from './ui';
import { TrashIcon, PencilIcon, PlusIcon } from './icons';
import sampleAIServices from '../sampleAIServices';
import { saveAIService, deleteAIService, saveAIModel, deleteAIModel, loadAIServices } from '../services/databaseService';
import { configService, AiModelConfig } from '../services/configService';
import type { Settings } from '../types';
import type { AIService, AIModel } from '../types';


// Define our own simple types instead of using Pick
interface NewService {
  name: string;
  description: string;
  models: AIModel[];
}

interface NewModel {
  name: string;
  provider: string;
  capabilities: string[];
}

const AdminPage: React.FC = () => {
  const [services, setServices] = useState<AIService[]>([]);
  const [editingService, setEditingService] = useState<AIService | null>(null);
  const [newService, setNewService] = useState<NewService>({ 
    name: '', 
    description: '', 
    models: [] 
  });
  
  const [editingModel, setEditingModel] = useState<AIModel | null>(null);
  const [newModel, setNewModel] = useState<NewModel>({ 
    name: '', 
    provider: '', 
    capabilities: [] 
  });
  
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  // New states for app settings and AI model config
  const [appSettings, setAppSettings] = useState<Settings>(configService.getAppSettings());
  const [aiModelConfig, setAiModelConfig] = useState<AiModelConfig>(configService.getAiModelConfig());

  // Load data from Airtable and configService on component mount
  useEffect(() => {
    const loadAllData = async () => {
      try {
        setLoading(true);
        // Load AI services from Airtable (existing functionality)
        const loadedServices = await loadAIServices();
        setServices(loadedServices);

        // Load app settings and AI model config from configService
        const adminDefaults = await configService.getAdminDefaults();
        setAppSettings(adminDefaults);
        setAiModelConfig(configService.getAiModelConfig());

      } catch (err) {
        setError('Failed to load data: ' + (err instanceof Error ? err.message : 'Unknown error'));
        console.error('Error loading data:', err);
      } finally {
        setLoading(false);
      }
    };
    
    loadAllData();
  }, []);

  const handleAddService = async () => {
    if (!newService.name.trim()) return;
    
    try {
      const service: Omit<AIService, 'models'> = {
        id: 'service-' + Date.now(),
        name: newService.name,
        description: newService.description,
      };
      
      const savedService = await saveAIService(service);
      // Add a small delay to ensure the service is properly saved in Airtable
      await new Promise(resolve => setTimeout(resolve, 500));
      setServices([...services, { ...service, models: [] }]);
      setNewService({ name: '', description: '', models: [] });
    } catch (err) {
      setError('Failed to add AI service');
      console.error('Error adding AI service:', err);
    }
  };

  const handleUpdateService = async () => {
    if (!editingService) return;
    
    try {
      await saveAIService(editingService);
      setServices(services.map(s => s.id === editingService.id ? editingService : s));
      setEditingService(null);
    } catch (err) {
      setError('Failed to update AI service');
      console.error('Error updating AI service:', err);
    }
  };

  const handleDeleteService = async (id: string) => {
    try {
      await deleteAIService(id);
      setServices(services.filter(s => s.id !== id));
    } catch (err) {
      setError('Failed to delete AI service');
      console.error('Error deleting AI service:', err);
    }
  };

  const handleAddModel = async (serviceId: string) => {
    if (!newModel.name.trim()) return;
    
    try {
      const model: AIModel = {
        id: 'model-' + Date.now(),
        name: newModel.name,
        provider: newModel.provider,
        capabilities: newModel.capabilities,
      };
      
      await saveAIModel(model, serviceId);
      
      setServices(services.map(service => {
        if (service.id === serviceId) {
          return {
            ...service,
            models: [...service.models, model]
          };
        }
        return service;
      }));
      
      setNewModel({ name: '', provider: '', capabilities: [] });
    } catch (err) {
      setError('Failed to add AI model');
      console.error('Error adding AI model:', err);
    }
  };

  const handleUpdateModel = async (serviceId: string) => {
    if (!editingModel) return;
    
    try {
      await saveAIModel(editingModel, serviceId);
      
      setServices(services.map(service => {
        if (service.id === serviceId) {
          return {
            ...service,
            models: service.models.map(m => m.id === editingModel.id ? editingModel : m)
          };
        }
        return service;
      }));
      
      setEditingModel(null);
    } catch (err) {
      setError('Failed to update AI model');
      console.error('Error updating AI model:', err);
    }
  };

  const handleDeleteModel = async (serviceId: string, modelId: string) => {
    try {
      await deleteAIModel(modelId);
      
      setServices(services.map(service => {
        if (service.id === serviceId) {
          return {
            ...service,
            models: service.models.filter(m => m.id !== modelId)
          };
        }
        return service;
      }));
    } catch (err) {
      setError('Failed to delete AI model');
      console.error('Error deleting AI model:', err);
    }
  };

  const handleLoadSampleData = async () => {
    if (services.length > 0 && !window.confirm('This will replace all existing services. Continue?')) {
      return;
    }
    
    try {
      // Create new services with simpler IDs
      const servicesWithIds = sampleAIServices.map((service, index) => ({
        ...service,
        id: `service-${Date.now()}-${index}`
      }));
      
      // Save sample services to Airtable
      for (const service of servicesWithIds) {
        await saveAIService(
          { id: service.id, name: service.name, description: service.description }
        );
      }
      
      // Save models for each service
      for (const service of servicesWithIds) {
        // Create models with simpler IDs
        const modelsWithIds = service.models.map((model, index) => ({
          ...model,
          id: `model-${Date.now()}-${index}`
        }));
        
        // Save models for this service
        for (const model of modelsWithIds) {
          await saveAIModel(model, service.id);
        }
      }
      
      // Reload services to reflect changes
      const loadedServices = await loadAIServices();
      setServices(loadedServices);
    } catch (err) {
      setError('Failed to load sample data');
      console.error('Error loading sample data:', err);
    }
  };

  const handleLogout = () => {
    // Clear authentication status
    window.location.href = '/';
  };

  const handleSaveAppSettings = async () => {
    try {
      // Merge appSettings and aiModelConfig into a single settings object
      const mergedSettings = { ...appSettings, ...aiModelConfig };
      console.log("Saving admin app settings:", mergedSettings);
      await configService.saveAdminDefaults(mergedSettings);
      setSuccessMessage('Application settings saved successfully!');
      setError(null);
    } catch (err) {
      const errorMessage = 'Failed to save application settings: ' + (err instanceof Error ? err.message : 'Unknown error');
      setError(errorMessage);
      setSuccessMessage(null);
      console.error(errorMessage, err);
    }
  };

  const handleSaveAiModelConfig = async () => {
    try {
      // Merge appSettings and aiModelConfig into a single settings object
      const mergedSettings = { ...appSettings, ...aiModelConfig };
      console.log("Saving AI model config:", mergedSettings);
      await configService.saveAdminDefaults(mergedSettings);
      setSuccessMessage('AI Model Configuration saved successfully!');
      setError(null);
    } catch (err) {
      const errorMessage = 'Failed to save AI Model Configuration: ' + (err instanceof Error ? err.message : 'Unknown error');
      setError(errorMessage);
      setSuccessMessage(null);
      console.error(errorMessage, err);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-brand-green border-t-transparent rounded-full animate-spin mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading AI services...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-6xl mx-auto p-6">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">AI Services Administration</h1>
          <div className="flex gap-2">
            <Button 
              onClick={handleLoadSampleData}
              variant="tertiary"
              className="flex items-center gap-2"
            >
              Load Sample Data
            </Button>
            <Button 
              onClick={handleLogout}
              variant="tertiary"
              className="flex items-center gap-2"
            >
              Logout
            </Button>
          </div>
        </div>
        
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
            <p className="text-red-700">{error}</p>
          </div>
        )}
        
        {successMessage && (
          <div className="bg-green-50 border border-green-200 rounded-md p-4 mb-6">
            <p className="text-green-700">{successMessage}</p>
          </div>
        )}
        
        {/* Application Settings */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4">Application Settings</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <label className="block">
              <span className="text-gray-700">Language</span>
              <Input
                value={appSettings.language}
                onChange={(e) => setAppSettings({ ...appSettings, language: e.target.value })}
              />
            </label>
            <label className="block">
              <span className="text-gray-700">Total Posts Per Month</span>
              <Input
                type="number"
                value={appSettings.totalPostsPerMonth}
                onChange={(e) => setAppSettings({ ...appSettings, totalPostsPerMonth: parseInt(e.target.value) })}
              />
            </label>
            <label className="block md:col-span-2">
              <span className="text-gray-700">Media Prompt Suffix</span>
              <Input
                value={appSettings.mediaPromptSuffix}
                onChange={(e) => setAppSettings({ ...appSettings, mediaPromptSuffix: e.target.value })}
              />
            </label>
            <label className="block md:col-span-2">
              <span className="text-gray-700">Text Generation Model</span>
              <Input
                value={appSettings.textGenerationModel}
                onChange={(e) => setAppSettings({ ...appSettings, textGenerationModel: e.target.value })}
              />
            </label>
            <label className="block md:col-span-2">
              <span className="text-gray-700">Image Generation Model</span>
              <Input
                value={appSettings.imageGenerationModel}
                onChange={(e) => setAppSettings({ ...appSettings, imageGenerationModel: e.target.value })}
              />
            </label>
            <label className="block md:col-span-2">
              <span className="text-gray-700">Affiliate Content Kit</span>
              <textarea
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-brand-blue focus:ring focus:ring-brand-blue focus:ring-opacity-50"
                rows={10}
                value={appSettings.affiliateContentKit}
                onChange={(e) => setAppSettings({ ...appSettings, affiliateContentKit: e.target.value })}
              ></textarea>
            </label>
          </div>
          <Button 
            className="mt-4 flex items-center gap-2"
            onClick={handleSaveAppSettings}
          >
            Save Application Settings
          </Button>
        </div>

        {/* AI Model Configuration */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4">AI Model Configuration</h2>

          {/* Text Model Fallback Order */}
          <div className="mb-6">
            <h3 className="text-lg font-medium mb-3">Text Model Fallback Order</h3>
            <div className="space-y-2">
              {aiModelConfig.textModelFallbackOrder.map((model, index) => (
                <div key={index} className="flex items-center gap-2">
                  <Input
                    value={model}
                    onChange={(e) => {
                      const newOrder = [...aiModelConfig.textModelFallbackOrder];
                      newOrder[index] = e.target.value;
                      setAiModelConfig({ ...aiModelConfig, textModelFallbackOrder: newOrder });
                    }}
                    className="flex-grow"
                  />
                  <Button
                    variant="tertiary"
                    onClick={() => {
                      const newOrder = aiModelConfig.textModelFallbackOrder.filter((_, i) => i !== index);
                      setAiModelConfig({ ...aiModelConfig, textModelFallbackOrder: newOrder });
                    }}
                  >
                    <TrashIcon className="h-5 w-5 text-red-600" />
                  </Button>
                </div>
              ))}
            </div>
            <Button
              className="mt-3 flex items-center gap-2"
              onClick={() => setAiModelConfig({ ...aiModelConfig, textModelFallbackOrder: [...aiModelConfig.textModelFallbackOrder, ''] })}
            >
              <PlusIcon className="h-5 w-5" />
              Add Text Model
            </Button>
          </div>

          {/* Vision Models */}
          <div>
            <h3 className="text-lg font-medium mb-3">Vision Models</h3>
            <div className="space-y-2">
              {aiModelConfig.visionModels.map((model, index) => (
                <div key={index} className="flex items-center gap-2">
                  <Input
                    value={model}
                    onChange={(e) => {
                      const newModels = [...aiModelConfig.visionModels];
                      newModels[index] = e.target.value;
                      setAiModelConfig({ ...aiModelConfig, visionModels: newModels });
                    }}
                    className="flex-grow"
                  />
                  <Button
                    variant="tertiary"
                    onClick={() => {
                      const newModels = aiModelConfig.visionModels.filter((_, i) => i !== index);
                      setAiModelConfig({ ...aiModelConfig, visionModels: newModels });
                    }}
                  >
                    <TrashIcon className="h-5 w-5 text-red-600" />
                  </Button>
                </div>
              ))}
            </div>
            <Button
              className="mt-3 flex items-center gap-2"
              onClick={() => setAiModelConfig({ ...aiModelConfig, visionModels: [...aiModelConfig.visionModels, ''] })}
            >
              <PlusIcon className="h-5 w-5" />
              Add Vision Model
            </Button>
          </div>

          <Button 
            className="mt-4 flex items-center gap-2"
            onClick={handleSaveAiModelConfig}
          >
            Save AI Model Configuration
          </Button>
        </div>

        {/* Add New Service */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4">Add New AI Service</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Input
              placeholder="Service Name"
              value={newService.name}
              onChange={(e) => setNewService({...newService, name: e.target.value})}
            />
            <Input
              placeholder="Description"
              value={newService.description}
              onChange={(e) => setNewService({...newService, description: e.target.value})}
            />
          </div>
          <Button 
            className="mt-4 flex items-center gap-2"
            onClick={handleAddService}
          >
            <PlusIcon className="h-5 w-5" />
            Add Service
          </Button>
        </div>

        {/* Services List */}
        <div className="space-y-6">
          {services.map(service => (
            <div key={service.id} className="bg-white rounded-lg shadow-md overflow-hidden">
              <div className="p-6">
                {editingService?.id === service.id ? (
                  // Edit Service Form
                  <div className="space-y-4">
                    <h2 className="text-xl font-semibold">Edit Service</h2>
                    <Input
                      placeholder="Service Name"
                      value={editingService.name}
                      onChange={(e) => setEditingService({...editingService, name: e.target.value})}
                    />
                    <Input
                      placeholder="Description"
                      value={editingService.description}
                      onChange={(e) => setEditingService({...editingService, description: e.target.value})}
                    />
                    <div className="flex gap-2">
                      <Button onClick={handleUpdateService}>Save</Button>
                      <Button variant="tertiary" onClick={() => setEditingService(null)}>Cancel</Button>
                    </div>
                  </div>
                ) : (
                  // Service Display
                  <div className="flex justify-between items-start">
                    <div>
                      <h2 className="text-xl font-semibold">{service.name}</h2>
                      <p className="text-gray-600 mt-1">{service.description}</p>
                    </div>
                    <div className="flex gap-2">
                      <Button 
                        variant="tertiary" 
                        onClick={() => setEditingService(service)}
                        className="flex items-center gap-1"
                      >
                        <PencilIcon className="h-4 w-4" />
                        Edit
                      </Button>
                      <Button 
                        variant="tertiary" 
                        onClick={() => handleDeleteService(service.id)}
                        className="flex items-center gap-1 text-red-600 hover:bg-red-50"
                      >
                        <TrashIcon className="h-4 w-4" />
                        Delete
                      </Button>
                    </div>
                  </div>
                )}
              </div>
              
              {/* Models Section */}
              <div className="border-t border-gray-200 p-6">
                <h3 className="text-lg font-medium mb-4">Models</h3>
                
                {/* Add New Model */}
                <div className="bg-gray-50 p-4 rounded-lg mb-4">
                  <h4 className="font-medium mb-3">Add New Model</h4>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <Input
                      placeholder="Model Name"
                      value={newModel.name}
                      onChange={(e) => setNewModel({...newModel, name: e.target.value})}
                    />
                    <Input
                      placeholder="Provider"
                      value={newModel.provider}
                      onChange={(e) => setNewModel({...newModel, provider: e.target.value})}
                    />
                    <div className="relative">
                      <label className="block text-sm font-medium text-gray-700 mb-1">Capabilities</label>
                      <div className="flex flex-wrap gap-2 p-2 border border-gray-300 rounded-md">
                        {['text', 'image', 'audio', 'video', 'code'].map((capability) => (
                          <label key={capability} className="inline-flex items-center">
                            <input
                              type="checkbox"
                              className="rounded border-gray-300 text-brand-blue focus:ring-brand-blue"
                              checked={newModel.capabilities.includes(capability)}
                              onChange={(e) => {
                                if (e.target.checked) {
                                  setNewModel({
                                    ...newModel,
                                    capabilities: [...newModel.capabilities, capability]
                                  });
                                } else {
                                  setNewModel({
                                    ...newModel,
                                    capabilities: newModel.capabilities.filter(c => c !== capability)
                                  });
                                }
                              }}
                            />
                            <span className="ml-1 text-sm text-gray-700">{capability}</span>
                          </label>
                        ))}
                      </div>
                    </div>
                  </div>
                  <Button 
                    className="mt-3 flex items-center gap-2"
                    onClick={() => handleAddModel(service.id)}
                  >
                    <PlusIcon className="h-4 w-4" />
                    Add Model
                  </Button>
                </div>
                
                {/* Models List */}
                {service.models.length > 0 ? (
                  <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                      <thead className="bg-gray-50">
                        <tr>
                          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Provider</th>
                          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Capabilities</th>
                          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                        </tr>
                      </thead>
                      <tbody className="bg-white divide-y divide-gray-200">
                        {service.models.map(model => (
                          <tr key={model.id}>
                            {editingModel?.id === model.id ? (
                              // Edit Model Row
                              <td colSpan={4} className="px-6 py-4">
                                <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                                  <Input
                                    placeholder="Model Name"
                                    value={editingModel.name}
                                    onChange={(e) => setEditingModel({...editingModel, name: e.target.value})}
                                  />
                                  <Input
                                    placeholder="Provider"
                                    value={editingModel.provider}
                                    onChange={(e) => setEditingModel({...editingModel, provider: e.target.value})}
                                  />
                                  <div className="relative">
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Capabilities</label>
                                    <div className="flex flex-wrap gap-2 p-2 border border-gray-300 rounded-md">
                                      {['text', 'image', 'audio', 'video', 'code'].map((capability) => (
                                        <label key={capability} className="inline-flex items-center">
                                          <input
                                            type="checkbox"
                                            className="rounded border-gray-300 text-brand-blue focus:ring-brand-blue"
                                            checked={editingModel.capabilities.includes(capability)}
                                            onChange={(e) => {
                                              if (e.target.checked) {
                                                setEditingModel({
                                                  ...editingModel,
                                                  capabilities: [...editingModel.capabilities, capability]
                                                });
                                              } else {
                                                setEditingModel({
                                                  ...editingModel,
                                                  capabilities: editingModel.capabilities.filter(c => c !== capability)
                                                });
                                              }
                                            }}
                                          />
                                          <span className="ml-1 text-sm text-gray-700">{capability}</span>
                                        </label>
                                      ))}
                                    </div>
                                  </div>
                                  <div className="flex gap-2 mt-6">
                                    <Button onClick={() => handleUpdateModel(service.id)}>Save</Button>
                                    <Button variant="tertiary" onClick={() => setEditingModel(null)}>Cancel</Button>
                                  </div>
                                </div>
                              </td>
                            ) : (
                              // Display Model Row
                              <>
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{model.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{model.provider}</td>
                                <td className="px-6 py-4 text-sm text-gray-500">{model.capabilities}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                                  <div className="flex gap-2">
                                    <Button 
                                      variant="tertiary" 
                                      onClick={() => setEditingModel(model)}
                                      className="flex items-center gap-1"
                                    >
                                      <PencilIcon className="h-4 w-4" />
                                      Edit
                                    </Button>
                                    <Button 
                                      variant="tertiary" 
                                      onClick={() => handleDeleteModel(service.id, model.id)}
                                      className="flex items-center gap-1 text-red-600 hover:bg-red-50"
                                    >
                                      <TrashIcon className="h-4 w-4" />
                                      Delete
                                    </Button>
                                  </div>
                                </td>
                              </>
                            )}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                ) : (
                  <p className="text-gray-500 italic">No models added for this service yet.</p>
                )}
              </div>
            </div>
          ))}
        </div>
        
        {services.length === 0 && !loading && (
          <div className="text-center py-12">
            <p className="text-gray-500">No AI services configured yet. Add your first service above.</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default AdminPage;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AdminPage.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AffiliateVaultDisplay.tsx ---\n
import React, { useState, useRef, useMemo, useEffect } from 'react';

import ExcelJS, { Cell } from 'exceljs';
import type { AffiliateLink } from '../types';
import { Button, Input, Select } from './ui';
import { ArrowPathIcon, PlusIcon, UploadIcon, SearchIcon, CashIcon, ScaleIcon, CollectionIcon, SparklesIcon, LinkIcon } from './icons';
import ProductCard from './ProductCard';

interface AffiliateVaultDisplayProps {
  affiliateLinks: AffiliateLink[];
  onSaveLink: (link: AffiliateLink) => void;
  onDeleteLink: (linkId: string) => void;
  onImportLinks: (links: AffiliateLink[]) => void;
  onReloadLinks: () => void; // New prop for reloading links
  onGenerateIdeasFromProduct?: (product: AffiliateLink) => void; // New prop for generating ideas from a product
  language: string;
  // Lazy loading props
  isDataLoaded?: boolean;
  onLoadData?: () => void;
  isLoading?: boolean;
}

const emptyLink: Omit<AffiliateLink, 'id'> = {
    productId: '',
    productName: '',
    price: 0,
    salesVolume: 0,
    providerName: '',
    commissionRate: 0,
    commissionValue: 0,
    productLink: '',
    promotionLink: '',
};

const AffiliateVaultDisplay: React.FC<AffiliateVaultDisplayProps> = ({ affiliateLinks, onSaveLink, onDeleteLink, onImportLinks, onReloadLinks, onGenerateIdeasFromProduct, language, isDataLoaded, onLoadData, isLoading }) => {
    const [isAffiliateVaultDataLoaded, setIsAffiliateVaultDataLoaded] = useState(false);
    const [isLoadingAffiliateVaultData, setIsLoadingAffiliateVaultData] = useState(false);
    
    // Load data when component mounts if not already loaded
    useEffect(() => {
        if (!isDataLoaded && onLoadData && !isLoading) {
            setIsLoadingAffiliateVaultData(true);
            onLoadData().finally(() => {
                setIsLoadingAffiliateVaultData(false);
                setIsAffiliateVaultDataLoaded(true);
            });
        } else if (isDataLoaded) {
            setIsAffiliateVaultDataLoaded(true);
        }
    }, [isDataLoaded, onLoadData, isLoading]);
    const [isAddingNewLink, setIsAddingNewLink] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('productName-asc');
    const [currentPage, setCurrentPage] = useState(1);
    const [productsPerPage, setProductsPerPage] = useState(20);
    const fileInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        setCurrentPage(1);
    }, [searchQuery, sortBy, productsPerPage]);

    const T = {
        'Việt Nam': {
            title: "Kho Affiliate",
            subtitle: "Quản lý tất cả các liên kết sản phẩm affiliate của bạn ở một nơi.",
            addLink: "Thêm liên kết mới",
            importFromFile: "Nhập từ tệp",
            // Empty State
            noLinks: "Chưa có liên kết affiliate nào.",
            addFirstLink: "Thêm liên kết đầu tiên của bạn để bắt đầu.",
            noResults: "Không tìm thấy kết quả",
            noResultsDesc: "Hãy thử một tìm kiếm khác hoặc thêm một liên kết mới.",
            // Confirm
            confirmDeleteMessage: "Bạn có chắc chắn muốn xóa liên kết này không? Hành động này không thể hoàn tác và sẽ xóa bản ghi khỏi Airtable nếu được kết nối.",
            // KPIs
            totalLinks: "Tổng số liên kết",
            totalComm: "Tổng hoa hồng",
            avgRate: "Tỷ lệ trung bình",
            topPerformer: "Hiệu suất cao nhất",
            // Toolbar
            searchPlaceholder: "Tìm kiếm theo tên, ID, hoặc nhà cung cấp...",
            sortBy: "Sắp xếp theo",
            productsPerPage: "Sản phẩm/trang"
        },
        'English': {
            title: "Affiliate Vault",
            subtitle: "Manage all of your affiliate product links in one place.",
            addLink: "Add New Link",
            importFromFile: "Import from File",
            // Empty State
            noLinks: "No affiliate links yet.",
            addFirstLink: "Add your first link to get started.",
            noResults: "No results found",
            noResultsDesc: "Try a different search or add a new link.",
            // Confirm
            confirmDeleteMessage: "Are you sure you want to delete this link? This cannot be undone and will remove the record from Airtable if connected.",
            // KPIs
            totalLinks: "Total Links",
            totalComm: "Total Commission",
            avgRate: "Average Rate",
            topPerformer: "Top Performer",
            // Toolbar
            searchPlaceholder: "Search by name, ID, or provider...",
            sortBy: "Sort by",
            productsPerPage: "Products/page"
        }
    };
    const texts = (T as any)[language] || T['English'];

    const formatCurrency = useMemo(() => (value: number) => {
        return new Intl.NumberFormat(language === 'Việt Nam' ? 'vi-VN' : 'en-US', {
            style: 'currency',
            currency: language === 'Việt Nam' ? 'VND' : 'USD',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        }).format(value);
    }, [language]);

    console.log("affiliateLinks:", affiliateLinks);

    const kpiData = useMemo(() => {
        const totalLinks = affiliateLinks.length;
        if (totalLinks === 0) {
            return {
                totalLinks: '0',
                totalComm: formatCurrency(0),
                avgRate: '0%',
                topPerformer: { name: 'N/A', value: '' }
            }
        }
        const totalComm = affiliateLinks.reduce((sum, link) => sum + link.commissionValue, 0);
        const totalRate = affiliateLinks.reduce((sum, link) => sum + link.commissionRate, 0);
        const avgRate = totalLinks > 0 ? totalRate / totalLinks : 0;
        const topPerformer = [...affiliateLinks].sort((a,b) => b.commissionValue - a.commissionValue)[0];

        return {
            totalLinks: totalLinks.toString(),
            totalComm: formatCurrency(totalComm),
            avgRate: `${avgRate.toFixed(1)}%`,
            topPerformer: {
                name: topPerformer?.productName || 'N/A',
                value: formatCurrency(topPerformer?.commissionValue || 0)
            }
        }
    }, [affiliateLinks, formatCurrency]);

    const processedLinks = useMemo(() => {
        const filtered = affiliateLinks.filter(link => 
            link.productName.toLowerCase().includes(searchQuery.toLowerCase()) ||
            link.productId.toLowerCase().includes(searchQuery.toLowerCase()) ||
            link.providerName.toLowerCase().includes(searchQuery.toLowerCase())
        );

        const [sortKey, sortDir] = sortBy.split('-');
        
        return filtered.sort((a, b) => {
            let valA, valB;
            switch(sortKey) {
                case 'price':
                case 'commissionValue':
                    valA = a[sortKey as keyof AffiliateLink] as number;
                    valB = b[sortKey as keyof AffiliateLink] as number;
                    break;
                case 'productName':
                default:
                    valA = a.productName.toLowerCase();
                    valB = b.productName.toLowerCase();
                    break;
            }
            if (valA < valB) return sortDir === 'asc' ? -1 : 1;
            if (valA > valB) return sortDir === 'asc' ? 1 : -1;
            return 0;
        });

    }, [affiliateLinks, searchQuery, sortBy]);

    const displayLinks = useMemo(() => {
        const startIndex = (currentPage - 1) * productsPerPage;
        return processedLinks.slice(startIndex, startIndex + productsPerPage);
    }, [processedLinks, currentPage, productsPerPage]);

    const handleDelete = (linkId: string) => {
        if (window.confirm(texts.confirmDeleteMessage)) {
            onDeleteLink(linkId);
        }
    };

    const handleSaveNew = (link: AffiliateLink) => {
        onSaveLink(link);
        setIsAddingNewLink(false);
    };

    const handleGenerateIdeas = (product: AffiliateLink) => {
        // This function will be called when the "Generate Ideas" button is clicked
        if (onGenerateIdeasFromProduct) {
            onGenerateIdeasFromProduct(product);
        }
    };

    const getCellValue = (cell: Cell): string => {
        if (!cell || cell.value === null || cell.value === undefined) return '';
        const val = cell.value;
        if (typeof val === 'object' && val !== null) {
            if ('richText' in val && Array.isArray((val as any).richText)) return (val as any).richText.map((rt:any) => rt.text).join('');
            if ('text' in val) return String((val as any).text);
            if ('result' in val) return String((val as any).result);
            return val.toString();
        }
        return String(val);
    };

    const parseAffiliateNumeric = (value: string | number | null | undefined): number => {
        if (typeof value === 'number') return value;
        if (!value) return 0;
    
        let s = String(value).toLowerCase().trim();
    
        // Remove currency symbols, percent, and '+' from "k+" etc.
        s = s.replace(/₫|vnd|\+|%/g, '').trim();
    
        let multiplier = 1;
        if (s.endsWith('tr')) {
            multiplier = 1000000;
            s = s.slice(0, -2).trim();
        } else if (s.endsWith('k')) {
            multiplier = 1000;
            s = s.slice(0, -1).trim();
        }
        
        // For Vietnamese style numbers: remove dots (thousands separators), then replace comma with dot (decimal separator).
        s = s.replace(/\./g, '').replace(/,/g, '.');
        
        const num = parseFloat(s);
    
        if (isNaN(num)) {
            return 0;
        }
    
        return num * multiplier;
    };

    const handleFileImport = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
    
        const workbook = new ExcelJS.Workbook();
        let worksheet: ExcelJS.Worksheet;
    
        try {
            if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                const csvText = await file.text();
                const parsedRows = csvText.trim().split(/\r?\n/).map(line => line.split(',').map(field => field.trim().replace(/^"|"$/g, '')));
                worksheet = workbook.addWorksheet('Imported CSV');
                worksheet.addRows(parsedRows);
            } else {
                const buffer = await file.arrayBuffer();
                await workbook.xlsx.load(buffer);
                worksheet = workbook.worksheets[0];
            }

            if (!worksheet) throw new Error("Could not find a worksheet.");
    
            const headers: Record<string, number> = {};
            worksheet.getRow(1).eachCell((cell, colNumber) => {
                headers[getCellValue(cell).trim().toLowerCase()] = colNumber;
            });
    
            const headerMapping: Record<string, keyof AffiliateLink> = {
                'mã sản phẩm': 'productId', 'product id': 'productId',
                'tên sản phẩm': 'productName', 'product name': 'productName',
                'giá': 'price', 'price': 'price',
                'doanh số': 'salesVolume', 'sales volume': 'salesVolume', 'doanh thu': 'salesVolume',
                'tên cửa hàng': 'providerName', 'provider name': 'providerName',
                'tỉ lệ hoa hồng': 'commissionRate', 'commission rate': 'commissionRate',
                'hoa hồng': 'commissionValue', 'commission value': 'commissionValue',
                'link sản phẩm': 'productLink', 'product link': 'productLink',
                'link ưu đãi': 'promotionLink', 'promotion link': 'promotionLink',
            };
    
            const importedLinks: AffiliateLink[] = [];
            worksheet.eachRow((row, rowNumber) => {
                if (rowNumber === 1) return;
    
                const link: Partial<AffiliateLink> = {};
                Object.entries(headerMapping).forEach(([header, key]) => {
                    const colNumber = headers[header];
                    if (colNumber) {
                        const cellValue = getCellValue(row.getCell(colNumber));
                        if (cellValue) (link as any)[key] = cellValue;
                    }
                });
    
                if (link.productName && link.productLink) {
                    importedLinks.push({
                        id: crypto.randomUUID(),
                        productId: String(link.productId || ''),
                        productName: String(link.productName),
                        price: parseAffiliateNumeric(link.price),
                        salesVolume: parseAffiliateNumeric(link.salesVolume),
                        providerName: String(link.providerName || ''),
                        commissionRate: parseAffiliateNumeric(link.commissionRate),
                        commissionValue: parseAffiliateNumeric(link.commissionValue),
                        productLink: String(link.productLink),
                        promotionLink: String(link.promotionLink || ''),
                    });
                }
            });
            onImportLinks(importedLinks);
        } catch (err) {
            console.error("Failed to import file:", err);
            alert("Error processing file.");
        }
        event.target.value = '';
    };

    const totalPages = Math.ceil(processedLinks.length / productsPerPage);

    return (
        <div className="h-full flex flex-col p-6 lg:p-10 bg-gray-50/50">
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                <div>
                    <h2 className="text-3xl font-bold font-sans text-gray-900 flex items-center gap-3"><LinkIcon className="h-8 w-8 text-brand-green"/> {texts.title}</h2>
                    <p className="text-lg text-gray-500 font-serif mt-1">{texts.subtitle}</p>
                </div>
                <div className="flex gap-2 flex-shrink-0">
                    <Button variant="secondary" onClick={onReloadLinks} className="flex items-center gap-2">
                        <ArrowPathIcon className="h-5 w-5"/> {texts.reload}
                    </Button>
                    <Button variant="secondary" onClick={() => fileInputRef.current?.click()} className="flex items-center gap-2">
                        <UploadIcon className="h-5 w-5"/> {texts.importFromFile}
                    </Button>
                    <input type="file" ref={fileInputRef} onChange={handleFileImport} className="hidden" accept=".xlsx, .csv" />
                    <Button onClick={() => setIsAddingNewLink(true)} className="flex items-center gap-2">
                        <PlusIcon className="h-5 w-5"/> {texts.addLink}
                    </Button>
                </div>
            </header>

            {/* KPIs */}
            <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm mb-8">
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="p-2 text-center">
                        <CollectionIcon className="h-7 w-7 text-green-600 mx-auto mb-1"/>
                        <p className="text-sm font-medium text-gray-500">{texts.totalLinks}</p>
                        <p className="text-xl font-bold text-gray-900">{kpiData.totalLinks}</p>
                    </div>
                    <div className="p-2 text-center">
                        <CashIcon className="h-7 w-7 text-green-600 mx-auto mb-1"/>
                        <p className="text-sm font-medium text-gray-500">{texts.totalComm}</p>
                        <p className="text-xl font-bold text-gray-900">{kpiData.totalComm}</p>
                    </div>
                    <div className="p-2 text-center">
                        <ScaleIcon className="h-7 w-7 text-green-600 mx-auto mb-1"/>
                        <p className="text-sm font-medium text-gray-500">{texts.avgRate}</p>
                        <p className="text-xl font-bold text-gray-900">{kpiData.avgRate}</p>
                    </div>
                    <div className="p-2 text-center">
                        <SparklesIcon className="h-7 w-7 text-green-600 mx-auto mb-1"/>
                        <p className="text-sm font-medium text-gray-500">{texts.topPerformer}</p>
                        <p className="text-xl font-bold text-gray-900 truncate" title={kpiData.topPerformer.name}>{kpiData.topPerformer.value}</p>
                    </div>
                </div>
            </div>

            {/* Toolbar */}
            <div className="mb-6 flex flex-col md:flex-row gap-4">
                <div className="relative flex-grow">
                    <Input 
                        placeholder={texts.searchPlaceholder} 
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        className="pl-10"
                    />
                    <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
                </div>
                <div className="flex items-center gap-4 flex-shrink-0">
                     <div className="flex items-center gap-2">
                        <label htmlFor="products-per-page" className="text-sm font-medium text-gray-700 whitespace-nowrap">{texts.productsPerPage}:</label>
                        <Select id="products-per-page" value={productsPerPage} onChange={(e) => setProductsPerPage(Number(e.target.value))}>
                            <option value={10}>10</option>
                            <option value={20}>20</option>
                            <option value={50}>50</option>
                            <option value={100}>100</option>
                        </Select>
                    </div>
                    <div className="flex items-center gap-2">
                        <label htmlFor="sort-by" className="text-sm font-medium text-gray-700 whitespace-nowrap">{texts.sortBy}:</label>
                        <Select id="sort-by" value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                            <option value="productName-asc">{language === 'Việt Nam' ? 'Tên sản phẩm (A-Z)' : 'Product Name (A-Z)'}</option>
                            <option value="productName-desc">{language === 'Việt Nam' ? 'Tên sản phẩm (Z-A)' : 'Product Name (Z-A)'}</option>
                            <option value="price-desc">{language === 'Việt Nam' ? 'Giá (Cao-Thấp)' : 'Price (High-Low)'}</option>
                            <option value="price-asc">{language === 'Việt Nam' ? 'Giá (Thấp-Cao)' : 'Price (Low-High)'}</option>
                            <option value="commissionValue-desc">{language === 'Việt Nam' ? 'Hoa hồng (Cao-Thấp)' : 'Commission (High-Low)'}</option>
                            <option value="commissionValue-asc">{language === 'Việt Nam' ? 'Hoa hồng (Thấp-Cao)' : 'Commission (Low-High)'}</option>
                        </Select>
                    </div>
                </div>
            </div>

            <main className="flex-grow overflow-y-auto -mx-2 p-2 sm:p-4 lg:p-6 flex flex-col">
                {(affiliateLinks.length > 0 || isAddingNewLink) ? (
                    <>
                        <div className="flex-grow">
                            {(displayLinks.length > 0 || isAddingNewLink) ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                                     {isAddingNewLink && (
                                        <ProductCard
                                            isNew
                                            link={{...emptyLink, id: 'new'}}
                                            onSave={handleSaveNew}
                                            onCancel={() => setIsAddingNewLink(false)}
                                            formatCurrency={formatCurrency}
                                            language={language}
                                        />
                                    )}
                                    {displayLinks.map(link => (
                                        <ProductCard 
                                            key={link.id}
                                            link={link}
                                            onSave={onSaveLink}
                                            onDelete={() => handleDelete(link.id)}
                                            formatCurrency={formatCurrency}
                                            language={language}
                                            onGenerateIdeas={handleGenerateIdeas}
                                        />
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-20">
                                    <SearchIcon className="mx-auto h-16 w-16 text-gray-400" />
                                    <h3 className="mt-2 text-2xl font-bold font-sans text-gray-900">{texts.noResults}</h3>
                                    <p className="mt-1 text-md text-gray-500 font-serif">{texts.noResultsDesc}</p>
                                </div>
                            )}
                        </div>
                        {totalPages > 1 && (
                            <div className="mt-6 flex justify-center items-center gap-4 pt-4 border-t border-gray-200">
                                <Button
                                    onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                                    disabled={currentPage === 1}
                                    variant="outline"
                                >
                                    {language === 'Việt Nam' ? 'Trước' : 'Previous'}
                                </Button>
                                <span className="text-sm font-medium text-gray-700">
                                    {language === 'Việt Nam' ? `Trang ${currentPage} / ${totalPages}` : `Page ${currentPage} of ${totalPages}`}
                                </span>
                                <Button
                                    onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                                    disabled={currentPage === totalPages}
                                    variant="outline"
                                >
                                    {language === 'Việt Nam' ? 'Sau' : 'Next'}
                                </Button>
                            </div>
                        )}
                    </>
                ) : (
                    <div className="text-center py-20 bg-white rounded-xl border-2 border-dashed border-gray-300">
                        <LinkIcon className="mx-auto h-16 w-16 text-gray-400" />
                        <h3 className="mt-2 text-2xl font-bold font-sans text-gray-900">{texts.noLinks}</h3>
                        <p className="mt-1 text-md text-gray-500 font-serif">{texts.addFirstLink}</p>
                    </div>
                )}
            </main>
        </div>
    );
};

export default AffiliateVaultDisplay;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AffiliateVaultDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableLoadModal.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';
import { Button } from './ui';
import { AirtableIcon } from './icons';
import { listBrandsFromAirtable } from '../services/databaseService';

interface AirtableLoadModalProps {
  isOpen: boolean;
  onClose: () => void;
  onLoadProject: (brandId: string) => Promise<void>;
  language: string;
}

const AirtableLoadModal: React.FC<AirtableLoadModalProps> = ({ isOpen, onClose, onLoadProject, language }) => {
  const [brands, setBrands] = useState<{id: string, name: string}[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const T = {
      'Việt Nam': {
          title: "Tải từ Airtable",
          subtitle: "Chọn một thương hiệu để tải. Thao tác này sẽ tải bộ thương hiệu và danh sách các kế hoạch truyền thông của nó.",
          noProjects: "Không tìm thấy dự án nào trong bảng 'Brand Kit'.",
          loadButton: "Tải Thương hiệu",
          loadingButton: "Đang tải...",
          cancelButton: "Đóng",
          errorTitle: "Lỗi Kết nối",
          envNotSetMessage: "Tích hợp Airtable chưa được cấu hình. Vui lòng cung cấp thông tin đăng nhập trong bảng Tích hợp.",
      },
      'English': {
          title: "Load from Airtable",
          subtitle: "Select a brand to load. This will load the brand kit and its list of media plans.",
          noProjects: "No projects found in the 'Brand Kit' table.",
          loadButton: "Load Brand",
          loadingButton: "Loading...",
          cancelButton: "Close",
          errorTitle: "Connection Error",
          envNotSetMessage: "Airtable integration is not configured. Please provide credentials in the Integrations panel.",
      }
  };
  const texts = (T as any)[language] || T['English'];

  useEffect(() => {
    if (!isOpen) {
        return;
    }

    const fetchBrands = async () => {
        setIsLoading(true);
        setError(null);
        try {
            
            const brandList = await listBrandsFromAirtable();
            setBrands(brandList);

        } catch (err) {
            setError(err instanceof Error ? err.message : "An unknown error occurred while fetching brands.");
        } finally {
            setIsLoading(false);
        }
    };

    fetchBrands();

  }, [isOpen, language, texts.envNotSetMessage]);


  const handleSelectBrand = async (brand: {id: string, name: string}) => {
    setIsLoading(true);
    setError(null);
    try {
        await onLoadProject(brand.id);
    } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load project.");
        setIsLoading(false);
    }
  }

  const resetAndClose = () => {
    setBrands([]);
    setError(null);
    onClose();
  };
  
  if (!isOpen) return null;

  const hasCredentials = !!(window as any).process.env.AIRTABLE_PAT && !!(window as any).process.env.AIRTABLE_BASE_ID;
  
  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={resetAndClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl p-8 border border-gray-200 m-4 transform transition-all" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-start mb-6">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
              <AirtableIcon className="h-8 w-8 text-sky-500" />
              {texts.title}
            </h2>
            <p className="text-gray-500 mt-1 font-serif">{texts.subtitle}</p>
          </div>
          <button onClick={resetAndClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
        </div>

        {error && (
            <div className="bg-red-50 border border-red-300 text-red-800 px-4 py-3 rounded-lg mb-4 relative" role="alert">
                <strong className="font-bold">{texts.errorTitle}:</strong>
                <span className="block sm:inline ml-2">{error}</span>
            </div>
        )}

        {isLoading ? (
            <div className="flex justify-center items-center h-40"><div className="w-8 h-8 border-2 border-t-transparent border-brand-green rounded-full animate-spin"></div></div>
        ) : hasCredentials && !error ? (
            <div>
                {brands.length > 0 ? (
                    <ul className="space-y-2 max-h-80 overflow-y-auto">
                        {brands.map(brand => (
                            <li key={brand.id} className="flex justify-between items-center bg-gray-50 p-3 rounded-lg border border-gray-200">
                                <span className="text-gray-800 font-medium">{brand.name}</span>
                                <Button onClick={() => handleSelectBrand(brand)} disabled={isLoading} variant="secondary" className="text-sm py-1 px-3">
                                    {isLoading ? texts.loadingButton : texts.loadButton}
                                </Button>
                            </li>
                        ))}
                    </ul>
                ) : <p className="text-center text-gray-500 py-10">{texts.noProjects}</p>}
                <div className="flex justify-end pt-4 mt-4 border-t border-gray-200">
                    <Button type="button" onClick={resetAndClose} variant="tertiary">{texts.cancelButton}</Button>
                </div>
            </div>
        ) : (
             <div className="flex justify-end pt-4 mt-4 border-t border-gray-200">
                <Button type="button" onClick={resetAndClose} variant="tertiary">{texts.cancelButton}</Button>
            </div>
        )}
      </div>
    </div>
  );
};

export default AirtableLoadModal;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableLoadModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableModal.tsx ---\n
import React, { useState } from 'react';
import { Button, TextArea } from './ui';
import { SparklesIcon } from './icons';

interface NewProjectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onGenerateProfile: (idea: string) => void;
  isLoading: boolean;
  language: string;
}

const NewProjectModal: React.FC<NewProjectModalProps> = ({ isOpen, onClose, onGenerateProfile, isLoading, language }) => {
  const [idea, setIdea] = useState('');

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (idea.trim()) {
      onGenerateProfile(idea);
    }
  };

  const texts = {
    'Việt Nam': {
      title: "Tạo dự án mới",
      subtitle: "Bắt đầu với ý tưởng kinh doanh của bạn. Chúng tôi sẽ tạo ra hồ sơ thương hiệu từ đó.",
      placeholder: "Vd: Một hộp đăng ký hàng tháng cho đồ chơi chó thân thiện với môi trường, được sản xuất tại địa phương và bền vững.",
      generateButton: 'Tạo hồ sơ thương hiệu',
      generateButtonLoading: 'Đang tạo...',
      cancel: "Hủy bỏ",
    },
    'English': {
      title: "Create New Project",
      subtitle: "Start with your business idea. We'll generate a brand profile from it.",
      placeholder: 'e.g., A subscription box for eco-friendly dog toys, locally made and sustainable.',
      generateButton: 'Generate Brand Profile',
      generateButtonLoading: 'Generating...',
      cancel: "Cancel",
    }
  };
  const currentTexts = (texts as any)[language] || texts['English'];

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl p-8 border border-gray-200 m-4" onClick={(e) => e.stopPropagation()}>
        <h2 className="text-2xl font-bold text-gray-900">{currentTexts.title}</h2>
        <p className="text-gray-500 font-serif mt-1">{currentTexts.subtitle}</p>
        <form onSubmit={handleSubmit} className="mt-6 space-y-4">
          <TextArea
            id="idea"
            name="idea"
            value={idea}
            onChange={(e) => setIdea(e.target.value)}
            required
            placeholder={currentTexts.placeholder}
            rows={4}
            className="text-lg p-4"
          />
          <div className="flex justify-end gap-4 pt-4 border-t border-gray-200">
            <Button type="button" variant="tertiary" onClick={onClose} disabled={isLoading}>
              {currentTexts.cancel}
            </Button>
            <Button type="submit" disabled={isLoading || !idea.trim()} className="flex items-center justify-center gap-2">
                {isLoading ? (
                    currentTexts.generateButtonLoading
                ) : (
                    <>
                        <SparklesIcon className="h-5 w-5" />
                        {currentTexts.generateButton}
                    </>
                )}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default NewProjectModal;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AirtableModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AssetDisplay.tsx ---\n
import React, { useState, useEffect, useRef } from 'react';
import type { GeneratedAssets, BrandFoundation, CoreMediaAssets, ColorInfo, LogoConcept, ColorPalette, FontRecommendations, UnifiedProfileAssets } from '../types';
import { Section, CopyableText, Button, HoverCopyWrapper } from './ui';
import { DownloadIcon, SparklesIcon, ArchiveIcon, UploadIcon } from './icons';

interface AssetDisplayProps {
  assets: GeneratedAssets;
  onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9") => void;
  onSetImage: (dataUrl: string, key: string) => void;
  generatedImages: Record<string, string>;
  isGeneratingImage: (key: string) => boolean;
  language: string;
  onExport: () => void;
  isExporting: boolean;
}

const getNavItems = (language: string) => {
    const texts = {
        'Việt Nam': [
            { id: 'foundation', label: 'Nền tảng Thương hiệu' },
            { id: 'core', label: 'Tài sản Cốt lõi' },
            { id: 'unified', label: 'Hồ sơ Thống nhất' },
        ],
        'English': [
            { id: 'foundation', label: 'Brand Foundation' },
            { id: 'core', label: 'Core Assets' },
            { id: 'unified', label: 'Unified Profile' },
        ]
    };
    return (texts as any)[language] || texts['English'];
}


const AssetDisplay: React.FC<AssetDisplayProps> = (props) => {
    const { assets, onGenerateImage, onSetImage, generatedImages, isGeneratingImage, language, onExport, isExporting } = props;
    const [activeSection, setActiveSection] = useState('foundation');

    const NAV_ITEMS = getNavItems(language);
    const mainContentRef = useRef<HTMLDivElement>(null);


    const handleNavClick = (id: string) => {
        setActiveSection(id);
        const element = document.getElementById(id);
        const headerOffset = 120; // Height of sticky header + subnav
        if (element && mainContentRef.current) {
            const elementPosition = element.offsetTop;
            mainContentRef.current.scrollTo({
                top: elementPosition - headerOffset,
                behavior: 'smooth'
            });
        }
    };
    
    // Logic to update activeSection on scroll
    useEffect(() => {
        const mainEl = mainContentRef.current;
        if (!mainEl) return;

        const handleScroll = () => {
            const scrollPosition = mainEl.scrollTop + 150;
            const sections = NAV_ITEMS.map(item => document.getElementById(item.id));
            
            let currentSection = '';
            for (const section of sections) {
                if (section && section.offsetTop <= scrollPosition) {
                    currentSection = section.id;
                }
            }
            if (currentSection) {
                 setActiveSection(currentSection);
            }
        };

        mainEl.addEventListener('scroll', handleScroll);
        return () => mainEl.removeEventListener('scroll', handleScroll);
    }, [NAV_ITEMS]);

    const imageGeneratorTexts = {
        'Việt Nam': { generating: 'Đang tạo...', generate: 'Tạo ảnh', prompt: 'Prompt ảnh:' },
        'English': { generating: 'Generating...', generate: 'Generate Image', prompt: 'Image Prompt:' }
    }
    const currentImgGenTexts = (imageGeneratorTexts as any)[language] || imageGeneratorTexts['English'];

    const exportTexts = {
        'Việt Nam': { export: 'Xuất Bộ Thương hiệu', exporting: 'Đang xuất...' },
        'English': { export: 'Export Brand Kit', exporting: 'Exporting...' }
    };
    const currentExportTexts = (exportTexts as any)[language] || exportTexts['English'];
    
    const sharedImageProps = { onGenerateImage, onSetImage, generatedImages, isGeneratingImage, texts: currentImgGenTexts };

    return (
        <div className="flex flex-col md:flex-row h-[calc(100vh-112px)]">
            <aside className="hidden md:flex w-64 bg-white md:sticky top-0 p-6 border-r border-gray-200 flex-col shrink-0">
                <div className="flex-grow">
                    <h2 className="text-base font-bold text-gray-900 mb-4">Brand Kit Navigation</h2>
                    <nav>
                        <ul>
                            {NAV_ITEMS.map(({id, label}) => (
                                 <li key={id} className="mb-1">
                                    <a
                                        href={`#${id}`}
                                        onClick={(e) => { e.preventDefault(); handleNavClick(id); }}
                                        className={`flex items-center gap-3 px-3 py-2 rounded-md transition-colors text-sm font-medium ${activeSection === id ? 'bg-green-50 text-brand-green' : 'text-gray-600 hover:bg-gray-100'}`}
                                    >
                                        {label}
                                    </a>
                                </li>
                            ))}
                        </ul>
                    </nav>
                </div>
                <div className="mt-auto pt-4">
                    <Button onClick={onExport} disabled={isExporting} variant="secondary" className="w-full flex items-center justify-center gap-2">
                        {isExporting ? (
                            <>
                                <div className="w-5 h-5 border-2 border-t-transparent border-brand-green rounded-full animate-spin"></div>
                                {currentExportTexts.exporting}
                            </>
                        ) : (
                            <>
                                <ArchiveIcon className="h-5 w-5" />
                                {currentExportTexts.export}
                            </>
                        )}
                    </Button>
                </div>
            </aside>
            <main ref={mainContentRef} className="flex-1 overflow-y-auto" style={{ scrollPaddingTop: '80px' }}>
                <div className="md:hidden sticky top-0 bg-white/80 backdrop-blur-lg z-10 border-b border-gray-200 p-3">
                    <select 
                        id="asset-nav-mobile"
                        className="w-full bg-white border border-gray-300 rounded-md py-2 px-3 text-gray-900 focus:outline-none focus:ring-2 focus:ring-brand-green focus:border-transparent"
                        value={activeSection} 
                        onChange={e => handleNavClick(e.target.value)}
                    >
                        {NAV_ITEMS.map(({id, label}) => <option key={id} value={id}>{label}</option>)}
                    </select>
                </div>
                <div className="max-w-4xl mx-auto p-4 sm:p-6 lg:p-10">
                    <BrandFoundationSection assets={assets.brandFoundation} language={language} />
                    <CoreAssetsSection assets={assets.coreMediaAssets} language={language} {...sharedImageProps} />
                    <UnifiedProfileAssetsSection assets={assets.unifiedProfileAssets} language={language} {...sharedImageProps}/>
                </div>
            </main>
        </div>
    );
};

interface ImageGeneratorProps {
    mediaPrompt: string | string[];
    imageKey: string;
    aspectRatio?: "1:1" | "16:9";
    onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9") => void;
    onSetImage: (dataUrl: string, key: string) => void;
    generatedImages: Record<string, string>;
    isGenerating: boolean;
    texts: { generating: string; generate: string; prompt: string };
    buttonText?: string;
};

const ImageGenerator: React.FC<ImageGeneratorProps> = ({ mediaPrompt, imageKey, aspectRatio = "1:1", onGenerateImage, onSetImage, generatedImages, isGenerating, texts, buttonText = "" }) => { 
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleFile = (file: File | null) => {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            if (e.target?.result) {
                onSetImage(e.target.result as string, imageKey);
            }
        };
        reader.readAsDataURL(file);
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        handleFile(e.target.files?.[0] || null);
    };

    const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.clipboardData.files.length > 0) {
            handleFile(e.clipboardData.files[0]);
        }
    };

    const generatedImage = generatedImages[imageKey];

    if (isGenerating) {
        return (
            <div className="w-full bg-gray-100 flex flex-col items-center justify-center rounded-lg border border-gray-200" style={{ aspectRatio, minHeight: '150px' }}>
                <div className="w-8 h-8 border-2 border-t-transparent border-brand-green rounded-full animate-spin"></div>
                <span className="text-sm mt-2 text-gray-500">{texts.generating}</span>
            </div>
        );
    }

    if (generatedImage) {
        return (
            <div className="relative group rounded-lg overflow-hidden" onPaste={handlePaste} tabIndex={0}>
                <img src={generatedImage} alt={Array.isArray(mediaPrompt) ? mediaPrompt.join(", ") : mediaPrompt} className="w-full object-cover" style={{ aspectRatio }}/>
                <div className="absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                    <div className="flex flex-col gap-2 items-center p-2">
                        <Button onClick={() => onGenerateImage(Array.isArray(mediaPrompt) ? mediaPrompt[0] : mediaPrompt, imageKey, aspectRatio)} disabled={isGenerating} variant="primary" className="w-full flex items-center justify-center gap-2 text-xs py-1 px-2">
                            <SparklesIcon className="h-4 w-4" /> Regenerate
                        </Button>
                        <Button onClick={() => fileInputRef.current?.click()} variant="secondary" className="w-full flex items-center justify-center gap-2 text-xs py-1 px-2">
                           <UploadIcon className="h-4 w-4" /> Change Image
                        </Button>
                    </div>
                     <a href={generatedImage} download={`${imageKey}.jpg`} className="absolute bottom-2 right-2 bg-gray-800 text-white p-2 rounded-full hover:bg-black transition-colors">
                       <DownloadIcon className="h-4 w-4"/>
                    </a>
                    <input type="file" ref={fileInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                </div>
            </div>
        )
    }

    return (
        <div className="bg-white border border-gray-200 p-4 rounded-lg mt-2" onPaste={handlePaste} tabIndex={0}>
            <HoverCopyWrapper textToCopy={Array.isArray(mediaPrompt) ? mediaPrompt.join("\n") : mediaPrompt}>
                <h5 className="font-semibold font-sans text-gray-700 text-sm">{texts.prompt}</h5>
                {Array.isArray(mediaPrompt) ? (
                    mediaPrompt.map((p, idx) => (
                        <p key={idx} className="text-gray-500 italic mb-1 text-sm font-serif">"{p}"</p>
                    ))
                ) : (
                    <p className="text-gray-500 italic mb-3 text-sm font-serif">"{mediaPrompt}"</p>
                )}
            </HoverCopyWrapper>
            <div className="space-y-2">
                <Button onClick={() => onGenerateImage(Array.isArray(mediaPrompt) ? mediaPrompt[0] : mediaPrompt, imageKey, aspectRatio)} disabled={isGenerating} className="w-full flex items-center justify-center gap-2">
                    <SparklesIcon /> {buttonText || texts.generate}
                </Button>
                <div 
                    className="relative w-full text-center border-2 border-dashed border-gray-300 rounded-lg p-4 hover:border-brand-green transition-colors cursor-pointer"
                    onClick={() => fileInputRef.current?.click()}
                >
                    <UploadIcon className="mx-auto h-8 w-8 text-gray-400" />
                    <p className="text-xs text-gray-500 mt-1">Click to upload or paste image</p>
                </div>
                <input type="file" ref={fileInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
            </div>
        </div>
    );
};

interface ImageGenSectionProps {
  onGenerateImage: AssetDisplayProps['onGenerateImage'];
  onSetImage: AssetDisplayProps['onSetImage'];
  generatedImages: AssetDisplayProps['generatedImages'];
  isGeneratingImage: AssetDisplayProps['isGeneratingImage'];
  language: string;
  texts: { generating: string; generate: string; prompt: string; };
}

const BrandFoundationSection: React.FC<{ assets: BrandFoundation, language: string }> = ({ assets, language }) => {
    const texts = {
        'Việt Nam': { title: 'Nền tảng Thương hiệu', brandName: 'Tên thương hiệu', mission: 'Sứ mệnh', usp: 'USP', values: 'Giá trị', keyMessaging: 'Thông điệp Chính', targetAudience: 'Đối tượng mục tiêu', personality: 'Tính cách' },
        'English': { title: 'Brand Foundation', brandName: 'Brand Name', mission: 'Mission', usp: 'USP', values: 'Values', keyMessaging: 'Key Messaging', targetAudience: 'Target Audience', personality: 'Personality' }
    };
    const currentTexts = (texts as any)[language] || texts['English'];

    return (
    <Section title={currentTexts.title} id="foundation">
        <HoverCopyWrapper textToCopy={assets.brandName}><p><strong className="font-sans text-gray-800">{currentTexts.brandName}:</strong> {assets.brandName}</p></HoverCopyWrapper>
        <HoverCopyWrapper textToCopy={assets.mission}><p><strong className="font-sans text-gray-800">{currentTexts.mission}:</strong> {assets.mission}</p></HoverCopyWrapper>
        <HoverCopyWrapper textToCopy={assets.usp}><p><strong className="font-sans text-gray-800">{currentTexts.usp}:</strong> {assets.usp}</p></HoverCopyWrapper>
        <HoverCopyWrapper textToCopy={assets.targetAudience}><p><strong className="font-sans text-gray-800">{currentTexts.targetAudience}:</strong> {assets.targetAudience}</p></HoverCopyWrapper>
        <HoverCopyWrapper textToCopy={assets.personality}><p><strong className="font-sans text-gray-800">{currentTexts.personality}:</strong> {assets.personality}</p></HoverCopyWrapper>
        
        <HoverCopyWrapper textToCopy={(assets.values || []).join(', ')}>
            <div className="mt-4"><strong className="font-sans text-gray-800">{currentTexts.values}:</strong><div className="flex flex-wrap gap-2 mt-1">{(assets.values || []).map(v => <span key={v} className="bg-gray-100 text-gray-800 px-3 py-1 rounded-full text-sm font-sans">{v}</span>)}</div></div>
        </HoverCopyWrapper>

        <HoverCopyWrapper textToCopy={(assets.keyMessaging || []).join('\n')}>
            <div className="mt-4"><strong className="font-sans text-gray-800">{currentTexts.keyMessaging}:</strong><ul className="list-disc list-inside mt-1 space-y-2">{(assets.keyMessaging || []).map(m => <li key={m}>{m}</li>)}</ul></div>
        </HoverCopyWrapper>
    </Section>
)};

const CoreAssetsSection: React.FC<{ assets: CoreMediaAssets } & ImageGenSectionProps> = ({ assets, language, ...imgProps }) => {
    const texts = {
        'Việt Nam': { title: 'Tài sản Cốt lõi', logoConcepts: 'Ý tưởng Logo', colorPalette: 'Bảng màu', fontRecs: 'Gợi ý Phông chữ', headlines: 'Tiêu đề', body: 'Nội dung' },
        'English': { title: 'Core Assets', logoConcepts: 'Logo Concepts', colorPalette: 'Color Palette', fontRecs: 'Font Recommendations', headlines: 'Headlines', body: 'Body' }
    };
    const currentTexts = (texts as any)[language] || texts['English'];

    return (
    <Section title={currentTexts.title} id="core">
        <h4 className="text-xl font-bold font-sans text-gray-900 mb-2">{currentTexts.logoConcepts}</h4>
        <div className="grid md:grid-cols-2 gap-6">
            {(assets.logoConcepts || []).map((logo) => {
                const imageKey = logo.imageKey;
                return <ImageGenerator key={logo.id} mediaPrompt={logo.prompt} imageKey={imageKey} {...imgProps} isGenerating={imgProps.isGeneratingImage(imageKey)} />
            })}
        </div>
        
        <h4 className="text-xl font-bold font-sans text-gray-900 my-6">{currentTexts.colorPalette}</h4>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {Object.entries(assets.colorPalette || {}).map(([key, color]) => (
                <div key={key}>
                    <div className="w-full h-20 rounded-lg border border-gray-200" style={{ backgroundColor: (color as ColorInfo).hex }}></div>
                    <p className="text-center mt-2 font-semibold font-sans text-gray-800">{(color as ColorInfo).name}</p>
                    <p className="text-center font-sans text-gray-500 text-sm">{(color as ColorInfo).hex}</p>
                </div>
            ))}
        </div>

        <h4 className="text-xl font-bold font-sans text-gray-900 my-6">{currentTexts.fontRecs}</h4>
        <p><strong className="font-sans text-gray-800">{currentTexts.headlines}:</strong> {assets.fontRecommendations?.headlines?.name} ({assets.fontRecommendations?.headlines?.weight})</p>
        <p><strong className="font-sans text-gray-800">{currentTexts.body}:</strong> {assets.fontRecommendations?.body?.name} ({assets.fontRecommendations?.body?.weight})</p>
    </Section>
)};

const UnifiedProfileAssetsSection: React.FC<{ assets: UnifiedProfileAssets } & ImageGenSectionProps> = ({ assets, language, ...imgProps }) => {
    const texts = {
        'Việt Nam': { title: 'Hồ sơ Thống nhất', accountName: 'Tên tài khoản', username: 'Tên người dùng', profilePic: 'Ảnh đại diện thống nhất', cover: 'Ảnh bìa thống nhất' },
        'English': { title: 'Unified Profile Assets', accountName: 'Account Name', username: 'Username', profilePic: 'Unified Profile Picture', cover: 'Unified Cover Photo' }
    };
    const currentTexts = (texts as any)[language] || texts['English'];
    
    const profileImageKey = assets.profilePictureImageKey;
    const coverImageKey = assets.coverPhotoImageKey;

    return (
        <Section title={currentTexts.title} id="unified">
            <HoverCopyWrapper textToCopy={assets.accountName}><p><strong className="font-sans text-gray-800">{currentTexts.accountName}:</strong> {assets.accountName}</p></HoverCopyWrapper>
            <strong className="font-sans text-gray-800">{currentTexts.username}:</strong> <CopyableText text={assets.username} />
             <div className="grid md:grid-cols-2 gap-6 mt-4">
                <div>
                    <h4 className="text-lg font-bold font-sans text-gray-900 mb-1">{currentTexts.profilePic}</h4>
                    <ImageGenerator mediaPrompt={assets.profilePicturePrompt} imageKey={profileImageKey} {...imgProps} isGenerating={imgProps.isGeneratingImage(profileImageKey)} />
                </div>
                <div>
                    <h4 className="text-lg font-bold font-sans text-gray-900 mb-1">{currentTexts.cover}</h4>
                    <HoverCopyWrapper textToCopy={assets.coverPhoto?.designConcept}><p className="font-sans text-sm text-gray-500 mb-2">{assets.coverPhoto?.designConcept}</p></HoverCopyWrapper>
                    <ImageGenerator mediaPrompt={assets.coverPhoto?.prompt} imageKey={coverImageKey} aspectRatio="16:9" {...imgProps} isGenerating={imgProps.isGeneratingImage(coverImageKey)} />
                </div>
            </div>
        </Section>
    );
};

export default AssetDisplay;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\AssetDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BrandProfiler.tsx ---\nimport React, { useState, useEffect } from 'react';
import type { BrandInfo } from '../types';
import { Button, Input, TextArea } from './ui';
import { SparklesIcon } from './icons';

interface BrandProfilerProps {
  initialBrandInfo: BrandInfo;
  onGenerate: (brandInfo: BrandInfo) => void;
  isLoading: boolean;
  onBack: () => void;
  language: string;
}

const BrandProfiler: React.FC<BrandProfilerProps> = ({ initialBrandInfo, onGenerate, isLoading, onBack, language }) => {
  const [brandInfo, setBrandInfo] = useState<BrandInfo>(initialBrandInfo);

  useEffect(() => {
    setBrandInfo(initialBrandInfo);
  }, [initialBrandInfo]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setBrandInfo(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onGenerate(brandInfo);
  };

  const texts = {
      'Việt Nam': {
          title: 'Xem lại Hồ sơ Thương hiệu của bạn',
          subtitle: 'Tinh chỉnh các chi tiết do AI tạo ra bên dưới để đảm bảo chúng hoàn toàn phù hợp với tầm nhìn của bạn.',
          nameLabel: 'Tên thương hiệu',
          missionLabel: 'Sứ mệnh thương hiệu',
          valuesLabel: 'Giá trị cốt lõi (phân tách bằng dấu phẩy)',
          audienceLabel: 'Đối tượng mục tiêu',
          personalityLabel: 'Tính cách thương hiệu',
          backButton: 'Quay lại',
          generateButton: 'Tạo tài sản thương hiệu',
          generateButtonLoading: 'Đang tạo...'
      },
      'English': {
          title: 'Review Your Brand Profile',
          subtitle: 'Tweak the AI-generated details below to ensure they perfectly match your vision.',
          nameLabel: 'Brand Name',
          missionLabel: 'Brand Mission',
          valuesLabel: 'Core Values (comma-separated)',
          audienceLabel: 'Target Audience',
          personalityLabel: 'Brand Personality',
          backButton: 'Go Back',
          generateButton: 'Generate Brand Assets',
          generateButtonLoading: 'Generating...'
      }
  }

  const currentTexts = (texts as any)[language] || texts['English'];

  return (
    <div className="min-h-screen bg-white flex flex-col items-center justify-center p-4">
      <div className="w-full max-w-2xl mx-auto">
        <div className="text-left mb-10">
            <h1 className="text-4xl font-bold font-sans text-gray-900">{currentTexts.title}</h1>
            <p className="text-gray-500 mt-2 text-lg font-serif">{currentTexts.subtitle}</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-8">
            <div>
              <label htmlFor="name" className="block text-sm font-semibold text-gray-700 mb-1">{currentTexts.nameLabel}</label>
              <Input id="name" name="name" value={brandInfo.name} onChange={handleChange} required placeholder="e.g., Nova Sneakers" />
            </div>
            <div>
              <label htmlFor="mission" className="block text-sm font-semibold text-gray-700 mb-1">{currentTexts.missionLabel}</label>
              <TextArea id="mission" name="mission" value={brandInfo.mission} onChange={handleChange} required placeholder="What is your brand's purpose?" />
            </div>
            <div>
              <label htmlFor="values" className="block text-sm font-semibold text-gray-700 mb-1">{currentTexts.valuesLabel}</label>
              <Input id="values" name="values" value={brandInfo.values} onChange={handleChange} required placeholder="e.g., Innovation, Quality, Community" />
            </div>
            <div>
              <label htmlFor="audience" className="block text-sm font-semibold text-gray-700 mb-1">{currentTexts.audienceLabel}</label>
              <TextArea id="audience" name="audience" value={brandInfo.audience} onChange={handleChange} required placeholder="Who are you trying to reach?" />
            </div>
            <div>
              <label htmlFor="personality" className="block text-sm font-semibold text-gray-700 mb-1">{currentTexts.personalityLabel}</label>
              <Input id="personality" name="personality" value={brandInfo.personality} onChange={handleChange} required placeholder="e.g., Playful, Professional, Edgy" />
            </div>
            
            <div className="flex flex-col sm:flex-row gap-4 pt-4 border-t border-gray-200">
                <Button type="button" onClick={onBack} variant="tertiary" className="w-full sm:w-auto">
                    {currentTexts.backButton}
                </Button>
                <Button type="submit" disabled={isLoading} variant="primary" className="w-full flex items-center justify-center gap-2">
                    {isLoading ? (
                        currentTexts.generateButtonLoading
                    ) : (
                        <>
                            <SparklesIcon className="h-5 w-5" />
                            {currentTexts.generateButton}
                        </>
                    )}
                </Button>
            </div>
        </form>
      </div>
    </div>
  );
};

export default BrandProfiler;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BrandProfiler.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BulkScheduleModal.tsx ---\n
import React, { useState } from 'react';
import { Button, Input } from './ui';
import { CalendarIcon } from './icons';

interface BulkScheduleModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSchedule: (startDate: string, intervalDays: number, intervalHours: number, intervalMinutes: number) => void;
  isScheduling: boolean;
  selectedCount: number;
  language: string;
}

const BulkScheduleModal: React.FC<BulkScheduleModalProps> = ({
  isOpen,
  onClose,
  onSchedule,
  isScheduling,
  selectedCount,
  language
}) => {
  const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
  const [time, setTime] = useState(new Date().toTimeString().substring(0, 5));
  const [intervalDays, setIntervalDays] = useState(1);
  const [intervalHours, setIntervalHours] = useState(0);
  const [intervalMinutes, setIntervalMinutes] = useState(0);

  if (!isOpen) return null;

  const handleSchedule = () => {
    const combinedDateTime = new Date(`${date}T${time}:00`);
    onSchedule(combinedDateTime.toISOString(), intervalDays, intervalHours, intervalMinutes);
  };
  
  const T = {
    'Việt Nam': {
        title: 'Lên lịch hàng loạt',
        subtitle: `Bạn sắp xếp lịch cho ${selectedCount} bài đăng. Đặt thời gian bắt đầu và khoảng cách giữa các bài đăng.`,
        start_date: 'Ngày bắt đầu',
        start_time: 'Thời gian bắt đầu',
        interval: 'Khoảng cách giữa các bài đăng',
        days: 'Ngày',
        hours: 'Giờ',
        minutes: 'Phút',
        cancel: 'Hủy bỏ',
        schedule: 'Lên lịch tất cả',
        scheduling: 'Đang lên lịch...',
    },
    'English': {
        title: 'Bulk Schedule Posts',
        subtitle: `You are scheduling ${selectedCount} posts. Set the start time and the interval between them.`,
        start_date: 'Start Date',
        start_time: 'Start Time',
        interval: 'Interval Between Posts',
        days: 'Days',
        hours: 'Hours',
        minutes: 'Minutes',
        cancel: 'Cancel',
        schedule: 'Schedule All',
        scheduling: 'Scheduling...',
    }
  };
  const texts = (T as any)[language] || T['English'];

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-lg p-8 border border-gray-200 m-4" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-start">
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3"><CalendarIcon className="h-7 w-7 text-brand-green"/> {texts.title}</h2>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
        </div>
        <p className="text-gray-500 font-serif mt-2">{texts.subtitle}</p>
        
        <div className="mt-6 space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">{texts.start_date} & {texts.start_time}</label>
            <div className="grid grid-cols-2 gap-4 mt-1">
                <Input type="date" value={date} onChange={(e) => setDate(e.target.value)} />
                <Input type="time" value={time} onChange={(e) => setTime(e.target.value)} />
            </div>
          </div>
          <div>
              <label className="block text-sm font-medium text-gray-700">{texts.interval}</label>
              <div className="grid grid-cols-3 gap-4 mt-1">
                  <div>
                      <Input type="number" min="0" value={intervalDays} onChange={(e) => setIntervalDays(Number(e.target.value) || 0)} />
                      <span className="text-xs text-gray-500 ml-1">{texts.days}</span>
                  </div>
                  <div>
                      <Input type="number" min="0" max="23" value={intervalHours} onChange={(e) => setIntervalHours(Number(e.target.value) || 0)} />
                      <span className="text-xs text-gray-500 ml-1">{texts.hours}</span>
                  </div>
                   <div>
                      <Input type="number" min="0" max="59" value={intervalMinutes} onChange={(e) => setIntervalMinutes(Number(e.target.value) || 0)} />
                      <span className="text-xs text-gray-500 ml-1">{texts.minutes}</span>
                  </div>
              </div>
          </div>
        </div>

        <div className="flex justify-end gap-4 pt-6 mt-6 border-t border-gray-200">
          <Button type="button" onClick={onClose} variant="tertiary" disabled={isScheduling}>
            {texts.cancel}
          </Button>
          <Button onClick={handleSchedule} disabled={isScheduling}>
            {isScheduling ? (
              <>
                <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin mr-2"></div>
                {texts.scheduling}
              </>
            ) : (
              texts.schedule
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default BulkScheduleModal;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\BulkScheduleModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\CalendarView.tsx ---\n
import React, { useMemo, useState } from 'react';
import type { MediaPlan, SchedulingPost, MediaPlanPost, PostInfo } from '../types';
import { ChevronLeftIcon, ChevronRightIcon, YouTubeIcon, FacebookIcon, InstagramIcon, TikTokIcon, PinterestIcon, SparklesIcon } from './icons';

interface CalendarViewProps {
  plan: MediaPlan;
  planId: string;
  language: string;
  onPostDrop: (postInfo: SchedulingPost, newDate: Date) => void;
  onViewDetails: (postInfo: PostInfo) => void;
}

const platformIcons: Record<string, React.FC<any>> = {
    YouTube: YouTubeIcon,
    Facebook: FacebookIcon,
    Instagram: InstagramIcon,
    TikTok: TikTokIcon,
    Pinterest: PinterestIcon
};

const PostLozenge: React.FC<{
    postInfo: SchedulingPost;
    onClick: () => void;
    onDragStart: (e: React.DragEvent<HTMLDivElement>) => void;
}> = ({ postInfo, onClick, onDragStart }) => {
    const { post } = postInfo;
    const Icon = platformIcons[post.platform] || SparklesIcon;

    const platformColors: Record<string, string> = {
        YouTube: 'bg-red-100 border-red-200 text-red-800 hover:bg-red-200',
        Facebook: 'bg-blue-100 border-blue-200 text-blue-800 hover:bg-blue-200',
        Instagram: 'bg-purple-100 border-purple-200 text-purple-800 hover:bg-purple-200',
        TikTok: 'bg-gray-200 border-gray-300 text-gray-800 hover:bg-gray-300',
        Pinterest: 'bg-red-100 border-red-200 text-red-800 hover:bg-red-200',
    };
    const colorClasses = platformColors[post.platform] || 'bg-gray-100 border-gray-200 text-gray-800 hover:bg-gray-200';

    return (
        <div
            onClick={onClick}
            draggable={true}
            onDragStart={onDragStart}
            className={`rounded-md px-2 py-1 flex items-center gap-1.5 cursor-pointer transition-colors ${colorClasses}`}
            title={post.title}
        >
            <Icon className="h-4 w-4 flex-shrink-0" />
            <span className="text-xs font-medium truncate flex-1">{post.title}</span>
        </div>
    );
};


const CalendarView: React.FC<CalendarViewProps> = ({ plan, planId, language, onPostDrop, onViewDetails }) => {
    const [currentDate, setCurrentDate] = useState(new Date());
    const [draggedOverDay, setDraggedOverDay] = useState<Date | null>(null);

    const handlePrevMonth = () => setCurrentDate(d => new Date(d.getFullYear(), d.getMonth() - 1, 1));
    const handleNextMonth = () => setCurrentDate(d => new Date(d.getFullYear(), d.getMonth() + 1, 1));

    const allPosts = useMemo(() => {
        const postsWithDate: (SchedulingPost & { date: Date })[] = [];
        
        (plan || []).forEach((week, weekIndex) => {
            (week.posts || []).forEach((post, postIndex) => {
                if (post.scheduledAt) { // Only include scheduled posts
                    const postDate = new Date(post.scheduledAt);
                    postsWithDate.push({ planId, weekIndex, postIndex, post, date: postDate });
                }
            });
        });
        return postsWithDate;
    }, [plan, planId]);

    const calendarGrid = useMemo(() => {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();

        const firstDayOfMonth = new Date(year, month, 1);
        const lastDayOfMonth = new Date(year, month + 1, 0);

        const daysInMonth = lastDayOfMonth.getDate();
        const startDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday

        const grid: { date: Date; posts: SchedulingPost[]; isCurrentMonth: boolean }[] = [];
        
        // Days from previous month
        const prevMonthLastDay = new Date(year, month, 0);
        const prevMonthDays = prevMonthLastDay.getDate();
        for (let i = startDayOfWeek - 1; i >= 0; i--) {
            grid.push({
                date: new Date(year, month - 1, prevMonthDays - i),
                posts: [],
                isCurrentMonth: false
            });
        }
        
        // Days of current month
        for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month, day);
            const postsForDay = allPosts.filter(p => p.date.toDateString() === date.toDateString());
            grid.push({ date, posts: postsForDay, isCurrentMonth: true });
        }

        // Days from next month
        const nextMonthStartDay = lastDayOfMonth.getDay();
        for (let i = 1; i < 7 - nextMonthStartDay; i++) {
             grid.push({
                date: new Date(year, month + 1, i),
                posts: [],
                isCurrentMonth: false
            });
        }
        
        return grid;
    }, [currentDate, allPosts]);

    const handleDragStart = (e: React.DragEvent<HTMLDivElement>, postInfo: SchedulingPost) => {
        e.dataTransfer.setData('application/json', JSON.stringify(postInfo));
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>, date: Date | null) => {
        e.preventDefault();
        if (date) setDraggedOverDay(date);
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>, date: Date | null) => {
        e.preventDefault();
        setDraggedOverDay(null);
        if (!date) return;
        
        try {
            const postInfoJSON = e.dataTransfer.getData('application/json');
            if (!postInfoJSON) return;
            const postInfo = JSON.parse(postInfoJSON) as SchedulingPost;
            onPostDrop(postInfo, date);
        } catch (err) {
            console.error("Failed to handle drop:", err);
        }
    };

    const dayHeaders = language === 'Việt Nam'
      ? ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7']
      : ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      
    const today = new Date().toDateString();

    return (
        <div className="bg-white p-4 sm:p-6 rounded-lg border border-gray-200 shadow-sm">
            <div className="flex justify-between items-center mb-4">
                <button onClick={handlePrevMonth} className="p-2 rounded-full hover:bg-gray-100 transition-colors" aria-label="Previous month">
                    <ChevronLeftIcon className="h-5 w-5 text-gray-600" />
                </button>
                <h2 className="text-xl font-bold text-gray-800 capitalize">
                    {currentDate.toLocaleString(language === 'Việt Nam' ? 'vi-VN' : 'en-US', { month: 'long', year: 'numeric' })}
                </h2>
                <button onClick={handleNextMonth} className="p-2 rounded-full hover:bg-gray-100 transition-colors" aria-label="Next month">
                    <ChevronRightIcon className="h-5 w-5 text-gray-600" />
                </button>
            </div>
            <div className="grid grid-cols-7 gap-px bg-gray-200 border border-gray-200 rounded-lg overflow-hidden">
                {dayHeaders.map(day => (
                    <div key={day} className="text-center text-xs font-bold text-gray-500 py-2 bg-gray-50">
                        {day}
                    </div>
                ))}
                {calendarGrid.map((day, index) => (
                    <div 
                        key={index} 
                        className={`min-h-[8rem] p-1.5 flex flex-col transition-colors duration-200
                          ${day.isCurrentMonth ? 'bg-white' : 'bg-gray-50'}
                          ${draggedOverDay && day.date && draggedOverDay.toDateString() === day.date.toDateString() ? 'ring-2 ring-brand-green ring-inset' : ''}
                        `}
                        onDragOver={(e) => handleDragOver(e, day.date)}
                        onDragLeave={() => setDraggedOverDay(null)}
                        onDrop={(e) => handleDrop(e, day.date)}
                    >
                         <span className={`text-xs font-semibold self-start
                           ${day.date.toDateString() === today ? 'bg-brand-green text-white rounded-full h-5 w-5 flex items-center justify-center' : ''}
                           ${day.isCurrentMonth ? 'text-gray-700' : 'text-gray-400'}
                         `}>
                            {day.date.getDate()}
                        </span>
                         <div className="flex-grow space-y-1.5 mt-1">
                            {day.posts.map((pInfo) => (
                                <PostLozenge
                                    key={pInfo.post.id}
                                    postInfo={pInfo}
                                    onClick={() => onViewDetails(pInfo)}
                                    onDragStart={(e) => handleDragStart(e, pInfo)}
                                />
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default CalendarView;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\CalendarView.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ContentPackageWizardModal.tsx ---\nimport React, { useState, useEffect } from 'react';
import type { Idea, Persona, AffiliateLink } from '../types';
import { Button, Select, Switch } from './ui';
import { YouTubeIcon, FacebookIcon, InstagramIcon, TikTokIcon, PinterestIcon, UsersIcon, CheckCircleIcon, SparklesIcon } from './icons';
import ProductSelector from './ProductSelector';

interface GenerationOptions {
    tone: string;
    style: string;
    length: string;
    includeEmojis: boolean;
}

interface ContentPackageWizardModalProps {
  isOpen: boolean;
  onClose: () => void;
  idea: Idea | null;
  onGenerate: (idea: Idea, personaId: string | null, selectedProductId: string | null, options: GenerationOptions) => void;
  language: string;
  personas: Persona[];
  affiliateLinks: AffiliateLink[];
  generatedImages: Record<string, string>;
  isGenerating: boolean;
}

const ContentPackageWizardModal: React.FC<ContentPackageWizardModalProps> = ({ 
    isOpen, 
    onClose, 
    idea, 
    onGenerate, 
    language, 
    personas, 
    affiliateLinks,
    generatedImages,
    isGenerating
}) => {
  const [step, setStep] = useState(1);
  const totalSteps = 3;

  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  const [selectedProductId, setSelectedProductId] = useState<string | null>(null);
  
  // Generation options state
  const [tone, setTone] = useState('Friendly & Casual');
  const [writingStyle, setWritingStyle] = useState('Storytelling');
  const [postLength, setPostLength] = useState('Medium (e.g. for Facebook)');
  const [includeEmojis, setIncludeEmojis] = useState(true);

  useEffect(() => {
    if (isOpen) {
        setStep(1);
        setSelectedPersonaId(null);
        setSelectedProductId(idea?.productId || null);
        setTone('Friendly & Casual');
        setWritingStyle('Storytelling');
        setPostLength('Medium (e.g. for Facebook)');
        setIncludeEmojis(true);
    }
  }, [isOpen, idea]);

  if (!isOpen || !idea) return null;

  const T = {
    'Việt Nam': {
        title: "Tạo Gói Nội dung",
        idea: "Từ ý tưởng:",
        step: "Bước",
        of: "trên",
        // Step 1
        step1Title: "Chọn một KOL/KOC (Tùy chọn)",
        step1Subtitle: "Chọn một nhân vật để làm gương mặt đại diện cho gói nội dung này. Nội dung sẽ được tạo từ góc nhìn của họ.",
        noPersona: "Không có KOL/KOC",
        noPersonasAvailable: "Chưa có KOL/KOC nào được định nghĩa. Bạn có thể thêm họ trong tab 'KOL/KOC'.",
        // Step 2
        step2Title: "Chọn Sản phẩm để Quảng bá (Tùy chọn)",
        step2Subtitle: "Chọn một sản phẩm từ Kho Affiliate của bạn để tự động liên kết với các bài đăng trong gói này.",
        // Step 3
        step3Title: "Tinh chỉnh & Tạo",
        step3Subtitle: "Điều chỉnh các cài đặt cuối cùng trước khi AI của chúng tôi bắt đầu làm việc.",
        toneOfVoice: "Giọng điệu",
        writingStyle: "Phong cách viết",
        postLength: "Độ dài bài đăng",
        includeEmojis: "Bao gồm Emojis",
        includeEmojisDesc: "Tự động thêm emojis vào bài đăng.",
        // Buttons
        back: "Quay lại",
        next: "Tiếp theo",
        skip: "Bỏ qua",
        generate: "Tạo Gói",
        generating: "Đang tạo...",
        cancel: "Hủy",
    },
    'English': {
        title: "Generate Content Package",
        idea: "From idea:",
        step: "Step",
        of: "of",
        // Step 1
        step1Title: "Select a KOL/KOC (Optional)",
        step1Subtitle: "Choose a persona to be the face of this content package. Content will be generated from their perspective.",
        noPersona: "No KOL/KOC",
        noPersonasAvailable: "No KOLs/KOCs have been defined yet. You can add them in the 'KOL/KOC' tab.",
        // Step 2
        step2Title: "Select Product to Promote (Optional)",
        step2Subtitle: "Choose a product from your Affiliate Vault to automatically link to posts in this package.",
        // Step 3
        step3Title: "Refine & Generate",
        step3Subtitle: "Adjust the final settings before our AI gets to work.",
        toneOfVoice: "Tone of Voice",
        writingStyle: "Writing Style",
        postLength: "Post Length",
        includeEmojis: "Include Emojis",
        includeEmojisDesc: "Automatically add emojis to posts.",
        // Buttons
        back: "Back",
        next: "Next",
        skip: "Skip for now",
        generate: "Generate Package",
        generating: "Generating...",
        cancel: "Cancel",
    }
  };
  const texts = (T as any)[language] || T['English'];

  const handleGenerate = () => {
    
    onGenerate(idea, selectedPersonaId, selectedProductId, { tone, style: writingStyle, length: postLength, includeEmojis });
    console.log('Generating content package with options:', {
        ideaId: idea.id,
        personaId: selectedPersonaId,
        productId: selectedProductId,
        options: { tone, style: writingStyle, length: postLength, includeEmojis }}
    )};

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl border border-gray-200 m-4 max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
        <header className="p-6 border-b border-gray-200">
            <div className="flex justify-between items-center">
                <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                    <SparklesIcon className="h-7 w-7 text-brand-green" />
                    {texts.title}
                </h2>
                <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
            </div>
            <p className="text-gray-500 font-serif mt-1">{texts.idea} <span className="font-semibold text-gray-700">"{idea.title}"</span></p>
            <div className="w-full bg-gray-200 rounded-full h-1.5 mt-4">
                <div className="bg-brand-green h-1.5 rounded-full" style={{ width: `${(step / totalSteps) * 100}%` }}></div>
            </div>
        </header>
        
        <main className="p-8 flex-grow overflow-y-auto">
            {step === 1 && (
                <div>
                     <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step1Title}</h3>
                    <p className="text-gray-500 font-serif text-center mt-1">{texts.step1Subtitle}</p>
                    <div className="mt-8 grid grid-cols-2 md:grid-cols-4 gap-4">
                        <button onClick={() => setSelectedPersonaId(null)} className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${selectedPersonaId === null ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' : 'bg-white hover:bg-gray-100 border-gray-200'}`}>
                            <div className="w-20 h-20 rounded-full bg-gray-200 flex items-center justify-center mb-2"><UsersIcon className="h-10 w-10 text-gray-500"/></div>
                            <span className="font-semibold text-gray-800">{texts.noPersona}</span>
                        </button>
                        {personas.map(p => {
                            const imageUrl = p.avatarImageKey ? generatedImages[p.avatarImageKey] : undefined;
                            return (
                                <button key={p.id} onClick={() => setSelectedPersonaId(p.id)} className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${selectedPersonaId === p.id ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' : 'bg-white hover:bg-gray-100 border-gray-200'}`}>
                                    <div className="w-20 h-20 rounded-full bg-gray-200 mb-2 overflow-hidden">
                                        {imageUrl ? <img src={imageUrl} alt={p.nickName} className="w-full h-full object-cover" /> : <UsersIcon className="h-10 w-10 text-gray-500 m-auto"/>}
                                    </div>
                                    <span className="font-semibold text-gray-800">{p.nickName}</span>
                                </button>
                            )
                        })}
                    </div>
                     {personas.length === 0 && <p className="text-center mt-8 text-gray-500">{texts.noPersonasAvailable}</p>}
                </div>
            )}
            {step === 2 && (
                <div>
                    <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step2Title}</h3>
                    <p className="text-gray-500 font-serif text-center mt-1">{texts.step2Subtitle}</p>
                   
                    <ProductSelector
                        affiliateLinks={affiliateLinks}
                        onSelectProduct={setSelectedProductId}
                        selectedProductId={selectedProductId || undefined}
                        language={language}
                        autoSelectedProductId={idea?.productId || undefined}
                    />
                </div>
            )}
            {step === 3 && (
                <div>
                    <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step3Title}</h3>
                    <p className="text-gray-500 font-serif text-center mt-1">{texts.step3Subtitle}</p>
                     <div className="mt-8 space-y-6 max-w-xl mx-auto">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                             <div>
                                <label htmlFor="tone" className="font-medium text-gray-700">{texts.toneOfVoice}</label>
                                <Select id="tone" value={tone} onChange={e => setTone(e.target.value)} className="mt-1">
                                    <option>Friendly & Casual</option>
                                    <option>Professional & Authoritative</option>
                                    <option>Witty & Humorous</option>
                                    <option>Inspirational & Uplifting</option>
                                    <option>Minimal & Direct</option>
                                </Select>
                             </div>
                             <div>
                                <label htmlFor="style" className="font-medium text-gray-700">{texts.writingStyle}</label>
                                <Select id="style" value={writingStyle} onChange={e => setWritingStyle(e.target.value)} className="mt-1">
                                    <option>Storytelling</option>
                                    <option>Educational / How-to</option>
                                    <option>Question-based</option>
                                    <option>Data-driven & Factual</option>
                                    <option>Conversational</option>
                                </Select>
                             </div>
                             <div>
                                <label htmlFor="length" className="font-medium text-gray-700">{texts.postLength}</label>
                                <Select id="length" value={postLength} onChange={e => setPostLength(e.target.value)} className="mt-1">
                                    <option>Short (e.g. for Instagram)</option>
                                    <option>Medium (e.g. for Facebook)</option>
                                    <option>Long (e.g. for a script)</option>
                                </Select>
                             </div>
                        </div>
                         <div className="p-4 bg-gray-50 rounded-lg border">
                            <Switch
                                id="include-emojis"
                                label={texts.includeEmojis}
                                checked={includeEmojis}
                                onChange={setIncludeEmojis}
                            />
                            <p className="text-sm text-gray-500 mt-1">{texts.includeEmojisDesc}</p>
                        </div>
                    </div>
                </div>
            )}
        </main>

        <footer className="flex justify-between items-center p-6 border-t border-gray-200 bg-gray-50 rounded-b-xl">
            <Button variant="tertiary" onClick={() => setStep(prev => prev - 1)} disabled={step === 1 || isGenerating}>{texts.back}</Button>
            <div>
                {step < totalSteps ? (
                    <>
                        {(step === 1 || step === 2) && <Button variant="secondary" onClick={() => setStep(prev => prev + 1)} disabled={isGenerating} className="mr-2">{texts.skip}</Button>}
                        <Button onClick={() => setStep(prev => prev + 1)} disabled={isGenerating}>{texts.next}</Button>
                    </>
                ) : (
                    <Button onClick={handleGenerate} disabled={isGenerating} className="w-48 flex justify-center">
                        {isGenerating ? (
                            <>
                                <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                                <span className="ml-2">{texts.generating}</span>
                            </>
                        ) : (
                            <>{texts.generate}</>
                        )}
                    </Button>
                )}
            </div>
        </footer>
      </div>
    </div>
  );
};

export default ContentPackageWizardModal;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ContentPackageWizardModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FacebookPageSelectionModal.tsx ---\nimport React from 'react';
import { Button } from './ui';
import type { FacebookPage } from '../types';

interface FacebookPageSelectionModalProps {
    isOpen: boolean;
    pages: FacebookPage[];
    onSelectPage: (page: FacebookPage) => void;
    onClose: () => void;
    language: string;
    onRetryConnect: () => void; // New prop to retry connection
}

const FacebookPageSelectionModal: React.FC<FacebookPageSelectionModalProps> = ({ isOpen, pages, onSelectPage, onClose, language, onRetryConnect }) => {
    //  console.log("FacebookPageSelectionModal isOpen:", isOpen);
    if (!isOpen) return null;

    const T = {
        'Việt Nam': {
            title: "Chọn Trang Facebook",
            subtitle: "Vui lòng chọn Trang Facebook bạn muốn kết nối.",
            select: "Chọn",
            cancel: "Hủy",
            noPages: "Không tìm thấy Trang Facebook nào. Vui lòng đảm bảo bạn có ít nhất một Trang và đã cấp quyền cần thiết.",
            retryConnect: "Thử kết nối lại",
        },
        'English': {
            title: "Select Facebook Page",
            subtitle: "Please select the Facebook Page you wish to connect.",
            select: "Select",
            cancel: "Cancel",
            noPages: "No Facebook Pages found. Please ensure you have at least one Page and have granted the necessary permissions.",
            retryConnect: "Try Connecting Again",
        }
    };
    const texts = (T as any)[language] || T['English'];

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md border border-gray-200 m-4 p-6 flex flex-col" onClick={(e) => e.stopPropagation()}>
                <h2 className="text-2xl font-bold font-sans text-gray-900 mb-2">{texts.title}</h2>
                <p className="text-gray-600 mb-4">{texts.subtitle}</p>

                {pages.length === 0 ? (
                    <div className="text-center my-4">
                        <p className="text-red-500 mb-4">{texts.noPages}</p>
                        <Button onClick={onRetryConnect}>{texts.retryConnect}</Button>
                    </div>
                ) : (
                    <div className="space-y-3 max-h-60 overflow-y-auto mb-4 pr-2">
                        {pages.map(page => (
                            <div key={page.id} className="flex items-center justify-between p-3 border border-gray-200 rounded-lg bg-gray-50">
                                <span className="font-medium text-gray-800">{page.name}</span>
                                <Button size="sm" onClick={() => onSelectPage(page)}>{texts.select}</Button>
                            </div>
                        ))}
                    </div>
                )}

                <div className="flex justify-end gap-3">
                    <Button variant="tertiary" onClick={onClose}>{texts.cancel}</Button>
                </div>
            </div>
        </div>
    );
};

export default FacebookPageSelectionModal;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FacebookPageSelectionModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelCampaignWizard.tsx ---\nimport React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import type { MediaPlanGroup, AffiliateLink, Persona } from '../../types';
import { Button, Input, Select, TextArea } from './ui';
import { SparklesIcon, ChevronLeftIcon, ChevronRightIcon, CheckCircleIcon } from './icons';
import ProductSelector from './ProductSelector';

interface FunnelCampaignWizardProps {
  isOpen: boolean;
  onClose: () => void;
  personas: Persona[];
  affiliateLinks: AffiliateLink[];
  language: string;
  onCreatePlan: (plan: MediaPlanGroup) => void;
  generatedImages: Record<string, string>;
}

const FunnelCampaignWizard: React.FC<FunnelCampaignWizardProps> = ({
  isOpen,
  onClose,
  personas,
  affiliateLinks,
  language,
  onCreatePlan,
  generatedImages
}) => {
  const [step, setStep] = useState(1);
  const [campaignName, setCampaignName] = useState('');
  const [primaryObjective, setPrimaryObjective] = useState<'product' | 'general'>('product');
  const [selectedProductId, setSelectedProductId] = useState<string | null>(null);
  const [generalGoal, setGeneralGoal] = useState('');
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  const [campaignDuration, setCampaignDuration] = useState<'1-week' | '2-weeks' | '1-month'>('1-month');
  
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);

  const totalSteps = 2;

  useEffect(() => {
    if (isOpen) {
      // Reset form when wizard opens
      setStep(1);
      setCampaignName('');
      setPrimaryObjective('product');
      setSelectedProductId(null);
      setGeneralGoal('');
      setSelectedPersonaId(null);
      setCampaignDuration('1-month');
      setIsGenerating(false);
      setGenerationError(null);
    }
  }, [isOpen]);

  const T = {
    'Việt Nam': {
      title: "Tạo Chiến dịch Funnel Mới",
      step: "Bước",
      of: "trên",
      // Step 1
      step1Title: "Xác định Mục tiêu Chiến dịch",
      campaignName: "Tên Chiến dịch",
      campaignNamePlaceholder: "Vd: Ra mắt Cà phê Rang đậm Q4",
      primaryObjective: "Mục tiêu Chính",
      promoteProduct: "Quảng bá Sản phẩm",
      generalGoal: "Mục tiêu Chung",
      selectProduct: "Chọn một sản phẩm để quảng bá",
      generalGoalPlaceholder: "Vd: Tăng số lượng đăng ký bản tin cho đại lý marketing của chúng tôi",
      targetAudience: "Đối tượng Khách hàng",
      selectPersona: "Chọn một Persona",
      noPersonasAvailable: "Chưa có Persona nào được định nghĩa. Bạn có thể thêm chúng trong tab 'KOL/KOC'.",
      campaignDuration: "Thời lượng Chiến dịch",
      oneWeek: "1 Tuần",
      twoWeeks: "2 Tuần",
      oneMonth: "1 Tháng",
      // Step 2
      step2Title: "Tạo Chiến dịch Funnel",
      generating: "Đang tạo chiến dịch funnel...",
      generateError: "Có lỗi xảy ra khi tạo chiến dịch:",
      // Buttons
      back: "Quay lại",
      next: "Tiếp theo",
      generate: "Tạo Chiến dịch Funnel",
      close: "Đóng",
      create: "Tạo",
    },
    'English': {
      title: "Create New Funnel Campaign",
      step: "Step",
      of: "of",
      // Step 1
      step1Title: "Define Campaign Goal",
      campaignName: "Campaign Name",
      campaignNamePlaceholder: "e.g., Q4 Dark Roast Coffee Launch",
      primaryObjective: "Primary Objective",
      promoteProduct: "Promote a Product",
      generalGoal: "General Goal",
      selectProduct: "Select a product to promote",
      generalGoalPlaceholder: "e.g., Increase newsletter sign-ups for our marketing agency",
      targetAudience: "Target Audience",
      selectPersona: "Select a Persona",
      noPersonasAvailable: "No Personas have been defined yet. You can add them in the 'KOL/KOC' tab.",
      campaignDuration: "Campaign Duration",
      oneWeek: "1 Week",
      twoWeeks: "2 Weeks",
      oneMonth: "1 Month",
      // Step 2
      step2Title: "Generate Funnel Campaign",
      generating: "Generating funnel campaign...",
      generateError: "An error occurred while generating the campaign:",
      // Buttons
      back: "Back",
      next: "Next",
      generate: "Generate Funnel Campaign",
      close: "Close",
      create: "Create",
    }
  };

  const texts = (T as any)[language] || T['English'];

  const calculateTotalPosts = () => {
    switch (campaignDuration) {
      case '1-week': return 7;
      case '2-weeks': return 14;
      case '1-month': return 30;
      default: return 30;
    }
  };

  const handleGenerateCampaign = async () => {
    setIsGenerating(true);
    setGenerationError(null);
    
    try {
      const selectedProduct = affiliateLinks.find(link => link.id === selectedProductId) || null;
      const selectedPersona = personas.find(p => p.id === selectedPersonaId) || null;

      // Create a shell for the media plan group. The actual content will be generated in App.tsx
      const newPlanGroup: MediaPlanGroup & { wizardData: any } = {
        id: uuidv4(),
        name: campaignName || (selectedProduct ? `Promotion: ${selectedProduct.productName}` : 'Funnel Campaign'),
        prompt: primaryObjective === 'product' && selectedProduct 
          ? `Funnel campaign to promote ${selectedProduct.productName}` 
          : `Funnel campaign for general goal: ${generalGoal}`,
        plan: [], // This will be populated by the AI generation service in the App component
        source: 'funnel-campaign',
        personaId: selectedPersona?.id,
        // Pass wizard data to the generation handler
        wizardData: {
            campaignDuration,
            primaryObjective,
            generalGoal,
            selectedProductId,
            selectedPersonaId,
        }
      };
      
      onCreatePlan(newPlanGroup);
      onClose();
    } catch (error: any) {
      console.error('Error generating funnel campaign:', error);
      setGenerationError(error.message || texts.generateError);
    } finally {
      setIsGenerating(false);
    }
  };

  const isNextDisabled = () => {
    if (step === 1) {
      if (!campaignName.trim()) return true;
      if (primaryObjective === 'product' && !selectedProductId) return true;
      if (primaryObjective === 'general' && !generalGoal.trim()) return true;
      if (!selectedPersonaId) return true;
      return false;
    }
    return false;
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onMouseDown={onClose}>
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl border border-gray-200 m-4 max-h-[90vh] flex flex-col" onMouseDown={(e) => e.stopPropagation()}>
        <header className="p-6 border-b border-gray-200">
          <div className="flex justify-between items-center">
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
              <SparklesIcon className="h-7 w-7 text-brand-green" />
              {texts.title}
            </h2>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-1.5 mt-4">
            <div className="bg-brand-green h-1.5 rounded-full" style={{ width: `${(step / totalSteps) * 100}%` }}></div>
          </div>
        </header>
        
        <main className="p-8 flex-grow overflow-y-auto">
          {step === 1 && (
            <div>
              <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step1Title}</h3>
              <div className="mt-8 space-y-6">
                <div>
                  <label htmlFor="campaignName" className="block text-sm font-medium text-gray-700 mb-1">
                    {texts.campaignName}
                  </label>
                  <Input
                    id="campaignName"
                    value={campaignName}
                    onChange={(e) => setCampaignName(e.target.value)}
                    placeholder={texts.campaignNamePlaceholder}
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    {texts.primaryObjective}
                  </label>
                  <div className="grid grid-cols-2 gap-4">
                    <button
                      onClick={() => setPrimaryObjective('product')}
                      className={`p-4 rounded-lg border-2 text-left transition-colors ${
                        primaryObjective === 'product' 
                          ? 'bg-green-50 border-brand-green' 
                          : 'bg-white hover:bg-gray-100 border-gray-200'
                      }`}
                    >
                      <div className="flex items-center">
                        <div className={`mr-3 h-5 w-5 rounded-full border-2 flex items-center justify-center ${
                          primaryObjective === 'product' 
                            ? 'bg-brand-green border-brand-green-dark' 
                            : 'bg-white border-gray-300'
                        }`}>
                          {primaryObjective === 'product' && <CheckCircleIcon className="h-5 w-5 text-white" />}
                        </div>
                        <span className="font-semibold text-gray-800">{texts.promoteProduct}</span>
                      </div>
                    </button>
                    <button
                      onClick={() => setPrimaryObjective('general')}
                      className={`p-4 rounded-lg border-2 text-left transition-colors ${
                        primaryObjective === 'general' 
                          ? 'bg-green-50 border-brand-green' 
                          : 'bg-white hover:bg-gray-100 border-gray-200'
                      }`}
                    >
                      <div className="flex items-center">
                        <div className={`mr-3 h-5 w-5 rounded-full border-2 flex items-center justify-center ${
                          primaryObjective === 'general' 
                            ? 'bg-brand-green border-brand-green-dark' 
                            : 'bg-white border-gray-300'
                        }`}>
                          {primaryObjective === 'general' && <CheckCircleIcon className="h-5 w-5 text-white" />}
                        </div>
                        <span className="font-semibold text-gray-800">{texts.generalGoal}</span>
                      </div>
                    </button>
                  </div>
                  
                  {primaryObjective === 'product' ? (
                    <div className="mt-4">
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        {texts.selectProduct}
                      </label>
                      <ProductSelector
                        affiliateLinks={affiliateLinks}
                        onSelectProduct={setSelectedProductId}
                        selectedProductId={selectedProductId}
                        language={language}
                      />
                    </div>
                  ) : (
                    <div className="mt-4">
                      <label htmlFor="generalGoal" className="block text-sm font-medium text-gray-700 mb-1">
                        {texts.generalGoal}
                      </label>
                      <TextArea
                        id="generalGoal"
                        value={generalGoal}
                        onChange={(e) => setGeneralGoal(e.target.value)}
                        placeholder={texts.generalGoalPlaceholder}
                        rows={3}
                      />
                    </div>
                  )}
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    {texts.targetAudience}
                  </label>
                  {personas.length === 0 ? (
                    <p className="text-gray-500 text-sm">{texts.noPersonasAvailable}</p>
                  ) : (
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-2">
                      {personas.map(persona => {
                        const imageUrl = persona.avatarImageKey ? generatedImages[persona.avatarImageKey] : undefined;
                        return (
                          <button
                            key={persona.id}
                            onClick={() => setSelectedPersonaId(persona.id)}
                            className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${
                              selectedPersonaId === persona.id 
                                ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' 
                                : 'bg-white hover:bg-gray-100 border-gray-200'
                            }`}
                          >
                            <div className="w-16 h-16 rounded-full bg-gray-200 mb-2 overflow-hidden">
                              {imageUrl ? (
                                <img src={imageUrl} alt={persona.nickName} className="w-full h-full object-cover" />
                              ) : (
                                <div className="w-full h-full flex items-center justify-center text-gray-500">
                                  <span className="text-xs text-center px-1">{persona.nickName.charAt(0)}</span>
                                </div>
                              )}
                            </div>
                            <span className="font-semibold text-gray-800 text-sm">{persona.nickName}</span>
                          </button>
                        );
                      })}
                    </div>
                  )}
                </div>
                
                <div>
                  <label htmlFor="campaignDuration" className="block text-sm font-medium text-gray-700 mb-1">
                    {texts.campaignDuration}
                  </label>
                  <Select
                    id="campaignDuration"
                    value={campaignDuration}
                    onChange={(e) => setCampaignDuration(e.target.value as any)}
                  >
                    <option value="1-week">{texts.oneWeek}</option>
                    <option value="2-weeks">{texts.twoWeeks}</option>
                    <option value="1-month">{texts.oneMonth}</option>
                  </Select>
                </div>
              </div>
            </div>
          )}
          
          {step === 2 && (
            <div>
              <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step2Title}</h3>
              <div className="mt-8">
                {isGenerating ? (
                  <div className="text-center py-10">
                    <div className="w-16 h-16 border-4 border-brand-green border-t-transparent rounded-full animate-spin mx-auto"></div>
                    <p className="mt-4 text-gray-600">{texts.generating}</p>
                  </div>
                ) : generationError ? (
                  <div className="text-center py-10">
                    <div className="bg-red-50 text-red-700 p-4 rounded-lg">
                      <p className="font-bold">{texts.generateError}</p>
                      <p className="mt-2">{generationError}</p>
                    </div>
                  </div>
                ) : (
                  <div className="bg-blue-50 p-6 rounded-lg border border-blue-200">
                    <h4 className="font-bold text-lg text-gray-900 mb-2">Campaign Summary</h4>
                    <ul className="space-y-2 text-gray-700">
                      <li><span className="font-semibold">Name:</span> {campaignName || (selectedProductId ? affiliateLinks.find(l => l.id === selectedProductId)?.productName : 'Unnamed Campaign')}</li>
                      <li><span className="font-semibold">Objective:</span> {primaryObjective === 'product' ? 'Product Promotion' : 'General Goal'}</li>
                      {primaryObjective === 'product' && selectedProductId && (
                        <li><span className="font-semibold">Product:</span> {affiliateLinks.find(l => l.id === selectedProductId)?.productName}</li>
                      )}
                      {primaryObjective === 'general' && generalGoal && (
                        <li><span className="font-semibold">Goal:</span> {generalGoal}</li>
                      )}
                      <li><span className="font-semibold">Persona:</span> {personas.find(p => p.id === selectedPersonaId)?.nickName || 'None selected'}</li>
                      <li><span className="font-semibold">Duration:</span> {campaignDuration === '1-week' ? texts.oneWeek : campaignDuration === '2-weeks' ? texts.twoWeeks : texts.oneMonth}</li>
                      <li><span className="font-semibold">Total Posts:</span> {calculateTotalPosts()}</li>
                    </ul>
                    
                    <div className="mt-6 p-4 bg-white rounded-lg border border-gray-200">
                      <h5 className="font-bold text-gray-900 mb-2">Funnel Stages:</h5>
                      <ol className="list-decimal list-inside space-y-1 text-gray-700">
                        <li>Awareness (Top-of-Funnel)</li>
                        <li>Consideration (Middle-of-Funnel)</li>
                        <li>Decision (Bottom-of-Funnel)</li>
                        <li>Action (Post-Purchase)</li>
                      </ol>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </main>

        <footer className="flex justify-between items-center p-6 border-t border-gray-200 bg-gray-50 rounded-b-xl">
          <Button 
            variant="tertiary" 
            onClick={() => setStep(prev => prev - 1)} 
            disabled={step === 1 || isGenerating}
          >
            <ChevronLeftIcon className="h-5 w-5 mr-1" />
            {texts.back}
          </Button>
          <div>
            {step < totalSteps ? (
              <Button 
                onClick={() => setStep(prev => prev + 1)} 
                disabled={isNextDisabled() || isGenerating}
              >
                {texts.next}
                <ChevronRightIcon className="h-5 w-5 ml-1" />
              </Button>
            ) : (
              <Button 
                onClick={handleGenerateCampaign} 
                disabled={isGenerating}
                className="w-48 flex justify-center"
              >
                {isGenerating ? (
                  <>
                    <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                    <span className="ml-2">{texts.generating}</span>
                  </>
                ) : (
                  texts.generate
                )}
              </Button>
            )}
          </div>
        </footer>
      </div>
    </div>
  );
};

export default FunnelCampaignWizard;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelCampaignWizard.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelStage.tsx ---\nimport React from 'react';
import type { MediaPlanGroup } from '../../types';

interface FunnelStageProps {
  stage: {
    name: string;
    description: string;
    goal: string;
    contentTypes: string[];
  };
  language: string;
  isSelected: boolean;
  onClick: () => void;
}

const FunnelStage: React.FC<FunnelStageProps> = ({ stage, language, isSelected, onClick }) => {
  const T = {
    'Việt Nam': {
      goal: "Mục tiêu:",
      contentTypes: "Loại nội dung:",
    },
    'English': {
      goal: "Goal:",
      contentTypes: "Content Types:",
    }
  };

  const texts = (T as any)[language] || T['English'];

  return (
    <div 
      className={`p-4 rounded-lg border-2 cursor-pointer transition-all ${
        isSelected 
          ? 'bg-green-50 border-brand-green shadow-sm' 
          : 'bg-white border-gray-200 hover:bg-gray-50'
      }`}
      onClick={onClick}
    >
      <h3 className="font-bold text-lg text-gray-900">{stage.name}</h3>
      <p className="text-gray-600 text-sm mt-1">{stage.description}</p>
      
      <div className="mt-3">
        <p className="text-xs font-semibold text-gray-500 uppercase">{texts.goal}</p>
        <p className="text-sm text-gray-800">{stage.goal}</p>
      </div>
      
      <div className="mt-3">
        <p className="text-xs font-semibold text-gray-500 uppercase">{texts.contentTypes}</p>
        <div className="flex flex-wrap gap-1 mt-1">
          {stage.contentTypes.map((type, index) => (
            <span 
              key={index} 
              className="text-xs bg-gray-100 text-gray-800 px-2 py-1 rounded"
            >
              {type}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};

export default FunnelStage;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\FunnelStage.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\GuidedWizard.tsx ---\n\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\GuidedWizard.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Header.tsx ---\n


import React, { useState } from 'react';
import { Button } from './ui';
import { SettingsIcon, PlugIcon, ArchiveIcon, MenuIcon, CheckCircleIcon, LinkIcon, CollectionIcon, TagIcon, UsersIcon, LightBulbIcon } from './icons';

export type ActiveTab = 'brandKit' | 'mediaPlan' | 'affiliateVault' | 'personas' | 'strategy';

interface HeaderProps {
    activeTab: ActiveTab;
    setActiveTab: (tab: ActiveTab) => void;
    onSaveProject: () => void;
    isSavingProject: boolean;
    onStartOver: () => void;
    autoSaveStatus: 'idle' | 'saving' | 'saved' | 'error';
    onOpenSettings: () => void;
    onOpenIntegrations: () => void;
    language: string;
}

const TabButton: React.FC<{
    tabId: ActiveTab;
    text: string;
    icon: React.ReactNode;
    activeTab: ActiveTab;
    onClick: (tabId: ActiveTab) => void;
}> = ({ tabId, text, icon, activeTab, onClick }) => (
    <button
        onClick={() => onClick(tabId)}
        className={`flex shrink-0 items-center gap-2 px-3 py-3 text-sm font-medium transition-colors focus:outline-none whitespace-nowrap ${
            activeTab === tabId
            ? 'border-b-2 border-gray-800 text-gray-800'
            : 'text-gray-500 hover:text-gray-900 border-b-2 border-transparent'
        }`}
    >
        {icon}
        {text}
    </button>
);

const AutoSaveIndicator: React.FC<{ status: HeaderProps['autoSaveStatus'], language: string }> = ({ status, language }) => {
    const T = { 
        'Việt Nam': { saving: 'Đang lưu...', saved: 'Đã lưu', error: 'Lỗi lưu' }, 
        'English': { saving: 'Saving...', saved: 'All changes saved', error: 'Save error' }
    };
    const texts = (T as any)[language] || T['English'];
    
    let content = null;
    switch(status) {
        case 'saving':
            content = (
                <>
                    <div className="w-4 h-4 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div>
                    <span>{texts.saving}</span>
                </>
            );
            break;
        case 'saved':
            content = (
                <>
                    <CheckCircleIcon className="h-5 w-5 text-green-600" />
                    <span>{texts.saved}</span>
                </>
            );
            break;
        case 'error':
            content = (
                <>
                    <span className="text-red-500 font-bold">!</span>
                    <span>{texts.error}</span>
                </>
            );
            break;
        default:
            return <div className="w-44 text-right">&nbsp;</div>; // Keep space for layout consistency
    }
    
    return (
        <div className="flex items-center gap-2 text-sm text-gray-500 w-44 justify-end">
            {content}
        </div>
    )
};


export const Header: React.FC<HeaderProps> = (props) => {
    const [isMenuOpen, setIsMenuOpen] = useState(false);

    const TABS_CONFIG = {
        'Việt Nam': {
            brandKit: { text: 'Bộ Thương hiệu', icon: <TagIcon className="h-5 w-5"/> },
            mediaPlan: { text: 'Kế hoạch Truyền thông', icon: <CollectionIcon className="h-5 w-5"/> },
            strategy: { text: 'Chiến lược Nội dung', icon: <LightBulbIcon className="h-5 w-5"/> },
            affiliateVault: { text: 'Kho Affiliate', icon: <LinkIcon className="h-5 w-5"/> },
            personas: { text: 'KOL/KOC', icon: <UsersIcon className="h-5 w-5"/> },
            saveProject: 'Lưu dự án',
            savingProject: 'Đang lưu...',
            startOver: 'Bắt đầu lại',
            settings: 'Cài đặt',
        },
        'English': {
            brandKit: { text: 'Brand Kit', icon: <TagIcon className="h-5 w-5"/> },
            mediaPlan: { text: 'Media Plan', icon: <CollectionIcon className="h-5 w-5"/> },
            strategy: { text: 'Content Strategy', icon: <LightBulbIcon className="h-5 w-5"/> },
            affiliateVault: { text: 'Affiliate Vault', icon: <LinkIcon className="h-5 w-5"/> },
            personas: { text: 'KOL/KOC', icon: <UsersIcon className="h-5 w-5"/> },
            saveProject: 'Save Project',
            savingProject: 'Saving...',
            startOver: 'Start Over',
            settings: 'Settings',
        }
    }
    const currentTexts = (TABS_CONFIG as any)[props.language] || TABS_CONFIG['English'];

    const actionButtons = (isMobile: boolean = false) => {
        const mobileClasses = isMobile ? 'w-full !justify-start text-base' : '';
        return (
            <>
                <Button onClick={props.onSaveProject} disabled={props.isSavingProject} variant="secondary" className={`${mobileClasses}`}>
                    {props.isSavingProject ? currentTexts.savingProject : currentTexts.saveProject}
                </Button>
                <Button onClick={props.onOpenSettings} variant="tertiary" className={`flex items-center gap-2 ${mobileClasses}`}>
                    <SettingsIcon className="h-5 w-5"/>
                    <span>{currentTexts.settings}</span>
                </Button>
                <Button onClick={() => window.location.href = '/admin'} variant="tertiary" className={`flex items-center gap-2 ${mobileClasses}`}>
                    <span>Admin</span>
                </Button>
                 <Button onClick={props.onStartOver} variant="tertiary" className={`text-red-600 hover:bg-red-50 ${mobileClasses}`}>
                    {currentTexts.startOver}
                </Button>
            </>
        );
    }
    
    return (
        <header className="sticky top-0 z-20 bg-white/80 backdrop-blur-lg">
             <div className="border-b border-gray-200">
                <div className="flex items-center justify-between gap-4 px-4 sm:px-6 lg:px-8 h-16">
                    <h1 className="text-xl font-semibold text-gray-900">SocialSync Pro</h1>
                    
                    {/* Desktop Buttons */}
                    <div className="hidden md:flex items-center gap-2">
                        <AutoSaveIndicator status={props.autoSaveStatus} language={props.language} />
                        {actionButtons(false)}
                    </div>

                    {/* Mobile Menu Button */}
                    <div className="md:hidden">
                        <Button variant="tertiary" onClick={() => setIsMenuOpen(!isMenuOpen)}>
                            <MenuIcon className="h-6 w-6"/>
                        </Button>
                    </div>
                </div>
            </div>
            {/* Mobile Menu */}
            {isMenuOpen && (
                <div className="md:hidden border-b border-gray-200 p-4 bg-white/95">
                    <div className="flex flex-col gap-3">
                        <div className="self-end"><AutoSaveIndicator status={props.autoSaveStatus} language={props.language} /></div>
                        {actionButtons(true)}
                    </div>
                </div>
            )}
            <div className="border-b border-gray-200">
                <div className="px-4 sm:px-6 lg:px-8">
                    <nav className="flex items-center gap-8 overflow-x-auto whitespace-nowrap -mb-px">
                         <TabButton tabId="brandKit" text={currentTexts.brandKit.text} icon={currentTexts.brandKit.icon} activeTab={props.activeTab} onClick={props.setActiveTab} />
                         <TabButton tabId="strategy" text={currentTexts.strategy.text} icon={currentTexts.strategy.icon} activeTab={props.activeTab} onClick={props.setActiveTab} />
                         <TabButton tabId="mediaPlan" text={currentTexts.mediaPlan.text} icon={currentTexts.mediaPlan.icon} activeTab={props.activeTab} onClick={props.setActiveTab} />
                         <TabButton tabId="affiliateVault" text={currentTexts.affiliateVault.text} icon={currentTexts.affiliateVault.icon} activeTab={props.activeTab} onClick={props.setActiveTab} />
                         <TabButton tabId="personas" text={currentTexts.personas.text} icon={currentTexts.personas.icon} activeTab={props.activeTab} onClick={props.setActiveTab} />
                    </nav>
                </div>
            </div>
        </header>
    );
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Header.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons.tsx ---\n





import React from 'react';

// Helper for standard UI icons
const UIIcon: React.FC<{ path: React.ReactNode, className?: string, viewBox?: string, fill?: string, strokeWidth?: number }> = ({ path, className, viewBox = "0 0 24 24", fill = "none", strokeWidth = 2 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className || "h-6 w-6"} fill={fill} viewBox={viewBox} stroke="currentColor" strokeWidth={strokeWidth}>
        {path}
    </svg>
);

// --- Platform Icons ---

export const YouTubeIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className || "h-8 w-8 text-red-600"}>
    <path d="M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17" /><path d="m10 15 5-3-5-3z" />
  </svg>
);

export const FacebookIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className || "h-8 w-8 text-blue-600"}>
    <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z" />
  </svg>
);

export const InstagramIcon = ({ className }: { className?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className || "h-8 w-8 text-pink-600"}>
        <rect width="20" height="20" x="2" y="2" rx="5" ry="5" /><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" /><line x1="17.5" x2="17.51" y1="6.5" y2="6.5" />
    </svg>
);

export const TikTokIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className || "h-8 w-8 text-gray-800"}>
    <path d="M12 12a4 4 0 1 0 4 4v-12a5 5 0 0 0-5-5v12a5 5 0 0 0 5 5z" />
  </svg>
);

export const PinterestIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className || "h-8 w-8 text-red-600"}>
    <path d="M12 12a5 5 0 0 0-5 5c0 2.76 2.24 5 5 5s5-2.24 5-5a5 5 0 0 0-5-5z" /><path d="M12 2a10 10 0 0 0-10 10c0 5.52 4.48 10 10 10s10-4.48 10-10A10 10 0 0 0 12 2z" /><path d="m9 12 6 6" />
  </svg>
);

export const AirtableIcon = ({ className }: { className?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className || "h-8 w-8 text-sky-500"} fill="currentColor" viewBox="0 0 24 24">
        <path d="M21.62,4.38l-2.54-2.54L12,9.07L4.92,1.84L2.38,4.38l7.07,7.07L2.38,18.52l2.54,2.54L12,13.83l7.07,7.07l2.54-2.54 l-7.07-7.07L21.62,4.38z"/>
    </svg>
);

export const KhongMinhIcon = ({ className }: { className?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className || "h-6 w-6"} fill="currentColor" viewBox="0 0 24 24">
        <path d="M21.2,12.7C21.7,12.4,22,11.9,22,11.3V5.5c0-1.2-0.9-2,2-2h-0.2c-0.5,0-1,0.2-1.4,0.6L12,9.3L5.6,3.9C5.2,3.5,4.7,3.3,4.2,3.3 H4c-1.1,0-2,0.8-2,2v5.8c0,0.6,0.3,1.1,0.8,1.4l7.2,4.5l-4,2.5C5.5,18.1,5,18.7,5,19.5c0,1,0.8,1.8,1.8,1.8h0.4 c0.5,0,0.9-0.2,1.3-0.5l4.5-3.2l4.5,3.2c0.4,0.3,0.8,0.5,1.3,0.5h0.4c1,0,1.8-0.8,1.8-1.8c0-0.8-0.5-1.4-1.2-1.7l-4-2.5L21.2,12.7 z" />
    </svg>
);

// --- UI Icons ---

export const DownloadIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></>} />;
export const SparklesIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="m12 3-1.9 4.2-4.3.6 3.1 3-1 4.2 3.8-2 3.8 2-1-4.2 3.1-3-4.3-.6z" /><path d="M5 3v4" /><path d="M19 17v4" /><path d="M3 5h4" /><path d="M17 19h4" /></>} />;
export const ArchiveIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="20" height="5" x="2" y="3" rx="1" /><path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8" /><path d="M10 12h4" /></>} />;
export const UploadIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></>} />;
export const CopyIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="14" height="14" x="8" y="8" rx="2" ry="2" /><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" /></>} />;
export const PlugIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M12 22v-5" /><path d="M9 8V2" /><path d="M15 8V2" /><path d="M18 11v-1a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v1a6 6 0 0 1 1 8h-2a6 6 0 0 1 1-8v-1a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v1" /><path d="M6 11v-1a2 2 0 0 1 2-2h1a2 2 0 0 1 2 2v1a6 6 0 0 0-1 8h2a6 6 0 0 0-1-8v-1a2 2 0 0 1 2-2h1a2 2 0 0 1 2 2v1" /></>} />;
export const PlusIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><line x1="12" x2="12" y1="5" y2="19" /><line x1="5" x2="19" y1="12" y2="12" /></>} />;
export const CheckCircleIcon = ({ className }: { className?: string }) => <UIIcon className={className} fill="currentColor" strokeWidth={0} path={<><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></>} />;
export const LinkIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72" /><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72" /></>} />;
export const SettingsIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M12.22 2h.44a2 2 0 0 1 2 2v.18a2 2 0 0 0 1.73 1.73h.18a2 2 0 0 1 2 2v.44a2 2 0 0 0 1.73 1.73h.18a2 2 0 0 1 2 2v.44a2 2 0 0 0 1.73 1.73h.18a2 2 0 0 1 2 2v.44a2 2 0 0 1-2 2h-.18a2 2 0 0 0-1.73 1.73v.18a2 2 0 0 1-2 2h-.44a2 2 0 0 1-2-2v-.18a2 2 0 0 0-1.73-1.73h-.18a2 2 0 0 1-2-2v-.44a2 2 0 0 0-1.73-1.73h-.18a2 2 0 0 1-2-2v-.44a2 2 0 0 0-1.73-1.73h-.18a2 2 0 0 1-2-2v-.44a2 2 0 0 1 2-2h.18a2 2 0 0 0 1.73-1.73v-.18a2 2 0 0 1 2-2h.44z" /><circle cx="12" cy="12" r="3" /></>} />;
export const MenuIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><line x1="4" x2="20" y1="12" y2="12" /><line x1="4" x2="20" y1="6" y2="6" /><line x1="4" x2="20" y1="18" y2="18" /></>} />;
export const TagIcon = ({ className }: { className?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className || "h-6 w-6"} viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
    </svg>
);
export const TrashIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M3 6h18" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" /><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></>} />;
export const PencilIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></>} />;
export const CashIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="20" height="14" x="2" y="5" rx="2" /><line x1="6" x2="6.01" y1="12" y2="12" /><line x1="18" x2="18.01" y1="12" y2="12" /></>} />;
export const ScaleIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2z" /><path d="M12 18a6 6 0 1 1 6-6 6 6 0 0 1-6 6z" /></>} />;
export const CollectionIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="20" height="14" x="2" y="5" rx="2" /><line x1="2" x2="22" y1="10" y2="10" /></>} />;
export const SearchIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><circle cx="11" cy="11" r="8" /><path d="m21 21-4.3-4.3" /></>} />;
export const DotsVerticalIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><circle cx="12" cy="12" r="1" /><circle cx="12" cy="5" r="1" /><circle cx="12" cy="19" r="1" /></>} />;
export const CalendarIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="18" height="18" x="3" y="4" rx="2" ry="2" /><line x1="16" x2="16" y1="2" y2="6" /><line x1="8" x2="8" y1="2" y2="6" /><line x1="3" x2="21" y1="10" y2="10" /></>} />;
export const ListBulletIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><line x1="8" x2="21" y1="6" y2="6" /><line x1="8" x2="21" y1="12" y2="12" /><line x1="8" x2="21" y1="18" y2="18" /><line x1="3" x2="3.01" y1="6" y2="6" /><line x1="3" x2="3.01" y1="12" y2="12" /><line x1="3" x2="3.01" y1="18" y2="18" /></>} />;
export const ChevronLeftIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="m15 18-6-6 6-6" /></>} />;
export const ChevronRightIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="m9 18 6-6-6-6" /></>} />;
export const ChevronDownIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="m6 9 6 6 6-6" /></>} />;
export const CheckSolidIcon = ({ className }: { className?: string }) => <UIIcon className={className} fill="currentColor" viewBox="0 0 20 20" path={<><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></>} />
export const ChatBubbleLeftIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></>} />;
export const PhotographIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></>} />;
export const InformationCircleIcon = ({ className }: { className?: string }) => <UIIcon className={className} fill="currentColor" viewBox="0 0 20 20" path={<><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="16" y2="12" /><line x1="12" x2="12.01" y1="8" y2="8" /></>} />
export const VideoCameraIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M22 8a2 2 0 0 1-2 2h-7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></>} />
export const UsersIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></>} />;
export const LightBulbIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M15 14c.2-1 .7-1.7 1.5-2.5C17.7 10.2 18 9 18 8A6 6 0 0 0 6 8c0 1 .3 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5" /><path d="M9 18h6" /><path d="M10 22h4" /></>} />;
export const XIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><line x1="18" x2="6" y1="6" y2="18" /><line x1="6" x2="18" y1="6" y2="18" /></>} />;
export const ArrowPathIcon = ({ className }: { className?: string }) => <UIIcon className={className} path={<><path d="M21 12a9 9 0 1 1-9-9c2.5 0 4.7 1 6.4 2.6l-1.4 1.4" /><path d="M21 2v6h-6" /></>} />;

// Funnel Icon - New addition
export const FunnelIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className || "h-6 w-6"} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
  </svg>
);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\IdeaProfiler.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';
import { Button, TextArea } from './ui';
import { SparklesIcon, PlugIcon, UploadIcon, PlusIcon } from './icons';
import { listBrandsFromAirtable } from '../services/databaseService';

interface IdeaProfilerProps {
  onGenerateProfile: (idea: string) => void;
  isLoading: boolean;
  onLoadProject: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onLoadProjectFromAirtable: (brandId: string) => void;
  onOpenIntegrations: () => void;
  language: string;
  setLanguage: (lang: string) => Promise<void>;
  integrationsVersion: number;
  areCredentialsSet: boolean;
}

const IdeaProfiler: React.FC<IdeaProfilerProps> = ({ onGenerateProfile, isLoading, onLoadProject, onLoadProjectFromAirtable, onOpenIntegrations, language, setLanguage, integrationsVersion, areCredentialsSet }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [idea, setIdea] = useState('');
  const [brands, setBrands] = useState<{ id: string, name: string }[]>([]);
  const [isFetchingBrands, setIsFetchingBrands] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const checkCredentialsAndFetch = async () => {
      if (areCredentialsSet) {
        setIsFetchingBrands(true);
        setError(null);
        try {
          const fetchedBrands = await listBrandsFromAirtable();
          setBrands(fetchedBrands);
        } catch (err) {
          console.error("Failed to fetch brands from Airtable:", err);
          setError(err instanceof Error ? err.message : "Could not fetch projects.");
        } finally {
          setIsFetchingBrands(false);
        }
      } else {
        setBrands([]); // Clear brands if credentials are not set
      }
    };
    checkCredentialsAndFetch();
  }, [integrationsVersion, areCredentialsSet]);

  const handleLoadClick = () => {
    fileInputRef.current?.click();
  };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (idea.trim()) {
      onGenerateProfile(idea);
    }
  };

  const texts = {
    'Việt Nam': {
      title: 'SocialSync Pro',
      welcomeTitle: "Bắt đầu với ý tưởng lớn của bạn",
      welcomeSubtitle: "Mô tả ý tưởng kinh doanh hoặc thương hiệu của bạn, và chúng tôi sẽ tạo ra một hồ sơ chuyên nghiệp để bắt đầu.",
      placeholder: "Vd: Một hộp đăng ký hàng tháng cho đồ chơi chó thân thiện với môi trường, được sản xuất tại địa phương và bền vững.",
      generateButton: 'Tạo hồ sơ thương hiệu',
      generateButtonLoading: 'Đang tạo...',
      connectDB: "Kết nối Cơ sở dữ liệu",
      loadFile: "Tải lên dự án",
      yourProjects: "Hoặc tiếp tục với một dự án hiện có",
      loadingProjects: "Đang tải lên dự án...",
      footerText: "Cung cấp bởi Google Gemini",
      noProjectsFound: "Không tìm thấy dự án nào trong cơ sở dữ liệu của bạn.",
    },
    'English': {
      title: 'SocialSync Pro',
      welcomeTitle: "Start with your big idea",
      welcomeSubtitle: "Describe your business or brand concept, and we'll generate a professional profile to get you started.",
      placeholder: 'e.g., A subscription box for eco-friendly dog toys, locally made and sustainable.',
      generateButton: 'Generate Brand Profile',
      generateButtonLoading: 'Generating...',
      connectDB: "Connect Database",
      loadFile: "Load Project",
      yourProjects: "Or continue with an existing project",
      loadingProjects: "Loading projects...",
      footerText: "Powered by Google Gemini",
      noProjectsFound: "No projects found in your database.",
    }
  };
  const currentTexts = (texts as any)[language] || texts['English'];
  
  return (
    <div className="bg-brand-light text-dark-text font-sans flex flex-col min-h-screen">
      <header className="sticky top-0 z-30 bg-white/70 backdrop-blur-lg border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex justify-between items-center h-16">
                <div className="flex-shrink-0">
                    <h1 className="text-xl font-bold text-dark-text">{currentTexts.title}</h1>
                </div>
                <div className="flex items-center">
                    <select
                        id="language"
                        value={language}
                        onChange={async (e) => await setLanguage(e.target.value)}
                        className="text-sm bg-transparent border-gray-300 rounded-md py-1.5 focus:ring-brand-green focus:border-brand-green"
                    >
                        <option value="Việt Nam">VI</option>
                        <option value="English">EN</option>
                    </select>
                </div>
            </div>
        </div>
      </header>
      
      <main className="flex-grow flex items-center py-12 sm:py-20">
        <div className="w-full max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center">
                <h1 className="text-4xl sm:text-5xl font-bold tracking-tight text-dark-text leading-tight">{currentTexts.welcomeTitle}</h1>
                <p className="mt-4 text-lg text-dark-subtle font-serif max-w-2xl mx-auto">{currentTexts.welcomeSubtitle}</p>
            </div>

            <form onSubmit={handleSubmit} className="mt-10 max-w-2xl mx-auto">
                <TextArea
                    id="idea"
                    name="idea"
                    value={idea}
                    onChange={(e) => setIdea(e.target.value)}
                    required
                    placeholder={currentTexts.placeholder}
                    rows={4}
                    className="text-lg p-4 shadow-lg border-gray-300 focus:border-brand-green focus:ring-brand-green"
                />
                <Button type="submit" disabled={isLoading || !idea.trim()} className="mt-4 w-full flex items-center justify-center gap-2 py-3 text-lg">
                    {isLoading ? (
                        currentTexts.generateButtonLoading
                    ) : (
                        <>
                            <SparklesIcon className="h-6 w-6" />
                            {currentTexts.generateButton}
                        </>
                    )}
                </Button>
            </form>

            <div className="mt-12">
                 <div className="relative">
                    <div className="absolute inset-0 flex items-center" aria-hidden="true">
                        <div className="w-full border-t border-gray-300" />
                    </div>
                    <div className="relative flex justify-center">
                        <span className="bg-brand-light px-4 text-sm font-medium text-dark-subtle">{currentTexts.yourProjects}</span>
                    </div>
                </div>

                <div className="mt-6 flex justify-center gap-4">
                    {!areCredentialsSet && (
                        <Button variant="secondary" onClick={onOpenIntegrations} className="flex items-center gap-2">
                            <PlugIcon className="h-5 w-5"/> {currentTexts.connectDB}
                        </Button>
                    )}
                    <Button variant="secondary" onClick={handleLoadClick} className="flex items-center gap-2">
                        <UploadIcon className="h-5 w-5"/> {currentTexts.loadFile}
                    </Button>
                </div>

                 {areCredentialsSet && (
                     <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-200 mt-8">
                        {isFetchingBrands ? (
                             <p className="text-center text-gray-500 py-10">{currentTexts.loadingProjects}</p>
                        ) : error ? (
                            <p className="text-center text-red-600 py-10">{error}</p>
                        ) : brands.length > 0 ? (
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                                {brands.map(brand => (
                                    <button 
                                        key={brand.id}
                                        onClick={() => onLoadProjectFromAirtable(brand.id)}
                                        className="p-4 bg-gray-50 rounded-lg text-left hover:bg-green-100 hover:shadow-md transition-all border border-gray-200"
                                    >
                                        <h3 className="font-bold text-dark-text">{brand.name}</h3>
                                        <p className="text-xs text-gray-400 font-mono mt-1">{brand.id}</p>
                                    </button>
                                ))}
                            </div>
                        ) : (
                            <div className="text-center py-10">
                                 <p className="text-gray-500">{currentTexts.noProjectsFound}</p>
                            </div>
                        )}
                    </div>
                 )}
            </div>
        </div>
      </main>

      <footer className="bg-white mt-auto">
        <div className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8 text-center text-sm text-dark-subtle">
            <p>&copy; {new Date().getFullYear()} {currentTexts.title}. {currentTexts.footerText}.</p>
        </div>
      </footer>
      <input 
          type="file" 
          ref={fileInputRef} 
          onChange={onLoadProject} 
          className="hidden" 
          accept=".ssproj,.json"
      />
    </div>
  );
};

export default IdeaProfiler;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\IdeaProfiler.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\KhongMinhSuggestion.tsx ---\nimport React, { useState, useEffect } from 'react';
import type { AffiliateLink } from '../types';
import { Button } from './ui';
import { KhongMinhIcon, LinkIcon, CheckCircleIcon, ChevronLeftIcon, ChevronRightIcon } from './icons';

interface KhongMinhSuggestionProps {
  acceptedProducts: AffiliateLink[];
  suggestedProducts: AffiliateLink[];
  isAnalyzing: boolean;
  isAnyAnalysisRunning: boolean;
  onAccept: (productId: string) => void;
  language: string;
  onRunAnalysis: () => void;
  affiliateLinksCount: number;
}

const KhongMinhSuggestion: React.FC<KhongMinhSuggestionProps> = ({ acceptedProducts, suggestedProducts, isAnalyzing, isAnyAnalysisRunning, onAccept, language, onRunAnalysis, affiliateLinksCount }) => {
    
    const [currentIndex, setCurrentIndex] = useState(0);

    useEffect(() => {
        // If the current index is now out of bounds because the list shrank, reset it.
        if (currentIndex >= suggestedProducts.length) {
            setCurrentIndex(suggestedProducts.length > 0 ? suggestedProducts.length - 1 : 0);
        }
    }, [suggestedProducts, currentIndex]);

    const T = {
        'Việt Nam': {
            thinking: "Khổng Minh đang suy nghĩ...",
            suggests: "Khổng Minh gợi ý",
            accept: "Chấp nhận",
            promotedProduct: "Sản phẩm được quảng bá",
            viewProduct: "Xem sản phẩm",
            getSuggestions: "Lấy gợi ý",
        },
        'English': {
            thinking: "KhongMinh is thinking...",
            suggests: "KhongMinh Suggests",
            accept: "Accept",
            promotedProduct: "Promoted Product",
            viewProduct: "View Product",
            getSuggestions: "Get Suggestions",
        }
    };
    const texts = T[language as keyof typeof T] || T['English'];

    const formatCurrency = (value: number) => {
        return new Intl.NumberFormat(language === 'Việt Nam' ? 'vi-VN' : 'en-US', {
            style: 'currency',
            currency: language === 'Việt Nam' ? 'VND' : 'USD',
            minimumFractionDigits: 0,
        }).format(value);
    };

    const hasSuggestions = suggestedProducts && suggestedProducts.length > 0;
    const currentSuggestion = hasSuggestions ? suggestedProducts[currentIndex] : null;

    // Handle accepting a product
    const handleAccept = (productId: string) => {
        onAccept(productId);
        // When a product is accepted, the suggestedProducts array will be filtered in the parent component
        // The currentIndex will be automatically adjusted by the useEffect if it becomes out of bounds
    };

    return (
        <div className="mt-4 p-3 bg-gray-50 border border-gray-200 rounded-lg space-y-3">
            <h5 className="font-bold text-sm text-gray-800 flex items-center gap-2">
                <KhongMinhIcon className="h-5 w-5"/>
                KhongMinh
            </h5>

            {/* Accepted Products */}
            {acceptedProducts.length > 0 && (
                <div className="space-y-2">
                    {acceptedProducts.map(product => (
                        <div key={product.id} className="p-2 bg-green-100/50 border border-green-200 rounded-md">
                            <p className="text-xs text-green-800 font-semibold flex items-center gap-1.5"><CheckCircleIcon className="h-4 w-4" /> {texts.promotedProduct}</p>
                            <p className="mt-1 text-sm text-green-900 font-medium">{product.productName}</p>
                            <a href={product.productLink} target="_blank" rel="noopener noreferrer" className="text-xs text-green-700 hover:underline flex items-center gap-1">
                                <LinkIcon className="h-3 w-3" />
                                {texts.viewProduct}
                            </a>
                        </div>
                    ))}
                </div>
            )}

            {/* Suggestions Carousel / Get Suggestions Button */}
            {isAnalyzing && (
                <div className="flex items-center justify-center gap-2 text-sm text-gray-500 py-4">
                    <div className="w-4 h-4 border-2 border-t-transparent border-gray-400 rounded-full animate-spin"></div>
                    {texts.thinking}
                </div>
            )}
            
            {!isAnalyzing && hasSuggestions && currentSuggestion && (
                <div className="p-2 bg-blue-50 border border-blue-200 rounded-md">
                    <p className="text-xs text-blue-800 font-semibold">{texts.suggests}</p>
                    <div className="flex items-center gap-1 mt-2">
                         <Button
                            variant="tertiary"
                            onClick={() => setCurrentIndex(i => i - 1)}
                            disabled={currentIndex === 0}
                            className="p-1 h-8 w-8 rounded-full"
                         >
                            <ChevronLeftIcon className="h-5 w-5" />
                        </Button>

                        <div className="flex-grow text-center">
                            <p className="text-sm text-blue-900 font-semibold">{currentSuggestion.productName}</p>
                            <p className="text-xs text-blue-700">{formatCurrency(currentSuggestion.price)}</p>
                        </div>
                        
                         <Button
                            variant="tertiary"
                            onClick={() => setCurrentIndex(i => i + 1)}
                            disabled={currentIndex >= suggestedProducts.length - 1}
                            className="p-1 h-8 w-8 rounded-full"
                         >
                            <ChevronRightIcon className="h-5 w-5" />
                        </Button>
                    </div>

                    <div className="mt-3 flex justify-end items-center gap-2">
                         <a href={currentSuggestion.productLink} target="_blank" rel="noopener noreferrer" className="text-xs font-medium text-blue-700 hover:underline flex items-center gap-1">
                            {texts.viewProduct}
                        </a>
                        <Button onClick={() => handleAccept(currentSuggestion.id)} className="text-xs px-3 py-1 bg-blue-600 hover:bg-blue-700">{texts.accept}</Button>
                    </div>
                </div>
            )}

            {!isAnalyzing && !hasSuggestions && acceptedProducts.length === 0 && affiliateLinksCount > 0 && (
                <div className="mt-2">
                    <Button
                        variant="secondary"
                        onClick={onRunAnalysis}
                        disabled={isAnyAnalysisRunning}
                        className="w-full text-xs py-1.5 px-2 flex items-center justify-center gap-2"
                    >
                        <KhongMinhIcon className="h-4 w-4 text-gray-600"/>
                        {texts.getSuggestions}
                    </Button>
                </div>
            )}

        </div>
    );
};

export default KhongMinhSuggestion;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\KhongMinhSuggestion.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Loader.tsx ---\nimport React, { useState, useEffect } from 'react';
import { CheckCircleIcon } from './icons';

interface LoaderProps {
    title: string;
    steps: string[];
    currentStep?: number; // Optional: for externally controlled progress
}

const Loader: React.FC<LoaderProps> = ({ title, steps, currentStep }) => {
    const [internalStep, setInternalStep] = useState(0);
    
    // Use the externally provided step if it exists, otherwise use internal state.
    const currentStepIndex = currentStep !== undefined ? currentStep : internalStep;

    useEffect(() => {
        // If the loader is externally controlled, don't run the internal timer.
        if (currentStep !== undefined || steps.length === 0) return;

        // Approximate total time for a long generation task, divided by number of steps
        const totalDuration = 25000; // 25 seconds
        const stepInterval = Math.max(2000, totalDuration / steps.length);

        const interval = setInterval(() => {
            setInternalStep(prev => {
                // Stop incrementing when we reach the second to last step. The last step will show as "in-progress" until the loader is removed.
                if (prev < steps.length - 1) {
                    return prev + 1;
                }
                clearInterval(interval);
                return prev;
            });
        }, stepInterval);

        return () => clearInterval(interval);
    }, [steps, currentStep]);

    return (
        <div className="fixed inset-0 bg-white/95 flex flex-col items-center justify-center z-50 backdrop-blur-md p-4 transition-opacity duration-300">
            <div className="w-full max-w-lg text-center">
                <div className="w-12 h-12 border-4 border-t-transparent border-brand-green rounded-full animate-spin mx-auto"></div>
                <h2 className="mt-6 text-3xl font-bold font-sans text-gray-900">{title}</h2>
                <p className="mt-2 text-lg text-gray-500 font-serif">Our AI is crafting your assets. This may take a moment.</p>
                
                {steps.length > 0 && (
                    <ul className="mt-8 space-y-4 text-left border-t border-gray-200 pt-6">
                        {steps.map((step, index) => (
                            <li key={index} className={`flex items-start gap-4 transition-all duration-500 ${currentStepIndex >= index ? 'opacity-100' : 'opacity-40'}`}>
                                <div className="flex-shrink-0 h-6 w-6 rounded-full flex items-center justify-center mt-0.5">
                                    {currentStepIndex > index ? (
                                        <CheckCircleIcon className="h-6 w-6 text-brand-green" />
                                    ) : currentStepIndex === index ? (
                                        <div className="w-6 h-6 rounded-full bg-brand-green/20 flex items-center justify-center">
                                            <div className="h-3 w-3 bg-brand-green rounded-full animate-pulse"></div>
                                        </div>
                                    ) : (
                                        <div className="h-6 w-6 rounded-full bg-gray-200 flex items-center justify-center">
                                            <div className="h-2 w-2 bg-gray-400 rounded-full"></div>
                                        </div>
                                    )}
                                </div>
                                <span className={`font-medium ${currentStepIndex > index ? 'text-gray-500 line-through' : currentStepIndex === index ? 'text-gray-900' : 'text-gray-500'}`}>{step}</span>
                            </li>
                        ))}
                    </ul>
                )}
            </div>
        </div>
    );
};

export default Loader;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Loader.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MainDisplay.tsx ---\nimport React, { useState, Suspense, useCallback, useEffect } from 'react';
import type { 
  GeneratedAssets, 
  MediaPlanGroup, 
  Settings, 
  AffiliateLink, 
  MediaPlanPost, 
  SchedulingPost, 
  Persona, 
  Trend, 
  Idea, 
  PostInfo 
} from '../types';
import ScheduleModal from './ScheduleModal';
import BulkScheduleModal from './BulkScheduleModal';
import { Header, ActiveTab } from './Header';
import { MediaPlanWizardModal } from './MediaPlanWizardModal';
import FunnelCampaignWizard from './FunnelCampaignWizard'; // Import the new component

const AssetDisplay = React.lazy(() => import('./AssetDisplay'));
const MediaPlanDisplay = React.lazy(() => import('./MediaPlanDisplay'));
const AffiliateVaultDisplay = React.lazy(() => import('./AffiliateVaultDisplay'));
const PersonasDisplay = React.lazy(() => import('./PersonasDisplay'));
const StrategyDisplay = React.lazy(() => import('./StrategyDisplay'));

interface MainDisplayProps {
  assets: GeneratedAssets;
  onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9", postInfo?: PostInfo) => void;
  onSetImage: (dataUrl: string, key: string, postInfo?: PostInfo) => void;
  generatedImages: Record<string, string>;
  generatedVideos: Record<string, string>;
  onSetVideo: (dataUrl: string, key: string, postInfo: PostInfo) => void;
  isGeneratingImage: (key: string) => boolean;
  isUploadingImage: (key: string) => boolean;
  settings: Settings;
  onExportBrandKit: () => void;
  isExportingBrandKit: boolean;
  onExportPlan: () => void;
  isExportingPlan: boolean;
  onGeneratePlan: (prompt: string, useSearch: boolean, totalPosts: number, selectedPlatforms: string[], options: { tone: string; style: string; length: string; includeEmojis: boolean; }, selectedProductId: string | null, personaId: string | null) => void;
  isGeneratingPlan: boolean;
  onRegenerateWeekImages: (planId: string, weekIndex: number) => void;
  productImages: File[]; // This prop is deprecated but kept for avoiding breaking changes in unrelated components.
  onSetProductImages: (files: File[]) => void;
  onSaveProject: () => void;
  isSavingProject: boolean;
  onStartOver: () => void;
  autoSaveStatus: 'idle' | 'saving' | 'saved' | 'error';
  onOpenSettings: () => void;
  onOpenIntegrations: () => void;
  activeTab: ActiveTab;
  setActiveTab: (tab: ActiveTab) => void;
  // Media Plan props
  mediaPlanGroupsList: {id: string, name: string, prompt: string, productImages?: { name: string, type: string, data: string }[], personaId?: string;}[];
  onSelectPlan: (planId: string, assetsToUse?: GeneratedAssets, plansList?: {id: string, name: string, prompt: string, productImages?: { name: string, type: string, data: string }[]}[]) => void;
  activePlanId: string | null;
  onUpdatePost: (postInfo: PostInfo) => void;
  onRefinePost: (text: string) => Promise<string>;
  onAssignPersonaToPlan: (planId: string, personaId: string | null) => void;
  // KhongMinh Props
  analyzingPostIds: Set<string>;
  isAnyAnalysisRunning: boolean;
  khongMinhSuggestions: Record<string, AffiliateLink[]>;
  onAcceptSuggestion: (postInfo: PostInfo, productId: string) => void;
  onRunKhongMinhForPost: (postInfo: PostInfo) => void;
  // On-demand prompt generation
  generatingPromptKeys: Set<string>;
  onGeneratePrompt: (postInfo: PostInfo) => Promise<MediaPlanPost | null>;
  // Comment Generation
  onGenerateAffiliateComment: (postInfo: PostInfo) => Promise<MediaPlanPost | null>;
  generatingCommentPostIds: Set<string>;
  // Selection & Scheduling
  selectedPostIds: Set<string>;
  onTogglePostSelection: (postId: string) => void;
  onSelectAllPosts: (posts: PostInfo[]) => void;
  onClearSelection: () => void;
  onOpenScheduleModal: (post: SchedulingPost | null) => void;
  isScheduling: boolean;
  onSchedulePost: (postInfo: SchedulingPost, scheduledAt: string) => void;
  onPostDrop: (postInfo: SchedulingPost, newDate: Date) => void;
  schedulingPost: SchedulingPost | null;
  onOpenBulkScheduleModal: () => void;
  isBulkScheduleModalOpen: boolean;
  onCloseBulkScheduleModal: () => void;
  onBulkSchedule: (startDate: string, intervalDays: number, intervalHours: number, intervalMinutes: number) => void;
  isPerformingBulkAction: boolean;
  onBulkGenerateImages: (posts: PostInfo[]) => void;
  onBulkSuggestPromotions: (posts: PostInfo[]) => void;
  onBulkGenerateComments: (posts: PostInfo[]) => void;
  onPublishPost: (postInfo: PostInfo) => void; // New prop for direct publishing
  brandFoundation: GeneratedAssets['brandFoundation'];
  // New prop for opening funnel wizard
  onOpenFunnelWizard: () => void;
  // Personas
  onSavePersona: (persona: Persona) => void;
  onDeletePersona: (personaId: string) => void;
  onSetPersonaImage: (dataUrl: string, imageKey: string, personaId: string) => void;
  onUpdatePersona: (persona: Persona) => void;
  // Strategy Hub
  onSaveTrend: (trend: Trend) => void;
  onDeleteTrend: (trendId: string) => void;
  onGenerateIdeas: (trend: Trend, useSearch: boolean) => void;
  onGenerateContentPackage: (idea: Idea, personaId: string | null, selectedProductId: string | null, options: { tone: string; style: string; length: string; includeEmojis: boolean; }) => void;
  onGenerateTrendsFromSearch: (industry: string) => void;
  isGeneratingTrendsFromSearch: boolean;
  onLoadIdeasForTrend?: (trendId: string) => void; // New prop
  productTrendToSelect: string | null; // New prop to specify which product trend to select
  // Video
  onSetVideo: (dataUrl: string, key: string, postInfo: PostInfo) => void;
  // New Facebook Strategy Props
  onGenerateFacebookPostIdeas: (postInfo: PostInfo) => void;
  onAddFacebookPostIdeaToPlan: (idea: FacebookPostIdea) => void;
  isGeneratingFacebookPostIdeas: boolean;
  // Funnel Campaign Props
  onCreateFunnelCampaignPlan: (plan: MediaPlanGroup) => void;
  // Lazy loading props
  isStrategyHubDataLoaded?: boolean;
  onLoadStrategyHubData?: () => void;
  isLoadingStrategyHubData?: boolean;
  isAffiliateVaultDataLoaded?: boolean;
  onLoadAffiliateVaultData?: () => void;
  isLoadingAffiliateVaultData?: boolean;
  isPersonasDataLoaded?: boolean;
  onLoadPersonasData?: () => void;
  isLoadingPersonasData?: boolean;
}

const MainDisplay: React.FC<MainDisplayProps> = (props) => {
  const {
    assets,
    onGenerateImage,
    onSetImage,
    generatedImages,
    generatedVideos,
    onSetVideo,
    isGeneratingImage,
    isUploadingImage,
    settings,
    onExportBrandKit,
    isExportingBrandKit,
    onExportPlan,
    isExportingPlan,
    onGeneratePlan,
    isGeneratingPlan,
    onRegenerateWeekImages,
    productImages,
    onSetProductImages,
    onSaveProject,
    isSavingProject,
    onStartOver,
    autoSaveStatus,
    onOpenSettings,
    onOpenIntegrations,
    activeTab,
    setActiveTab,
    mediaPlanGroupsList,
    onSelectPlan,
    activePlanId,
    onUpdatePost,
    onRefinePost,
    onAssignPersonaToPlan,
    onSaveAffiliateLink,
    onDeleteAffiliateLink,
    onImportAffiliateLinks,
    productTrendToSelect,
    brandFoundation,
    analyzingPostIds,
    isAnyAnalysisRunning,
    khongMinhSuggestions,
    onAcceptSuggestion,
    onRunKhongMinhForPost,
    generatingPromptKeys,
    onGeneratePrompt,
    onGenerateAffiliateComment,
    generatingCommentPostIds,
    selectedPostIds,
    onTogglePostSelection,
    onSelectAllPosts,
    onClearSelection,
    onOpenScheduleModal,
    isScheduling,
    onSchedulePost,
    onPostDrop,
    schedulingPost,
    onOpenBulkScheduleModal,
    isBulkScheduleModalOpen,
    onCloseBulkScheduleModal,
    onBulkSchedule,
    isPerformingBulkAction,
    onBulkGenerateImages,
    onBulkSuggestPromotions,
    onBulkGenerateComments,
    onSavePersona,
    onDeletePersona,
    onSetPersonaImage,
    onSaveTrend,
    onDeleteTrend,
    onGenerateIdeas,
    onGenerateContentPackage,
    onGenerateTrendsFromSearch,
    isGeneratingTrendsFromSearch,
    onPublishPost,
    onUpdatePersona,
    onLoadIdeasForTrend,
    onCreateFunnelCampaignPlan, // New prop
  } = props;
  
  const [isWizardOpen, setIsWizardOpen] = useState(false);
  const [initialWizardPrompt, setInitialWizardPrompt] = useState('');
  const [initialWizardProductId, setInitialWizardProductId] = useState<string | undefined>(undefined);
  
  // State for Funnel Campaign Wizard
  const [isFunnelWizardOpen, setIsFunnelWizardOpen] = useState(false);
  
  // State for tracking which tabs have been loaded
  const [loadedTabs, setLoadedTabs] = useState<Set<ActiveTab>>(new Set(['brandKit']));
  
  // State for tracking loading status of tabs
  const [loadingTabs, setLoadingTabs] = useState<Set<ActiveTab>>(new Set());
  
  // Load data on demand when switching tabs
  useEffect(() => {
    // Load strategy hub data when switching to strategy tab
    if (activeTab === 'strategy' && !loadedTabs.has('strategy') && props.onLoadStrategyHubData && !loadingTabs.has('strategy')) {
      setLoadingTabs(prev => new Set(prev).add('strategy'));
      props.onLoadStrategyHubData().then(() => {
        // Success - mark tab as loaded
        setLoadedTabs(prev => new Set(prev).add('strategy'));
      }).catch((error) => {
        // Error - don't mark tab as loaded so it can retry
        console.error("Failed to load strategy hub data:", error);
      }).finally(() => {
        // Always clean up loading state
        setLoadingTabs(prev => {
          const newSet = new Set(prev);
          newSet.delete('strategy');
          return newSet;
        });
      });
    }
    
    // Load affiliate vault data when switching to affiliate vault tab
    if (activeTab === 'affiliateVault' && !loadedTabs.has('affiliateVault') && props.onLoadAffiliateVaultData && !loadingTabs.has('affiliateVault')) {
      setLoadingTabs(prev => new Set(prev).add('affiliateVault'));
      props.onLoadAffiliateVaultData().then(() => {
        // Success - mark tab as loaded
        setLoadedTabs(prev => new Set(prev).add('affiliateVault'));
      }).catch((error) => {
        // Error - don't mark tab as loaded so it can retry
        console.error("Failed to load affiliate vault data:", error);
      }).finally(() => {
        // Always clean up loading state
        setLoadingTabs(prev => {
          const newSet = new Set(prev);
          newSet.delete('affiliateVault');
          return newSet;
        });
      });
    }
    
    // Load personas data when switching to personas tab
    if (activeTab === 'personas' && !loadedTabs.has('personas') && props.onLoadPersonasData && !loadingTabs.has('personas')) {
      setLoadingTabs(prev => new Set(prev).add('personas'));
      props.onLoadPersonasData().then(() => {
        // Success - mark tab as loaded
        setLoadedTabs(prev => new Set(prev).add('personas'));
      }).catch((error) => {
        // Error - don't mark tab as loaded so it can retry
        console.error("Failed to load personas data:", error);
      }).finally(() => {
        // Always clean up loading state
        setLoadingTabs(prev => {
          const newSet = new Set(prev);
          newSet.delete('personas');
          return newSet;
        });
      });
    }
  }, [activeTab, loadedTabs, loadingTabs, props.onLoadStrategyHubData, props.onLoadAffiliateVaultData, props.onLoadPersonasData]);
  
  // Function to mark a tab as loaded
  const markTabAsLoaded = (tab: ActiveTab) => {
    setLoadedTabs(prev => new Set(prev).add(tab));
  };
  
  // Function to mark a tab as loading
  const markTabAsLoading = (tab: ActiveTab) => {
    setLoadingTabs(prev => new Set(prev).add(tab));
  };
  
  // Function to mark a tab as finished loading
  const markTabAsFinishedLoading = (tab: ActiveTab) => {
    setLoadingTabs(prev => {
      const newSet = new Set(prev);
      newSet.delete(tab);
      return newSet;
    });
  };

  const handleOpenWizard = (prompt = '', productId?: string) => {
    setInitialWizardPrompt(prompt);
    setInitialWizardProductId(productId);
    // If we're opening from another tab, switch to the media plan tab
    if (activeTab !== 'mediaPlan') {
      setActiveTab('mediaPlan');
    }
    setIsWizardOpen(true);
  };
  
  // Override setActiveTab to implement lazy loading
  const handleSetActiveTab = (tab: ActiveTab) => {
    // Mark the tab as loaded
    markTabAsLoaded(tab);
    
    // Call the original setActiveTab
    setActiveTab(tab);
  };
  
  // Handler for opening the Funnel Campaign Wizard
  const handleOpenFunnelWizard = () => {
    setIsFunnelWizardOpen(true);
  };

  return (
    <div className="w-full bg-white h-screen flex flex-col max-w-screen-2xl mx-auto shadow-lg border-x border-gray-200">
      <Header 
        activeTab={activeTab}
        setActiveTab={handleSetActiveTab}
        onSaveProject={onSaveProject}
        isSavingProject={isSavingProject}
        autoSaveStatus={autoSaveStatus}
        onOpenSettings={onOpenSettings}
        onOpenIntegrations={onOpenIntegrations}
        onStartOver={onStartOver}
        language={settings.language}
      />

      <main className="flex-grow overflow-hidden">
        <Suspense fallback={<div>Loading...</div>}>
          {activeTab === 'brandKit' && (
            <AssetDisplay 
              assets={assets}
              onGenerateImage={(prompt, key, aspectRatio) => onGenerateImage(prompt, key, aspectRatio, undefined)}
              onSetImage={(dataUrl, key) => onSetImage(dataUrl, key, undefined)}
              generatedImages={generatedImages}
              isGeneratingImage={isGeneratingImage}
              language={settings.language}
              onExport={onExportBrandKit}
              isExporting={isExportingBrandKit}
            />
          )}
          {activeTab === 'mediaPlan' && (
            <MediaPlanDisplay 
              plans={assets.mediaPlans}
              personas={assets.personas || []}
              affiliateLinks={assets.affiliateLinks || []}
              onOpenWizard={handleOpenWizard}
              onGenerateImage={onGenerateImage}
              onSetImage={onSetImage}
              generatedImages={generatedImages}
              generatedVideos={generatedVideos}
              onSetVideo={onSetVideo}
              isGeneratingImage={isGeneratingImage}
              settings={settings}
              onExport={onExportPlan}
              isExporting={isExportingPlan}
              onRegenerateWeekImages={onRegenerateWeekImages}
              // New props for on-demand loading
              planGroupsList={mediaPlanGroupsList}
              onSelectPlan={onSelectPlan}
              activePlanId={activePlanId}
              onUpdatePost={onUpdatePost}
              onRefinePost={onRefinePost}
              onAssignPersonaToPlan={onAssignPersonaToPlan}
              // KhongMinh Props
              analyzingPostIds={analyzingPostIds}
              isAnyAnalysisRunning={isAnyAnalysisRunning}
              khongMinhSuggestions={khongMinhSuggestions}
              onAcceptSuggestion={onAcceptSuggestion}
              onRunKhongMinhForPost={onRunKhongMinhForPost}
              // On-demand prompt generation
              generatingPromptKeys={generatingPromptKeys}
              onGeneratePrompt={onGeneratePrompt}
              // Comment Generation
              onGenerateAffiliateComment={onGenerateAffiliateComment}
              generatingCommentPostIds={generatingCommentPostIds}
              // Selection and Scheduling
              selectedPostIds={selectedPostIds}
              onTogglePostSelection={onTogglePostSelection}
              onSelectAllPosts={onSelectAllPosts}
              onClearSelection={onClearSelection}
              onOpenScheduleModal={onOpenScheduleModal}
              onOpenBulkScheduleModal={onOpenBulkScheduleModal}
              onPostDrop={onPostDrop}
              onPublishPost={onPublishPost} // Pass the new prop
              // Bulk Actions
              isPerformingBulkAction={isPerformingBulkAction}
              onBulkGenerateImages={onBulkGenerateImages}
              onBulkSuggestPromotions={onBulkSuggestPromotions}
              onBulkGenerateComments={onBulkGenerateComments}
              brandFoundation={brandFoundation}
              // New prop for opening funnel wizard
              onOpenFunnelWizard={handleOpenFunnelWizard}
            />
          )}
          {activeTab === 'strategy' && (
            <StrategyDisplay
              language={settings.language}
              trends={assets.trends || []}
              ideas={assets.ideas || []}
              personas={assets.personas || []}
              affiliateLinks={assets.affiliateLinks || []}
              generatedImages={generatedImages}
              settings={settings}
              onSaveTrend={onSaveTrend}
              onDeleteTrend={onDeleteTrend}
              onGenerateIdeas={onGenerateIdeas}
              onCreatePlanFromIdea={handleOpenWizard}
              onGenerateContentPackage={onGenerateContentPackage}
              isGeneratingIdeas={isGeneratingPlan}
              onGenerateFacebookTrends={onGenerateTrendsFromSearch}
              isGeneratingTrendsFromSearch={isGeneratingTrendsFromSearch}
              productTrendToSelect={productTrendToSelect}
              onLoadIdeasForTrend={onLoadIdeasForTrend}
              // Lazy loading props
              isDataLoaded={props.isStrategyHubDataLoaded}
              onLoadData={props.onLoadStrategyHubData}
              isLoading={props.isLoadingStrategyHubData}
            />
          )}
          {activeTab === 'affiliateVault' && (
            <AffiliateVaultDisplay 
              affiliateLinks={assets.affiliateLinks || []}
              onSaveLink={onSaveAffiliateLink}
              onDeleteLink={onDeleteAffiliateLink}
              onImportLinks={onImportAffiliateLinks}
              onReloadLinks={props.onReloadLinks}
              onGenerateIdeasFromProduct={props.onGenerateIdeasFromProduct}
              language={settings.language}
              // Lazy loading props
              isDataLoaded={props.isAffiliateVaultDataLoaded}
              onLoadData={props.onLoadAffiliateVaultData}
              isLoading={props.isLoadingAffiliateVaultData}
            />
          )}
          {activeTab === 'personas' && (
            <PersonasDisplay
              personas={assets.personas || []}
              generatedImages={generatedImages}
              onSavePersona={onSavePersona}
              onDeletePersona={onDeletePersona}
              onSetPersonaImage={onSetPersonaImage}
              isUploadingImage={isUploadingImage}
              language={settings.language}
              onUpdatePersona={props.onUpdatePersona}
              // Lazy loading props
              isDataLoaded={props.isPersonasDataLoaded}
              onLoadData={props.onLoadPersonasData}
              isLoading={props.isLoadingPersonasData}
            />
          )}
        </Suspense>
      </main>
      
      <ScheduleModal
        isOpen={!!schedulingPost}
        onClose={() => onOpenScheduleModal(null)}
        schedulingPost={schedulingPost}
        onSchedule={onSchedulePost}
        isScheduling={isScheduling}
        language={settings.language}
      />

      <BulkScheduleModal
        isOpen={isBulkScheduleModalOpen}
        onClose={onCloseBulkScheduleModal}
        onSchedule={onBulkSchedule}
        isScheduling={isScheduling}
        language={settings.language}
        selectedCount={selectedPostIds.size}
      />

      <MediaPlanWizardModal
        isOpen={isWizardOpen}
        onClose={() => { setIsWizardOpen(false); setInitialWizardPrompt(''); setInitialWizardProductId(undefined); }}
        settings={settings}
        onGenerate={onGeneratePlan}
        isGenerating={isGeneratingPlan}
        personas={assets.personas || []}
        generatedImages={generatedImages}
        initialPrompt={initialWizardPrompt}
        affiliateLinks={assets.affiliateLinks || []}
        initialProductId={initialWizardProductId}
      />
      
      {/* Funnel Campaign Wizard Modal */}
      <FunnelCampaignWizard
        isOpen={isFunnelWizardOpen}
        onClose={() => setIsFunnelWizardOpen(false)}
        personas={assets.personas || []}
        affiliateLinks={assets.affiliateLinks || []}
        language={settings.language}
        onCreatePlan={onCreateFunnelCampaignPlan}
        generatedImages={generatedImages}
      />
    </div>
  );
};

export default MainDisplay;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MainDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanDisplay.tsx ---\nimport React, { useState, useMemo, useEffect, useRef } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import type { MediaPlanGroup, MediaPlanPost, Settings, AffiliateLink, SchedulingPost, Persona, PostInfo, Idea } from '../types';
import { Button, Input, Select } from './ui';
import { 
  ArchiveIcon, 
  SparklesIcon, 
  PlusIcon, 
  CalendarIcon, 
  CollectionIcon, 
  TagIcon, 
  YouTubeIcon, 
  FacebookIcon, 
  InstagramIcon, 
  TikTokIcon, 
  PinterestIcon, 
  KhongMinhIcon, 
  ChatBubbleLeftIcon, 
  SearchIcon, 
  PencilIcon, 
  PhotographIcon, 
  CheckSolidIcon, 
  TrashIcon, 
  ListBulletIcon, 
  LightBulbIcon, 
  LinkIcon, 
  DotsVerticalIcon, 
  ChevronDownIcon, 
  ChevronLeftIcon, 
  ChevronRightIcon, 
  UsersIcon,
  FunnelIcon // New icon import
} from './icons';
import PostCard from './PostCard';
import PostDetailModal from './PostDetailModal';
import CalendarView from './CalendarView';
import { useInfiniteScroll } from '../hooks/useInfiniteScroll';

interface MediaPlanDisplayProps {
  plans: MediaPlanGroup[];
  personas: Persona[];
  affiliateLinks: AffiliateLink[];
  onOpenWizard: (prompt?: string) => void;
  onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9", postInfo?: PostInfo) => void;
  onSetImage: (dataUrl: string, key: string, postInfo?: PostInfo) => void;
  generatedImages: Record<string, string>;
  generatedVideos: Record<string, string>;
  onSetVideo: (dataUrl: string, key: string, postInfo: PostInfo) => void;
  isGeneratingImage: (key: string) => boolean;
  settings: Settings;
  onExport: () => void;
  isExporting: boolean;
  onRegenerateWeekImages: (planId: string, weekIndex: number) => void;
  planGroupsList: {id: string; name: string; prompt: string; source?: MediaPlanGroup['source']; productImages?: { name: string, type: string, data: string }[], personaId?: string;}[];
  onSelectPlan: (planId: string, assetsToUse?: GeneratedAssets, plansList?: {id: string, name: string, prompt: string, productImages?: { name: string, type: string, data: string }[]}[]) => void;
  activePlanId: string | null;
  onUpdatePost: (postInfo: PostInfo) => void;
  onRefinePost: (text: string) => Promise<string>;
  onAssignPersonaToPlan: (planId: string, personaId: string | null) => void;
  // KhongMinh Props
  analyzingPostIds: Set<string>;
  isAnyAnalysisRunning: boolean;
  khongMinhSuggestions: Record<string, AffiliateLink[]>;
  onAcceptSuggestion: (postInfo: PostInfo, productId: string) => void;
  onRunKhongMinhForPost: (postInfo: PostInfo) => void;
  // On-demand prompt generation
  generatingPromptKeys: Set<string>;
  onGeneratePrompt: (postInfo: PostInfo) => Promise<MediaPlanPost | null>;
  // Comment Generation
  onGenerateAffiliateComment: (postInfo: PostInfo) => Promise<MediaPlanPost | null>;
  generatingCommentPostIds: Set<string>;
  // Selection & Scheduling
  selectedPostIds: Set<string>;
  onTogglePostSelection: (postId: string) => void;
  onSelectAllPosts: (posts: PostInfo[]) => void;
  onClearSelection: () => void;
  onOpenScheduleModal: (post: SchedulingPost | null) => void;
  onOpenBulkScheduleModal: () => void;
  onPostDrop: (postInfo: SchedulingPost, newDate: Date) => void;
  // Bulk Actions
  isPerformingBulkAction: boolean;
  onBulkGenerateImages: (posts: PostInfo[]) => void;
  onBulkSuggestPromotions: (posts: PostInfo[]) => void;
  onBulkGenerateComments: (posts: PostInfo[]) => void;
  onPublishPost: (postInfo: PostInfo) => void; // New prop for direct publishing
  brandFoundation: GeneratedAssets['brandFoundation'];
  // New prop for opening funnel wizard
  onOpenFunnelWizard: () => void;
}

const MediaPlanDisplay: React.FC<MediaPlanDisplayProps> = (props) => {
  const { 
    plans, 
    personas, 
    settings, 
    onExport, 
    isExporting, 
    onOpenWizard, 
    planGroupsList, 
    onSelectPlan, 
    activePlanId, 
    isAnyAnalysisRunning, 
    onUpdatePost, 
    onOpenScheduleModal, 
    onOpenBulkScheduleModal, 
    onPostDrop, 
    isPerformingBulkAction, 
    onBulkGenerateImages, 
    onBulkSuggestPromotions, 
    onBulkGenerateComments, 
    onAssignPersonaToPlan, 
    onPublishPost, 
    brandFoundation,
    onOpenFunnelWizard // New prop
  } = props;
  const { language } = settings;
  const [viewingPost, setViewingPost] = useState<PostInfo | null>(null);
    const [viewMode, setViewMode] = useState<'feed' | 'calendar'>('feed');
    const [isPlanSidebarOpen, setIsPlanSidebarOpen] = useState(false);
    const [isFilterOpen, setIsFilterOpen] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>([]);
    const [selectedStatuses, setSelectedStatuses] = useState<string[]>([]);
    const [sortBy, setSortBy] = useState('date-desc');
    
    const [currentPage, setCurrentPage] = useState(1);

  const T = {
    'Việt Nam': { 
      export_plans: 'Xuất Kế hoạch', 
      exporting: 'Đang xuất...', 
      select_plan_title: "Chọn một Kế hoạch",
      select_plan_subtitle: "Chọn một kế hoạch từ thanh bên để xem chi tiết, hoặc tạo một kế hoạch mới.",
      generate_plan_title: "Tạo Kế hoạch Đầu tiên của bạn",
      generate_plan_subtitle: "Bắt đầu chiến lược nội dung của bạn.",
      plans_sidebar_title: "Kế hoạch",
      plan_prompt: "Prompt",
      pkgLabel: "Gói ND",
      newPlanButton: "Kế hoạch Mới",
      newFunnelPlanButton: "Chiến dịch Funnel", // New button text
      kpiTotalPosts: "Tổng số bài đăng",
      kpiPlatforms: "Nền tảng được sử dụng",
      kpiPostsThisWeek: "Bài đăng tuần này",
      assignPersona: "Gán KOL/KOC",
      noPersonaAssigned: "Chưa gán KOL/KOC",
      listViewTitle: "Dòng nội dung",
      filter_search: "Tìm kiếm bài đăng...",
      filter_sort_by: "Sắp xếp theo",
      filter_sort_date_desc: "Ngày (Mới nhất)",
      filter_sort_date_asc: "Ngày (Cũ nhất)",
      filter_sort_title_asc: "Tiêu đề (A-Z)",
      filter_sort_title_desc: "Tiêu đề (Z-A)",
      filter_platforms: "Nền tảng:",
      filter_status: "Trạng thái:",
      filter_status_scheduled: "Đã lên lịch",
      filter_status_draft: "Bản nháp",
      filter_status_published: "Đã đăng",
      filter_status_promo: "Có khuyến mãi",
      filter_status_comment: "Có bình luận",
      filter_status_image: "Có ảnh",
      filter_no_results: "Không tìm thấy bài đăng nào",
      filter_no_results_desc: "Thử xóa một số bộ lọc để xem nhiều kết quả hơn.",
      selection_title: "Đã chọn:",
      selection_clear: "Xóa",
      selection_schedule: "Lên lịch",
      selection_delete: "Xóa",
      selection_gen_images: "Tạo ảnh",
      selection_sug_promo: "Gợi ý KM",
      selection_gen_comment: "Tạo BL (NgoSiLien)",
      view_toggle_feed: "Dạng Lưới",
      view_toggle_calendar: "Dạng Lịch",
      filters_title: "Bộ lọc",
      select_plan_mobile: "Chọn Kế hoạch",
    },
    'English': { 
      export_plans: 'Export Plan', 
      exporting: 'Exporting...', 
      select_plan_title: "Select a Plan",
      select_plan_subtitle: "Choose a plan from the sidebar to see its details, or generate a new one.",
      generate_plan_title: "Generate Your First Plan",
      generate_plan_subtitle: "Kickstart your content strategy.",
      plans_sidebar_title: "Plans",
      plan_prompt: "Prompt",
      pkgLabel: "Content Pkg",
      newPlanButton: "New Plan",
      newFunnelPlanButton: "Funnel Campaign", // New button text
      kpiTotalPosts: "Total Posts",
      kpiPlatforms: "Platforms Used",
      kpiPostsThisWeek: "Posts This Week",
      assignPersona: "Assign KOL/KOC",
      noPersonaAssigned: "No KOL/KOC Assigned",
      listViewTitle: "Content Feed",
      filter_search: "Search posts...",
      filter_sort_by: "Sort by",
      filter_sort_date_desc: "Date (Newest)",
      filter_sort_date_asc: "Date (Oldest)",
      filter_sort_title_asc: "Title (A-Z)",
      filter_sort_title_desc: "Title (Z-A)",
      filter_platforms: "Platforms:",
      filter_status: "Status:",
      filter_status_scheduled: "Scheduled",
      filter_status_draft: "Draft",
      filter_status_published: "Published",
      filter_status_promo: "Has Promo",
      filter_status_comment: "Has Comment",
      filter_status_image: "Has Image",
      filter_no_results: "No posts found",
      filter_no_results_desc: "Try clearing some filters to see more results.",
      selection_title: "Selected:",
      selection_clear: "Clear",
      selection_schedule: "Schedule",
      selection_delete: "Delete",
      selection_gen_images: "Gen. Images",
      selection_sug_promo: "Sug. Promos",
      selection_gen_comment: "Gen. Comments (NgoSiLien)",
      view_toggle_feed: "Feed View",
      view_toggle_calendar: "Calendar View",
      filters_title: "Filters",
      select_plan_mobile: "Select Plan",
    }
  };
  const currentTexts = (T as any)[language] || T['English'];

  const unifiedSidebarItems = useMemo(() => {
    return (planGroupsList || []).map(group => ({
      id: group.id,
      name: group.name,
      description: `${currentTexts.plan_prompt}: "${group.prompt}"`,
      source: group.source,
    }));
  }, [planGroupsList, currentTexts.plan_prompt]);

  const selectedPlan = useMemo(() => {
    if (!activePlanId) return null;
    return plans.find(p => p.id === activePlanId) || null;
  }, [activePlanId, plans]);

  // Get initial posts from the selected plan
  const initialPosts = useMemo(() => {
    if (!selectedPlan) return [];
    return selectedPlan.plan.flatMap(week => week.posts || []);
  }, [selectedPlan]);

  // Use the infinite scroll hook
  const { 
    posts: paginatedPosts, 
    loadMorePosts, 
    hasMore, 
    loading: isLoadingMorePosts,
    error: paginationError,
    totalPosts
  } = useInfiniteScroll(activePlanId, initialPosts);

  // Calculate total pages for pagination display
  const totalPages = useMemo(() => {
    return Math.ceil(totalPosts / 30);
  }, [totalPosts]);


  // This effect ensures that if the modal is open (`viewingPost` is not null),
  // and the underlying data changes (e.g., after an image generation),
  // the modal's data (`viewingPost`) is updated to reflect those changes.
  useEffect(() => {
    if (!viewingPost) return;

    const plan = plans.find(p => p.id === viewingPost.planId);
    const updatedPost = plan?.plan[viewingPost.weekIndex]?.posts[viewingPost.postIndex];
    
    if (updatedPost && updatedPost.id === viewingPost.post.id) {
      if (JSON.stringify(updatedPost) !== JSON.stringify(viewingPost.post)) {
        setViewingPost(prev => prev ? { ...prev, post: updatedPost } : null);
      }
    } else {
      // Post was not found (e.g., plan changed), close the modal
      setViewingPost(null);
    }
  }, [plans, viewingPost]);

  const handleViewDetails = (postInfo: PostInfo) => {
    setViewingPost(postInfo);
  };
  
  const platformOptions = [
    { id: 'YouTube', Icon: YouTubeIcon }, { id: 'Facebook', Icon: FacebookIcon }, { id: 'Instagram', Icon: InstagramIcon }, { id: 'TikTok', Icon: TikTokIcon }, { id: 'Pinterest', Icon: PinterestIcon }
  ];

  const statusOptions = [
    { id: 'published', text: currentTexts.filter_status_published, Icon: CheckSolidIcon },
    { id: 'scheduled', text: currentTexts.filter_status_scheduled, Icon: CalendarIcon },
    { id: 'draft', text: currentTexts.filter_status_draft, Icon: PencilIcon },
    { id: 'promo', text: currentTexts.filter_status_promo, Icon: KhongMinhIcon },
    { id: 'comment', text: currentTexts.filter_status_comment, Icon: ChatBubbleLeftIcon },
    { id: 'image', text: currentTexts.filter_status_image, Icon: PhotographIcon },
  ];

  const { planKPIs, assignedPersona } = useMemo(() => {
    if (!selectedPlan) return { planKPIs: { totalPosts: 0, platformCount: 0, postsThisWeek: 0 }, assignedPersona: null };
    
    const allPosts = selectedPlan.plan.flatMap(w => w.posts || []);
    const platformCount = new Set(allPosts.map(p => p.platform)).size;
    
    const postsThisWeek = selectedPlan.plan[0]?.posts?.length || 0;
    
    const persona = personas.find(p => p.id === selectedPlan.personaId);

    return {
      planKPIs: {
        totalPosts: allPosts.length,
        platformCount,
        postsThisWeek
      },
      assignedPersona: persona || null
    };
  }, [selectedPlan, personas]);

      // Convert paginated posts to PostInfo format
    const paginatedPostInfos = useMemo(() => {
        if (!selectedPlan) return [];
        
        // Since we're getting posts directly, we need to map them to PostInfo format
        // This is a simplified version - in a real implementation, you'd track weekIndex and postIndex
        return paginatedPosts.map((post, index) => ({
            planId: selectedPlan.id,
            weekIndex: 0, // This would need to be calculated properly in a real implementation
            postIndex: index,
            post,
        }));
    }, [paginatedPosts, selectedPlan]);

    const displayedPosts = useMemo(() => {
        let filteredPosts = [...paginatedPostInfos];

        if (searchQuery) {
            filteredPosts = filteredPosts.filter(p =>
                p.post.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                p.post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
                (p.post.hashtags || []).join(' ').toLowerCase().includes(searchQuery.toLowerCase())
            );
        }

        if (selectedPlatforms.length > 0) {
            filteredPosts = filteredPosts.filter(p => selectedPlatforms.includes(p.post.platform));
        }

        if (selectedStatuses.length > 0) {
            filteredPosts = filteredPosts.filter(p => {
                const imageUrl = p.post.imageKey ? props.generatedImages[p.post.imageKey] : undefined;
                return selectedStatuses.every(status => {
                    switch (status) {
                        case 'published': return p.post.status === 'published';
                        case 'scheduled': return p.post.status === 'scheduled';
                        case 'draft': return p.post.status === 'draft' || !p.post.status;
                        case 'promo': return (p.post.promotedProductIds?.length || 0) > 0;
                        case 'comment': return !!p.post.autoComment;
                        case 'image': return !!imageUrl;
                        default: return true;
                    }
                });
            });
        }

        filteredPosts.sort((a, b) => {
            const [key, dir] = sortBy.split('-');
            const isAsc = dir === 'asc';

            if (key === 'date') {
                const dateA = a.post.publishedAt ? new Date(a.post.publishedAt).getTime() : (a.post.scheduledAt ? new Date(a.post.scheduledAt).getTime() : 0);
                const dateB = b.post.publishedAt ? new Date(b.post.publishedAt).getTime() : (b.post.scheduledAt ? new Date(b.post.scheduledAt).getTime() : 0);
                if (dateA === 0 && dateB !== 0) return 1;
                if (dateB === 0 && dateA !== 0) return -1;
                return isAsc ? dateA - dateB : dateB - dateA;
            }

            if (key === 'title') {
                return isAsc ? a.post.title.localeCompare(b.post.title) : b.post.title.localeCompare(a.post.title);
            }
            return 0;
        });

        return filteredPosts;
    }, [paginatedPostInfos, searchQuery, selectedPlatforms, selectedStatuses, sortBy, props.generatedImages]);
  
  const handlePlatformToggle = (platformId: string) => {
    setSelectedPlatforms(prev => prev.includes(platformId) ? prev.filter(p => p !== platformId) : [...prev, platformId]);
  };
  
  const handleStatusToggle = (statusId: string) => {
    setSelectedStatuses(prev => prev.includes(statusId) ? prev.filter(s => s !== statusId) : [...prev, statusId]);
  };
  
  const isAllDisplayedSelected = displayedPosts.length > 0 && props.selectedPostIds.size === displayedPosts.length && displayedPosts.every(p => props.selectedPostIds.has(p.post.id));

  const handleSelectAllToggle = () => {
    if (isAllDisplayedSelected) {
      props.onClearSelection();
    } else {
      props.onSelectAllPosts(displayedPosts);
    }
  };
  
  const handleBulkAction = (action: (posts: PostInfo[]) => void) => {
    const selectedPostsInOrder = displayedPosts.filter(p => props.selectedPostIds.has(p.post.id));
    action(selectedPostsInOrder);
  };

  const FilterToggleButton: React.FC<{ children: React.ReactNode, onClick: () => void, isActive: boolean }> = ({ children, onClick, isActive }) => (
    <button
      onClick={onClick}
      className={`px-3 py-1.5 rounded-md text-sm font-medium border-2 transition-colors flex items-center gap-2 ${isActive ? 'bg-green-50 border-brand-green shadow-sm' : 'bg-white border-gray-200 hover:border-gray-300'}`}
    >
      {children}
    </button>
  );

  const showFeed = viewMode === 'feed';
  const showCalendar = viewMode === 'calendar';

  const sidebarContent = (
    <div className="p-6 flex flex-col h-full bg-white">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-4">
        <h2 className="text-xl font-bold font-sans text-gray-900 shrink-0">{currentTexts.plans_sidebar_title}</h2>
        <div className="flex flex-col items-stretch gap-2 shrink-0">
          {/* New Funnel Campaign button */}
          <Button 
            onClick={onOpenFunnelWizard}
            variant="secondary" 
            className="w-full whitespace-nowrap flex items-center justify-center gap-2 rounded-md px-3 py-2"
          >
            <FunnelIcon className="h-5 w-5" />
            <span>{currentTexts.newFunnelPlanButton}</span>
          </Button>
          <Button 
            onClick={() => onOpenWizard()}
            variant="primary" 
            className="w-full whitespace-nowrap flex items-center justify-center gap-2 rounded-md px-3 py-2"
          >
            <PlusIcon className="h-5 w-5" />
            <span>{currentTexts.newPlanButton}</span>
          </Button>
        </div>
      </div>
      <div className="space-y-2 flex-grow overflow-y-auto">
         {unifiedSidebarItems.map(item => (
          <button
            key={item.id}
            onClick={() => {onSelectPlan(item.id); setIsPlanSidebarOpen(false);}}
            className={`w-full text-left p-4 rounded-lg transition-colors border-2 ${activePlanId === item.id ? 'bg-green-50 border-brand-green' : 'bg-white hover:bg-gray-100 border-gray-200'}`}
          >
            <div className="flex justify-between items-start">
               <h3 className="font-bold font-sans text-gray-900">{item.name}</h3>
               {item.source === 'content-package' && (
                <span className="text-xs font-semibold px-2 py-0.5 rounded-full bg-blue-100 text-blue-800">{currentTexts.pkgLabel}</span>
               )}
            </div>
            <p className="text-sm text-gray-500 mt-1 font-serif truncate">{item.description}</p>
          </button>
        ))}
        {unifiedSidebarItems.length === 0 && (
           <div className="text-center py-10 text-gray-400 border-2 border-dashed border-gray-300 rounded-lg">
             <p>{currentTexts.generate_plan_subtitle}</p>
           </div>
        )}
      </div>
       <div className="mt-auto pt-4 flex flex-col gap-2">
         <Button 
            onClick={onExport} 
            disabled={isExporting || plans.length === 0}
            variant="tertiary" 
            className="w-full flex items-center justify-center gap-2"
          >
            {isExporting ? <div className="w-5 h-5 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div> : <ArchiveIcon className="h-5 w-5" />}
            {currentTexts.export_plans}
          </Button>
        </div>
      </div>
    );

    return (
      <div className="flex flex-col xl:flex-row h-full bg-gray-50/50">
        {/* Mobile sidebar overlay */}
        {isPlanSidebarOpen && (
          <div className="xl:hidden fixed inset-0 bg-black/30 z-30" onClick={() => setIsPlanSidebarOpen(false)}></div>
        )}
        {/* Sidebar */}
        <aside className={`fixed xl:relative inset-y-0 left-0 w-80 md:w-96 border-r border-gray-200 transform transition-transform z-40 ${isPlanSidebarOpen ? 'translate-x-0' : '-translate-x-full'} xl:translate-x-0 shrink-0`}>
          {sidebarContent}
        </aside>
        
        {/* Main Content Area */}
        <main className="flex-1 p-4 sm:p-6 lg:p-10 overflow-y-auto">
           {selectedPlan ? (
            <div className="max-w-7xl mx-auto">
              <header className="mb-8">
                <div className="flex items-start justify-between">
                  <div>
                    <h3 className="text-3xl font-bold font-sans text-gray-900">
                      {selectedPlan.name}
                    </h3>
                    <p className="text-lg text-gray-500 font-serif">
                      {selectedPlan.prompt}
                    </p>
                  </div>
                  <Button onClick={() => setIsPlanSidebarOpen(true)} className="xl:hidden flex-shrink-0 ml-4" variant="secondary">{currentTexts.select_plan_mobile}</Button>
                </div>

                <div className="mt-4 flex flex-wrap items-center gap-x-6 gap-y-4 text-sm text-gray-600 border-t border-gray-200 pt-4">
                  <div className="flex items-center gap-2">
                    <CollectionIcon className="h-5 w-5 text-gray-400" />
                    <p><span className="font-semibold text-gray-800">{planKPIs.totalPosts}</span> {language === 'Việt Nam' ? 'bài đăng' : 'posts'}</p>
                  </div>
                  <div className="flex items-center gap-2">
                    <TagIcon className="h-5 w-5 text-gray-400" />
                    <p><span className="font-semibold text-gray-800">{planKPIs.platformCount}</span> {language === 'Việt Nam' ? 'nền tảng' : 'platforms'}</p>
                  </div>
                  <div className="flex items-center gap-2">
                    <UsersIcon className="h-5 w-5 text-gray-400" />
                    {assignedPersona ? (
                      <div className="flex items-center gap-2 bg-white rounded-md p-2 shadow-sm border border-gray-200">
                        {assignedPersona.avatarImageUrl || (assignedPersona.photos.length > 0 && props.generatedImages[assignedPersona.photos[0].imageKey]) ? (
                          <img
                            src={assignedPersona.avatarImageUrl || props.generatedImages[assignedPersona.photos[0].imageKey]}
                            alt={assignedPersona.nickName}
                            className="h-8 w-8 rounded-full object-cover border border-gray-100"
                          />
                        ) : (
                          <div className="h-8 w-8 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-sm font-semibold">
                            <UsersIcon className="h-4 w-4" />
                          </div>
                        )}
                        <div>
                          <p className="text-sm font-semibold text-gray-800 leading-tight">{assignedPersona.nickName}</p>
                          <p className="text-xs text-gray-500 leading-tight">{assignedPersona.mainStyle} | {assignedPersona.activityField}</p>
                        </div>
                        <select
                          value={selectedPlan.personaId || ''}
                          onChange={(e) => onAssignPersonaToPlan(activePlanId!, e.target.value || null)}
                          className="text-sm bg-transparent border-gray-300 rounded-md py-1 pl-2 pr-8 focus:ring-brand-green focus:border-brand-green ml-2"
                        >
                          <option value="">{currentTexts.noPersonaAssigned}</option>
                          {personas.map(p => <option key={p.id} value={p.id}>{p.nickName}</option>)}
                        </select>
                      </div>
                    ) : (
                      <select
                        value={selectedPlan.personaId || ''}
                        onChange={(e) => onAssignPersonaToPlan(activePlanId!, e.target.value || null)}
                        className="text-sm bg-transparent border-gray-300 rounded-md py-1 pl-2 pr-8 focus:ring-brand-green focus:border-brand-green"
                      >
                        <option value="">{currentTexts.noPersonaAssigned}</option>
                        {personas.map(p => <option key={p.id} value={p.id}>{p.nickName}</option>)}
                      </select>
                    )}
                  </div>
                </div>
              </header>
              
              <div className="flex justify-center mb-8">
                <div className="inline-flex rounded-lg shadow-sm border border-gray-200 bg-white p-1">
                  <Button
                    variant={viewMode === 'feed' ? 'primary' : 'tertiary'}
                    onClick={() => setViewMode('feed')}
                    className={`!rounded-md px-4 py-1.5 flex items-center gap-2 !text-sm ${viewMode === 'feed' ? '' : 'text-gray-600'}`}
                  >
                    <ListBulletIcon className="h-5 w-5"/>
                    {currentTexts.view_toggle_feed}
                  </Button>
                  <Button
                     variant={viewMode === 'calendar' ? 'primary' : 'tertiary'}
                    onClick={() => setViewMode('calendar')}
                    className={`!rounded-md px-4 py-1.5 flex items-center gap-2 !text-sm ${viewMode === 'calendar' ? '' : 'text-gray-600'}`}
                  >
                    <CalendarIcon className="h-5 w-5"/>
                    {currentTexts.view_toggle_calendar}
                  </Button>
                </div>
              </div>
              
              {showFeed && (
                <div>
                  <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm mb-8">
                    <button onClick={() => setIsFilterOpen(!isFilterOpen)} className="w-full flex justify-between items-center font-semibold md:hidden">
                      <span>{currentTexts.filters_title}</span>
                      <ChevronDownIcon className={`h-5 w-5 transition-transform ${isFilterOpen ? 'rotate-180' : ''}`} />
                    </button>
                    <div className={`space-y-4 ${isFilterOpen ? 'mt-4' : 'hidden'} md:block`}>
                      {props.selectedPostIds.size > 0 && (
                        <div className="fixed bottom-0 left-0 right-0 p-3 bg-white/95 backdrop-blur-sm border-t-2 border-brand-green shadow-lg z-20 animate-fade-in md:relative md:bottom-auto md:p-3 md:bg-green-50 md:border md:border-green-200 md:rounded-lg md:shadow-sm">
                          <div className="flex flex-col sm:flex-row items-start sm:items-center gap-4">
                            <div className="flex items-center gap-3 flex-shrink-0">
                              <input
                                type="checkbox"
                                className="h-5 w-5 rounded border-gray-300 text-brand-green focus:ring-brand-green"
                                checked={isAllDisplayedSelected}
                                onChange={handleSelectAllToggle}
                                aria-label="Select all displayed posts"
                                disabled={isPerformingBulkAction}
                              />
                              <span className="font-semibold text-gray-800">{currentTexts.selection_title} {props.selectedPostIds.size}</span>
                              <Button variant="tertiary" onClick={props.onClearSelection} className="text-sm py-1 px-2" disabled={isPerformingBulkAction}>{currentTexts.selection_clear}</Button>
                            </div>
                            <div className="flex items-center gap-2 sm:ml-auto flex-wrap justify-end">
                              <Button onClick={() => handleBulkAction(onBulkGenerateImages)} disabled={isPerformingBulkAction} variant="secondary" className="bg-white text-sm py-1.5 px-3 flex items-center gap-1.5"><PhotographIcon className="h-4 w-4" /> {currentTexts.selection_gen_images}</Button>
                              <Button onClick={() => handleBulkAction(onBulkSuggestPromotions)} disabled={isPerformingBulkAction} variant="secondary" className="bg-white text-sm py-1.5 px-3 flex items-center gap-1.5"><KhongMinhIcon className="h-4 w-4" /> {currentTexts.selection_sug_promo}</Button>
                              <Button onClick={() => handleBulkAction(onBulkGenerateComments)} disabled={isPerformingBulkAction} variant="secondary" className="bg-white text-sm py-1.5 px-3 flex items-center gap-1.5"><ChatBubbleLeftIcon className="h-4 w-4" /> {currentTexts.selection_gen_comment}</Button>
                              <Button onClick={onOpenBulkScheduleModal} disabled={isPerformingBulkAction} className="text-sm py-1.5 px-3 flex items-center gap-1.5"><CalendarIcon className="h-4 w-4" /> {currentTexts.selection_schedule}</Button>
                              <Button variant="secondary" className="bg-white text-red-600 border-red-200 hover:bg-red-50 text-sm py-1.5 px-3 flex items-center gap-1.5" disabled={isPerformingBulkAction}><TrashIcon className="h-4 w-4" /> {currentTexts.selection_delete}</Button>
                            </div>
                          </div>
                        </div>
                      )}

                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="relative">
                          <Input placeholder={currentTexts.filter_search} value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="pl-10" />
                          <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
                        </div>
                        <div className="flex items-center gap-2">
                          <label htmlFor="sort-by" className="text-sm font-medium text-gray-700 flex-shrink-0">{currentTexts.filter_sort_by}:</label>
                          <Select id="sort-by" value={sortBy} onChange={(e) => setSortBy(e.target.value)} className="w-full">
                            <option value="date-desc">{currentTexts.filter_sort_date_desc}</option>
                            <option value="date-asc">{currentTexts.filter_sort_date_asc}</option>
                            <option value="title-asc">{currentTexts.filter_sort_title_asc}</option>
                            <option value="title-desc">{currentTexts.filter_sort_title_desc}</option>
                          </Select>
                        </div>
                      </div>
                      <div className="flex items-center gap-3 flex-wrap">
                        <span className="text-sm font-medium text-gray-700">{currentTexts.filter_platforms}</span>
                        {platformOptions.map(({ id, Icon }) => (
                          <FilterToggleButton key={id} onClick={() => handlePlatformToggle(id)} isActive={selectedPlatforms.includes(id)}>
                            <Icon className="h-5 w-5" />
                          </FilterToggleButton>
                        ))}
                      </div>
                      <div className="flex items-center gap-3 flex-wrap">
                        <span className="text-sm font-medium text-gray-700">{currentTexts.filter_status}</span>
                        {statusOptions.map(({ id, text, Icon }) => (
                          <FilterToggleButton key={id} onClick={() => handleStatusToggle(id)} isActive={selectedStatuses.includes(id)}>
                            <Icon className={`h-4 w-4 ${selectedStatuses.includes(id) ? 'text-brand-green' : 'text-gray-500'}`} />
                            <span>{text}</span>
                          </FilterToggleButton>
                        ))}
                      </div>
                    </div>
                  </div>

                  <div className={`${props.selectedPostIds.size > 0 ? 'pb-24 md:pb-0' : ''}`}>
                    <div className="flex justify-between items-center mb-6">
                      <h2 className="text-2xl font-bold font-sans text-gray-900">{currentTexts.listViewTitle}</h2>
                    </div>
                    {displayedPosts.length > 0 ? (
                      <>
                        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                          {displayedPosts.map(postInfo => {
                            const promotedProductsCount = postInfo.post.promotedProductIds?.length || 0;
                            return (
                              <PostCard
                                key={postInfo.post.id}
                                postInfo={postInfo}
                                language={language}
                                imageUrl={postInfo.post.imageKey ? props.generatedImages[postInfo.post.imageKey] : undefined}
                                videoUrl={postInfo.post.videoKey ? props.generatedVideos[postInfo.post.videoKey] : undefined}
                                promotedProductsCount={promotedProductsCount}
                                isDraft={postInfo.post.status === 'draft' || (!postInfo.post.status && !postInfo.post.scheduledAt)}
                                isSelected={props.selectedPostIds.has(postInfo.post.id)}
                                onToggleSelection={() => props.onTogglePostSelection(postInfo.post.id)}
                                onViewDetails={handleViewDetails}
                                scheduledAt={postInfo.post.scheduledAt}
                                publishedAt={postInfo.post.publishedAt}
                                publishedUrl={postInfo.post.publishedUrl}
                              />
                            )
                          })}
                        </div>
                        
                        {/* Infinite Scroll Trigger */}
                        {hasMore && (
                          <div className="mt-8 flex justify-center">
                            <Button
                              onClick={loadMorePosts}
                              disabled={isLoadingMorePosts}
                              variant="secondary"
                              className="flex items-center gap-2"
                            >
                              {isLoadingMorePosts ? (
                                <>
                                  <div className="w-5 h-5 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div>
                                  {language === 'Việt Nam' ? 'Đang tải...' : 'Loading...'}
                                </>
                              ) : (
                                <>
                                  <ChevronDownIcon className="h-5 w-5" />
                                  {language === 'Việt Nam' ? 'Tải thêm bài đăng' : 'Load more posts'}
                                </>
                              )}
                            </Button>
                          </div>
                        )}
                        
                        {/* Manual Pagination Controls (fallback) */}
                        {totalPages > 1 && (
                          <div className="mt-8 flex items-center justify-between border-t border-gray-200 pt-6">
                            <div className="flex items-center">
                              <span className="text-sm text-gray-700">
                                {language === 'Việt Nam' 
                                  ? `Trang ${currentPage} trên ${totalPages}` 
                                  : `Page ${currentPage} of ${totalPages}`}
                              </span>
                            </div>
                            <div className="flex items-center space-x-2">
                              <Button
                                onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                                disabled={currentPage === 1}
                                variant="tertiary"
                                className="flex items-center gap-1"
                              >
                                <ChevronLeftIcon className="h-4 w-4" />
                                {language === 'Việt Nam' ? 'Trước' : 'Previous'}
                              </Button>
                              
                              {/* Page numbers */}
                              {[...Array(Math.min(5, totalPages))].map((_, i) => {
                                const pageNum = 
                                  totalPages <= 5 
                                    ? i + 1 
                                    : currentPage <= 3 
                                      ? i + 1 
                                      : currentPage >= totalPages - 2 
                                        ? totalPages - 4 + i 
                                        : currentPage - 2 + i;
                                        
                                return (
                                  <Button
                                    key={pageNum}
                                    onClick={() => setCurrentPage(pageNum)}
                                    variant={currentPage === pageNum ? 'primary' : 'tertiary'}
                                    className={`w-10 h-10 ${currentPage === pageNum ? '' : 'text-gray-700'}`}
                                  >
                                    {pageNum}
                                  </Button>
                                );
                              })}
                              
                              <Button
                                onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                                disabled={currentPage === totalPages}
                                variant="tertiary"
                                className="flex items-center gap-1"
                              >
                                {language === 'Việt Nam' ? 'Tiếp' : 'Next'}
                                <ChevronRightIcon className="h-4 w-4" />
                              </Button>
                            </div>
                            <div className="flex items-center">
                              <span className="text-sm text-gray-700">
                                {language === 'Việt Nam' 
                                  ? `${displayedPosts.length} bài đăng` 
                                  : `${displayedPosts.length} posts`}
                              </span>
                            </div>
                          </div>
                        )}
                      </>
                    ) : (
                      <div className="text-center py-16 bg-white rounded-lg border-2 border-dashed">
                        <SearchIcon className="mx-auto h-12 w-12 text-gray-400"/>
                        <h3 className="mt-2 text-xl font-semibold text-gray-900">{currentTexts.filter_no_results}</h3>
                        <p className="mt-1 text-sm text-gray-500">{currentTexts.filter_no_results_desc}</p>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {showCalendar && (
               <CalendarView
                 plan={selectedPlan.plan}
                 planId={selectedPlan.id}
                 language={language}
                 onPostDrop={onPostDrop}
                 onViewDetails={handleViewDetails}
               />
              )}
            </div>
           ) : (
             <div className="text-center py-20 bg-white rounded-xl border-2 border-dashed border-gray-300">
               <h3 className="text-3xl font-bold font-sans text-gray-900">
                 {unifiedSidebarItems.length > 0 ? currentTexts.select_plan_title : currentTexts.generate_plan_title}
               </h3>
               <p className="text-lg text-gray-500 mt-2 font-serif max-w-md mx-auto">
                 {unifiedSidebarItems.length > 0 ? currentTexts.select_plan_subtitle : currentTexts.generate_plan_subtitle}
               </p>
               <div className="mt-6 xl:hidden">
                 <Button onClick={() => setIsPlanSidebarOpen(true)}>{currentTexts.select_plan_mobile}</Button>
               </div>
             </div>
           )}
         </main>

         {viewingPost && (
           <PostDetailModal
             isOpen={!!viewingPost}
             onClose={() => setViewingPost(null)}
             postInfo={viewingPost}
             language={language}
             weekTheme={selectedPlan?.plan[viewingPost.weekIndex]?.theme}
             onUpdatePost={(updatedInfo) => {
               onUpdatePost(updatedInfo);
               setViewingPost(updatedInfo);
             }}
             onAcceptSuggestion={(productId) => {
               if(viewingPost) {
                 const updatedPost = {
                   ...viewingPost.post,
                   promotedProductIds: [...(viewingPost.post.promotedProductIds || []), productId],
                 };
                 const updatedInfo = { ...viewingPost, post: updatedPost };
                 setViewingPost(updatedInfo);
                 props.onUpdatePost(updatedInfo);
               }
             }}
             onRunKhongMinhForPost={() => {
               if(viewingPost) props.onRunKhongMinhForPost(viewingPost);
             }}
             affiliateLinks={props.affiliateLinks}
             generatedImages={props.generatedImages}
             generatedVideos={props.generatedVideos}
             onSetVideo={props.onSetVideo}
             isAnyAnalysisRunning={props.isAnyAnalysisRunning}
             isGeneratingImage={props.isGeneratingImage}
             isGeneratingPrompt={props.generatingPromptKeys.has(`${viewingPost.planId}_${viewingPost.weekIndex}_${viewingPost.postIndex}`)}
             isAnalyzing={props.analyzingPostIds.has(viewingPost.post.id)}
             khongMinhSuggestions={props.khongMinhSuggestions}
             onGenerateImage={props.onGenerateImage}
             onGeneratePrompt={async (postInfo) => {
               const updatedPost = await props.onGeneratePrompt(postInfo);
               if (updatedPost) {
                 setViewingPost({ ...postInfo, post: updatedPost });
               }
             }}
             onRefinePost={props.onRefinePost}
             onSetImage={props.onSetImage}
             isGeneratingComment={props.generatingCommentPostIds.has(viewingPost.post.id)}
             onGenerateComment={async (postInfo) => {
               const updatedPost = await props.onGenerateAffiliateComment(postInfo);
               if (updatedPost) {
                 setViewingPost({ ...postInfo, post: updatedPost });
               }
             }}
             onOpenScheduleModal={() => {
               onOpenScheduleModal(viewingPost as SchedulingPost)
             }}
             onPublishPost={async (postInfo) => {
               await props.onPublishPost(postInfo);
             }}
             publishedUrl={viewingPost.post.publishedUrl}
             publishedAt={viewingPost.post.publishedAt}
           />
         )}
       </div>
     );
   };

   export default MediaPlanDisplay;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanWizardModal.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';
import type { Settings, Persona, AffiliateLink } from '../types';
import { Button, TextArea, Switch, Input, Select } from './ui';
import { YouTubeIcon, FacebookIcon, InstagramIcon, TikTokIcon, PinterestIcon, CheckCircleIcon, SparklesIcon, UsersIcon } from './icons';
import ProductSelector from './ProductSelector'; // Import the new component

interface GenerationOptions {
    tone: string;
    style: string;
    length: string;
    includeEmojis: boolean;
}

interface MediaPlanWizardModalProps {
  isOpen: boolean;
  onClose: () => void;
  settings: Settings;
  onGenerate: (prompt: string, useSearch: boolean, totalPosts: number, selectedPlatforms: string[], options: GenerationOptions, selectedProductId: string | null, personaId: string | null) => void; // Updated onGenerate signature
  isGenerating: boolean;
  personas: Persona[];
  generatedImages: Record<string, string>;
  initialPrompt?: string;
  affiliateLinks: AffiliateLink[]; // New prop for affiliate links
  initialProductId?: string; // New prop to pre-select a product
}

const getStrategyTemplates = (language: string) => {
    const T = {
        'Việt Nam': [
            { name: "Ra mắt Thương hiệu", prompt: "Tạo một kế hoạch truyền thông để ra mắt thương hiệu của tôi. Tuần 1 nên tập trung vào việc giới thiệu thương hiệu, sứ mệnh và các giá trị cốt lõi. Tuần 2 nên làm nổi bật các điểm bán hàng độc nhất (USP) và giới thiệu sản phẩm/dịch vụ cốt lõi. Tuần 3 nên xây dựng sự tương tác của cộng đồng thông qua các câu hỏi và nội dung hậu trường. Tuần 4 nên thúc đẩy việc mua hàng hoặc đăng ký đầu tiên với một lời kêu gọi hành động (CTA) mạnh mẽ.", description: "Tạo một lộ trình 4 tuần để giới thiệu thương hiệu của bạn, từ việc giới thiệu đến thúc đẩy việc mua hàng đầu tiên." },
            { name: "Quảng bá Sản phẩm", prompt: "Tạo một kế hoạch truyền thông tập trung vào việc quảng bá một sản phẩm mới. Tuần 1: nhá hàng về sản phẩm và các tính năng của nó. Tuần 2: chính thức ra mắt sản phẩm với các bài đăng chi tiết. Tuần 3: chia sẻ lời chứng thực của người dùng và các trường hợp sử dụng. Tuần 4: đưa ra một ưu đãi trong thời gian có hạn để thúc đẩy doanh số.", description: "Một kế hoạch tập trung vào việc tạo sự chú ý và thúc đẩy doanh số cho một sản phẩm mới cụ thể." },
            { name: "Tăng tương tác", prompt: "Tạo một kế hoạch truyền thông được thiết kế để tăng cường sự tương tác của cộng đồng. Bao gồm các cuộc thăm dò ý kiến, các cuộc thi, các buổi hỏi đáp, và nội dung do người dùng tạo ra. Mục tiêu là để có được nhiều bình luận, lượt chia sẻ và sự tham gia của người theo dõi.", description: "Thúc đẩy sự tham gia của cộng đồng với các cuộc thi, thăm dò ý kiến và nội dung do người dùng tạo." },
        ],
        'English': [
            { name: "Brand Launch", prompt: "Create a media plan to launch my brand. Week 1 should focus on introducing the brand, its mission, and core values. Week 2 should highlight the unique selling proposition (USP) and introduce the core products/services. Week 3 should build community engagement with questions and behind-the-scenes content. Week 4 should drive first-time purchases or sign-ups with a strong call-to-action.", description: "Create a 4-week roadmap to introduce your brand, from introduction to driving first sales." },
            { name: "Product Promotion", prompt: "Create a media plan focused on promoting a new product. Week 1: Tease the product and its features. Week 2: Announce the official product launch with detailed posts. Week 3: Share user testimonials and use-cases. Week 4: Push a limited-time offer to drive sales.", description: "A focused plan to build hype and drive sales for a specific new product." },
            { name: "Engagement Boost", prompt: "Create a media plan designed to boost community engagement. Include polls, contests, Q&A sessions, and user-generated content features. The goal is to get more comments, shares, and follower participation.", description: "Ignite community participation with contests, polls, and user-generated content." },
        ]
    };
    return (T as any)[language] || T['English'];
};

export const MediaPlanWizardModal: React.FC<MediaPlanWizardModalProps> = ({ isOpen, onClose, settings, onGenerate, isGenerating, personas, generatedImages, initialPrompt, affiliateLinks, initialProductId }) => {
    const [step, setStep] = useState(1);
    const [prompt, setPrompt] = useState(initialPrompt || '');
    const [useSearch, setUseSearch] = useState(false);
    const [totalPosts, setTotalPosts] = useState(settings.totalPostsPerMonth);
    const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>(['YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest']);
    
    // New state for advanced options
    const [tone, setTone] = useState('Friendly & Casual');
    const [writingStyle, setWritingStyle] = useState('Storytelling');
    const [postLength, setPostLength] = useState('Medium (e.g. for Facebook)');
    const [includeEmojis, setIncludeEmojis] = useState(true);
    const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);

    // New state for selected product ID
    const [selectedProductId, setSelectedProductId] = useState<string | null>(initialProductId || null);

    const { language } = settings;
    const isGeminiModel = settings.textGenerationModel.startsWith('gemini-');
    const strategyTemplates = getStrategyTemplates(language);
    const totalSteps = 5;

    useEffect(() => {
        if (isOpen) {
            setStep(initialPrompt ? 2 : 1);
            setPrompt(initialPrompt || '');
            setUseSearch(false);
            setTotalPosts(settings.totalPostsPerMonth);
            setSelectedPlatforms(['YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest']);
            setTone('Friendly & Casual');
            setWritingStyle('Storytelling');
            setPostLength('Medium (e.g. for Facebook)');
            setIncludeEmojis(true);
            setSelectedPersonaId(null);
            // Initialize selectedProductId with initialProductId if provided, otherwise null
            setSelectedProductId(initialProductId || null);
        }
    }, [isOpen, initialPrompt, settings.totalPostsPerMonth, initialProductId]);

    const platforms = [
        { id: 'YouTube', Icon: YouTubeIcon },
        { id: 'Facebook', Icon: FacebookIcon },
        { id: 'Instagram', Icon: InstagramIcon },
        { id: 'TikTok', Icon: TikTokIcon },
        { id: 'Pinterest', Icon: PinterestIcon },
    ];
    
    const handlePlatformToggle = (platformId: string) => {
        setSelectedPlatforms(prev => 
            prev.includes(platformId) 
                ? prev.filter(p => p !== platformId) 
                : [...prev, platformId]
        );
    };

    const T = {
        'Việt Nam': {
            title: "Tạo Kế hoạch Truyền thông Mới",
            step: "Bước",
            of: "trên",
            // Step 1
            step1Title: "Xác định Mục tiêu của bạn",
            step1Subtitle: "Bắt đầu với một mẫu chiến lược đã được chứng minh hoặc viết mục tiêu của riêng bạn.",
            startWithStrategy: "Chọn một mẫu chiến lược",
            orWriteYourOwn: "Hoặc viết/tùy chỉnh mục tiêu của bạn",
            placeholder: "Vd: Tập trung vào việc ra mắt sản phẩm mới của chúng tôi, nhấn mạnh các tính năng thân thiện với môi trường. Bao gồm một cuộc thi vào tuần thứ 3.",
            // Step 2
            step2Title: "Chọn Nền tảng của bạn",
            step2Subtitle: "Chọn nơi bạn muốn nội dung này được đăng. Bạn có thể chọn nhiều nền tảng.",
            // Step 3
            step3Title: "Chọn một KOL/KOC (Tùy chọn)",
            step3Subtitle: "Chọn một nhân vật để làm gương mặt đại diện cho chiến dịch này. Nội dung sẽ được tạo từ góc nhìn của họ.",
            noPersona: "Không có KOL/KOC",
            noPersonasAvailable: "Chưa có KOL/KOC nào được định nghĩa. Bạn có thể thêm họ trong tab 'KOL/KOC'.",
            // Step 4 - Updated
            step4Title: "Chọn Sản phẩm để Quảng bá (Tùy chọn)",
            step4Subtitle: "Chọn một sản phẩm từ Kho Affiliate của bạn để tự động liên kết với các bài đăng trong kế hoạch truyền thông này, hoặc bỏ qua bước này.",
            // Step 5
            step5Title: "Tinh chỉnh & Tạo",
            step5Subtitle: "Điều chỉnh các cài đặt cuối cùng trước khi AI của chúng tôi bắt đầu làm việc.",
            useSearchMode: "Sử dụng Chế độ Tìm kiếm (thực tế)",
            useSearchModeDesc: "Sử dụng Google Tìm kiếm để có nội dung thực tế, cập nhật.",
            geminiOnly: "Chỉ dành cho Gemini",
            totalPosts: "Tổng số bài đăng",
            toneOfVoice: "Giọng điệu",
            writingStyle: "Phong cách viết",
            postLength: "Độ dài bài đăng",
            includeEmojis: "Bao gồm Emojis",
            includeEmojisDesc: "Tự động thêm emojis vào bài đăng.",
            // Buttons
            back: "Quay lại",
            next: "Tiếp theo",
            skip: "Bỏ qua",
            generate: "Tạo Kế hoạch",
            generating: "Đang tạo...",
        },
        'English': {
            title: "Create a New Media Plan",
            step: "Step",
            of: "of",
            // Step 1
            step1Title: "Define Your Goal",
            step1Subtitle: "Start with a proven strategy template or write your own objective.",
            startWithStrategy: "Choose a strategy template",
            orWriteYourOwn: "Or write/customize your own goal",
            placeholder: "e.g., Focus on launching our new product, highlighting eco-friendly features. Include a contest in week 3.",
            // Step 2
            step2Title: "Choose Your Platforms",
            step2Subtitle: "Select where you want this content to live. You can pick multiple platforms.",
            // Step 3
            step3Title: "Select a KOL/KOC (Optional)",
            step3Subtitle: "Choose a persona to be the face of this campaign. Content will be generated from their perspective.",
            noPersona: "No KOL/KOC",
            noPersonasAvailable: "No KOLs/KOCs have been defined yet. You can add them in the 'KOL/KOC' tab.",
            // Step 4 - Updated
            step4Title: "Select Product to Promote (Optional)",
            step4Subtitle: "Choose a product from your Affiliate Vault to automatically link to posts in this media plan, or skip this step.",
            // Step 5
            step5Title: "Refine & Generate",
            step5Subtitle: "Adjust the final settings before our AI gets to work.",
            useSearchMode: "Use Search Mode (Factual)",
            useSearchModeDesc: "Uses Google Search for factual, up-to-date content.",
            geminiOnly: "Gemini only",
            totalPosts: "Total Posts for Plan",
            toneOfVoice: "Tone of Voice",
            writingStyle: "Writing Style",
            postLength: "Post Length",
            includeEmojis: "Include Emojis",
            includeEmojisDesc: "Automatically add emojis to posts.",
            // Buttons
            back: "Back",
            next: "Next",
            skip: "Skip for now",
            generate: "Generate Plan",
            generating: "Generating...",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const handleGenerate = async () => {
      // Use selectedProductId if available, otherwise fall back to initialProductId
      const productIdToUse = selectedProductId || initialProductId || null;
      onGenerate(prompt, useSearch, totalPosts, selectedPlatforms, { tone, style: writingStyle, length: postLength, includeEmojis }, productIdToUse, selectedPersonaId);
      onClose();
    };

    const isNextDisabled = () => {
        if (step === 1 && !prompt.trim()) return true;
        if (step === 2 && selectedPlatforms.length === 0) return true;
        return false;
    }

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onMouseDown={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl border border-gray-200 m-4 max-h-[90vh] flex flex-col" onMouseDown={(e) => e.stopPropagation()}>
                <header className="p-6 border-b border-gray-200">
                    <div className="flex justify-between items-center">
                        <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                            <SparklesIcon className="h-7 w-7 text-brand-green" />
                            {texts.title}
                        </h2>
                        <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-1.5 mt-4">
                        <div className="bg-brand-green h-1.5 rounded-full" style={{ width: `${(step / totalSteps) * 100}%` }}></div>
                    </div>
                </header>
                
                <main className="p-8 flex-grow overflow-y-auto">
                    {step === 1 && (
                        <div>
                            <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step1Title}</h3>
                            <p className="text-gray-500 font-serif text-center mt-1">{texts.step1Subtitle}</p>
                            <div className="mt-8 space-y-6">
                                <div>
                                    <label className="text-sm font-medium text-gray-700">{texts.startWithStrategy}</label>
                                    <div className="mt-2 grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {strategyTemplates.map((template: any) => (
                                            <button 
                                                key={template.name} 
                                                onClick={() => setPrompt(template.prompt)}
                                                className={`p-4 rounded-lg border-2 text-left transition-colors ${prompt === template.prompt ? 'bg-green-50 border-brand-green' : 'bg-white hover:bg-gray-100 border-gray-200'}`}
                                            >
                                                <h4 className="font-bold font-sans text-gray-900">{template.name}</h4>
                                                <p className="text-sm text-gray-500 mt-1 font-serif">{template.description}</p>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                 <div>
                                     <label htmlFor="prompt" className="text-sm font-medium text-gray-700">{texts.orWriteYourOwn}</label>
                                    <TextArea
                                        id="prompt"
                                        value={prompt}
                                        onChange={(e) => setPrompt(e.target.value)}
                                        rows={4}
                                        placeholder={texts.placeholder}
                                        className="mt-1"
                                    />
                                </div>
                            </div>
                        </div>
                    )}
                    {step === 2 && (
                         <div>
                            <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step2Title}</h3>
                            <p className="text-gray-500 font-serif text-center mt-1">{texts.step2Subtitle}</p>
                            <div className="mt-8 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                                {platforms.map(({ id, Icon }) => (
                                    <button 
                                        key={id}
                                        onClick={() => handlePlatformToggle(id)}
                                        className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${selectedPlatforms.includes(id) ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' : 'bg-white hover:bg-gray-100 border-gray-200'}`}
                                    >
                                        <Icon className="h-10 w-10 mb-2"/>
                                        <span className="font-semibold text-gray-800">{id}</span>
                                        <div className={`mt-2 h-5 w-5 rounded-full border-2 flex items-center justify-center ${selectedPlatforms.includes(id) ? 'bg-brand-green border-brand-green-dark' : 'bg-white border-gray-300'}`}>
                                            {selectedPlatforms.includes(id) && <CheckCircleIcon className="h-5 w-5 text-white" />}
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                    {step === 3 && (
                        <div>
                             <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step3Title}</h3>
                            <p className="text-gray-500 font-serif text-center mt-1">{texts.step3Subtitle}</p>
                            <div className="mt-8 grid grid-cols-2 md:grid-cols-4 gap-4">
                                <button onClick={() => setSelectedPersonaId(null)} className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${selectedPersonaId === null ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' : 'bg-white hover:bg-gray-100 border-gray-200'}`}>
                                    <div className="w-20 h-20 rounded-full bg-gray-200 flex items-center justify-center mb-2"><UsersIcon className="h-10 w-10 text-gray-500"/></div>
                                    <span className="font-semibold text-gray-800">{texts.noPersona}</span>
                                </button>
                                {personas.map(p => {
                                    const imageUrl = p.avatarImageKey ? generatedImages[p.avatarImageKey] : undefined;
                                    return (
                                        <button key={p.id} onClick={() => setSelectedPersonaId(p.id)} className={`flex flex-col items-center justify-center p-4 rounded-xl border-2 transition-all duration-200 ${selectedPersonaId === p.id ? 'bg-green-50 border-brand-green shadow-sm -translate-y-1' : 'bg-white hover:bg-gray-100 border-gray-200'}`}>
                                            <div className="w-20 h-20 rounded-full bg-gray-200 mb-2 overflow-hidden">
                                                {imageUrl ? <img src={imageUrl} alt={p.nickName} className="w-full h-full object-cover" /> : <UsersIcon className="h-10 w-10 text-gray-500 m-auto"/>}
                                            </div>
                                            <span className="font-semibold text-gray-800">{p.nickName}</span>
                                        </button>
                                    )
                                })}
                            </div>
                             {personas.length === 0 && <p className="text-center mt-8 text-gray-500">{texts.noPersonasAvailable}</p>}
                        </div>
                    )}
                    {step === 4 && (
                        <div>
                            <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step4Title}</h3>
                            <p className="text-gray-500 font-serif text-center mt-1">{texts.step4Subtitle}</p>
                           
                            <ProductSelector
                                affiliateLinks={affiliateLinks}
                                onSelectProduct={setSelectedProductId}
                                selectedProductId={selectedProductId || initialProductId || undefined}
                                language={language}
                                autoSelectedProductId={initialProductId || undefined}
                            />
                        </div>
                    )}
                    {step === 5 && (
                        <div>
                            <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.step5Title}</h3>
                            <p className="text-gray-500 font-serif text-center mt-1">{texts.step5Subtitle}</p>
                             <div className="mt-8 space-y-6">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="p-4 bg-gray-50 rounded-lg border">
                                        <Switch
                                            id="use-search"
                                            label={texts.useSearchMode}
                                            checked={useSearch}
                                            onChange={setUseSearch}
                                            disabled={!isGeminiModel}
                                        />
                                        <p className="text-sm text-gray-500 mt-1">{texts.useSearchModeDesc} <span className="font-bold text-gray-600">{texts.geminiOnly}</span></p>
                                    </div>
                                    <div className="p-4 bg-gray-50 rounded-lg border">
                                         <label htmlFor="totalPosts" className="font-medium text-gray-700">{texts.totalPosts}</label>
                                         <Input id="totalPosts" type="number" min="4" max="40" value={totalPosts} onChange={(e) => setTotalPosts(parseInt(e.target.value))} className="mt-1" />
                                    </div>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                     <div>
                                        <label htmlFor="tone" className="font-medium text-gray-700">{texts.toneOfVoice}</label>
                                        <Select id="tone" value={tone} onChange={e => setTone(e.target.value)} className="mt-1">
                                            <option>Friendly & Casual</option>
                                            <option>Professional & Authoritative</option>
                                            <option>Witty & Humorous</option>
                                            <option>Inspirational & Uplifting</option>
                                            <option>Minimal & Direct</option>
                                        </Select>
                                     </div>
                                     <div>
                                        <label htmlFor="style" className="font-medium text-gray-700">{texts.writingStyle}</label>
                                        <Select id="style" value={writingStyle} onChange={e => setWritingStyle(e.target.value)} className="mt-1">
                                            <option>Storytelling</option>
                                            <option>Educational / How-to</option>
                                            <option>Question-based</option>
                                            <option>Data-driven & Factual</option>
                                            <option>Conversational</option>
                                        </Select>
                                     </div>
                                     <div>
                                        <label htmlFor="length" className="font-medium text-gray-700">{texts.postLength}</label>
                                        <Select id="length" value={postLength} onChange={e => setPostLength(e.target.value)} className="mt-1">
                                            <option>Short (e.g. for Instagram)</option>
                                            <option>Medium (e.g. for Facebook)</option>
                                            <option>Long (e.g. for a script)</option>
                                        </Select>
                                     </div>
                                </div>
                                 <div className="p-4 bg-gray-50 rounded-lg border">
                                    <Switch
                                        id="include-emojis"
                                        label={texts.includeEmojis}
                                        checked={includeEmojis}
                                        onChange={setIncludeEmojis}
                                    />
                                    <p className="text-sm text-gray-500 mt-1">{texts.includeEmojisDesc}</p>
                                </div>
                            </div>
                        </div>
                    )}
                </main>

                <footer className="flex justify-between items-center p-6 border-t border-gray-200 bg-gray-50 rounded-b-xl">
                    <Button variant="tertiary" onClick={() => setStep(prev => prev - 1)} disabled={step === 1 || isGenerating}>{texts.back}</Button>
                    <div>
                        {step < totalSteps ? (
                            <>
                                {(step === 3 || step === 4) && <Button variant="secondary" onClick={() => setStep(prev => prev + 1)} disabled={isGenerating} className="mr-2">{texts.skip}</Button>}
                                <Button onClick={() => setStep(prev => prev + 1)} disabled={isNextDisabled() || isGenerating}>{texts.next}</Button>
                            </>
                        ) : (
                            <Button onClick={handleGenerate} disabled={isGenerating} className="w-40 flex justify-center">
                                {isGenerating ? (
                                    <>
                                        <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                                        <span className="ml-2">{texts.generating}</span>
                                    </>
                                ) : (
                                    <>{texts.generate}</>
                                )}
                            </Button>
                        )}
                    </div>
                </footer>
            </div>
        </div>
    );
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\MediaPlanWizardModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonaConnectModal.tsx ---\nimport React, { useState } from 'react';
import { Button } from './ui';
import { LinkIcon } from './icons';
import { Persona } from '../types';
import { connectSocialAccountToPersona } from '../services/socialAccountService'; // Assuming this is the correct import

interface PersonaConnectModalProps {
  isOpen: boolean;
  onClose: () => void;
  language: string;
  personaToConnect: Persona | null;
  platformToConnect: string | null;
  onSocialAccountConnected: (persona: Persona) => void; // Callback to update persona in App.tsx
}

const PersonaConnectModal: React.FC<PersonaConnectModalProps> = ({ isOpen, onClose, language, personaToConnect, platformToConnect, onSocialAccountConnected }) => {
  const [isConnectingSocialAccount, setIsConnectingSocialAccount] = useState(false);

  if (!isOpen || !personaToConnect || !platformToConnect) return null;

  const T = {
    'Việt Nam': {
      connect_social_account_title: 'Kết nối tài khoản xã hội',
      connect_social_account_subtitle: (personaName: string, platformName: string) => `Vui lòng kết nối tài khoản ${platformName} cho KOL/KOC ${personaName} để tiếp tục.`,
      connect_button: 'Kết nối',
      connecting: 'Đang kết nối...',
      failed_to_connect: (platformName: string) => `Không thể kết nối tài khoản ${platformName}. Vui lòng thử lại.`,
      close: 'Đóng',
    },
    'English': {
      connect_social_account_title: 'Connect Social Account',
      connect_social_account_subtitle: (personaName: string, platformName: string) => `Please connect the ${platformName} account for persona ${personaName} to proceed.`,
      connect_button: 'Connect',
      connecting: 'Connecting...',
      failed_to_connect: (platformName: string) => `Failed to connect ${platformName} account. Please try again.`,
      close: 'Close',
    }
  };
  const texts = (T as any)[language] || T['English'];

  const handleConnectSocialAccount = async () => {
    if (!personaToConnect || !platformToConnect) return;

    setIsConnectingSocialAccount(true);
    try {
      const updatedPersona = await connectSocialAccountToPersona(personaToConnect, platformToConnect as any);
      onSocialAccountConnected(updatedPersona as Persona);
      onClose(); // Close the modal on successful connection
    } catch (error) {
      console.error("Failed to connect social account:", error);
      alert(texts.failed_to_connect(platformToConnect));
    } finally {
      setIsConnectingSocialAccount(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-8 border border-gray-200 m-4 transform transition-all max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-start">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
              {texts.connect_social_account_title}
            </h2>
            <p className="text-gray-500 mt-1 font-serif">
              {texts.connect_social_account_subtitle(personaToConnect.nickName, platformToConnect)}
            </p>
          </div>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
        </div>
        
        <div className="mt-6 flex-grow flex flex-col items-center justify-center text-center">
          <p className="text-lg text-gray-700 mb-4">
            {texts.connect_social_account_subtitle(personaToConnect.nickName, platformToConnect)}
          </p>
          <Button
            onClick={handleConnectSocialAccount}
            disabled={isConnectingSocialAccount}
            className="mt-4 px-6 py-3 text-lg flex items-center gap-2"
          >
            {isConnectingSocialAccount ? (
              <>
                <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                <span>{texts.connecting}</span>
              </>
            ) : (
              <>
                <LinkIcon className="h-5 w-5" />
                <span>{texts.connect_button}</span>
              </>
            )}
          </Button>
        </div>

        <div className="flex justify-end gap-4 pt-6 mt-auto border-t border-gray-200">
            <Button type="button" onClick={onClose} variant="tertiary">
                {texts.close}
            </Button>
        </div>
      </div>
    </div>
  );
};

export default PersonaConnectModal;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonaConnectModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonasDisplay.tsx ---\nimport React, { useState, useRef, useEffect, memo, useId } from 'react';
import type { Persona, PersonaPhoto, SocialAccount } from '../types';
import { Button, Input, TextArea } from './ui';
import { PlusIcon, UsersIcon, SearchIcon, TrashIcon, UploadIcon, DotsVerticalIcon, PencilIcon, FacebookIcon, InstagramIcon, TikTokIcon, YouTubeIcon, PinterestIcon } from './icons';
import { connectSocialAccountToPersona, disconnectSocialAccountFromPersona, handleConnectFacebookPage } from '../services/socialAccountService';
import FacebookPageSelectionModal from './FacebookPageSelectionModal';

interface PersonaCardProps {
    persona: Persona;
    isNew?: boolean;
    onSave: (persona: Persona) => void;
    onDelete: () => void;
    onCancel: () => void;
    onSetImage: (photoId: string, dataUrl: string) => Promise<string | undefined>;
    generatedImages: Record<string, string>;
    isUploadingImage: (photoKey: string) => boolean;
    language: string;
    onUpdatePersona: (persona: Persona) => void; // New prop for updating persona after social account changes
}

const MenuDropDown: React.FC<{onEdit: () => void, onDelete: () => void, texts: any}> = ({ onEdit, onDelete, texts }) => {
    const [isOpen, setIsOpen] = useState(false);
    const menuRef = useRef<HTMLDivElement>(null);
     useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);
    return (
        <div ref={menuRef}>
            <button onClick={() => setIsOpen(!isOpen)} className="text-gray-400 hover:text-gray-700 p-1 rounded-full"><DotsVerticalIcon className="h-5 w-5" /></button>
            {isOpen && (
                 <div className="absolute right-0 mt-2 w-40 bg-white rounded-md shadow-lg border z-10">
                    <button onClick={onEdit} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"><PencilIcon className="h-4 w-4"/> {texts.edit}</button>
                    <button onClick={onDelete} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-red-600 hover:bg-red-50"><TrashIcon className="h-4 w-4"/> {texts.delete}</button>
                </div>
            )}
        </div>
    )
};

const InputField: React.FC<React.InputHTMLAttributes<HTMLInputElement> & {label: string}> = ({label, ...props}) => {
    const inputId = useId(); // Generate a unique ID
    return (
        <div className="mb-2">
            <label htmlFor={inputId} className="text-xs font-medium text-gray-500">{label}</label>
            <Input id={inputId} {...props} className="mt-1 p-1 text-sm"/>
        </div>
    );
};
const TextAreaField: React.FC<React.TextareaHTMLAttributes<HTMLTextAreaElement> & {label: string}> = ({label, ...props}) => {
    const textareaId = useId(); // Generate a unique ID
    return (
        <div className="mb-2">
            <label htmlFor={textareaId} className="text-xs font-medium text-gray-500">{label}</label>
            <TextArea id={textareaId} {...props} className="mt-1 p-1 text-sm"/>
        </div>
    );
};


// PersonaCard component is now defined inside PersonasDisplay
const PersonaCard: React.FC<PersonaCardProps> = memo(({ persona, isNew = false, onSave, onDelete, onCancel, onSetImage, generatedImages, isUploadingImage, language, onUpdatePersona }) => {
    const [isEditing, setIsEditing] = useState(isNew);
    const [editedPersona, setEditedPersona] = useState(persona);
    const [connectingPlatform, setConnectingPlatform] = useState<string | null>(null);
    const fileInputRefs = useRef<(HTMLInputElement | null)[]>([]);

    // State for Facebook Page Selection
    const [isFacebookPageSelectionModalOpen, setIsFacebookPageSelectionModalOpen] = useState(false);
    const [facebookPages, setFacebookPages] = useState<FacebookPage[]>([]);
    const [facebookUserAccessToken, setFacebookUserAccessToken] = useState<string | null>(null);

    useEffect(() => {
        setEditedPersona(persona);
    }, [persona]);

    const T = {
        'Việt Nam': {
            nickName: "Biệt danh",
            mainStyle: "Phong cách chính",
            activityField: "Lĩnh vực hoạt động",
            outfitDescription: "Mô tả trang phục/phong cách",
            photos: "Ảnh đại diện",
            uploadHint: "Tải lên / Dán",
            save: "Lưu",
            cancel: "Hủy",
            edit: "Chỉnh sửa",
            delete: "Xóa",
            socialAccounts: "Tài khoản Mạng xã hội",
            connect: "Kết nối",
            disconnect: "Ngắt kết nối",
            connecting: "Đang kết nối...",
            facebook: "Facebook",
            instagram: "Instagram",
            tiktok: "TikTok",
            youtube: "YouTube",
            pinterest: "Pinterest",
        },
        'English': {
            nickName: "Nickname",
            mainStyle: "Main Style",
            activityField: "Field of Activity",
            outfitDescription: "Outfit/Style Description",
            photos: "Reference Photos",
            uploadHint: "Upload / Paste",
            save: "Save",
            cancel: "Cancel",
            edit: "Edit",
            delete: "Delete",
            socialAccounts: "Social Accounts",
            connect: "Connect",
            disconnect: "Disconnect",
            connecting: "Connecting...",
            facebook: "Facebook",
            instagram: "Instagram",
            tiktok: "TikTok",
            youtube: "YouTube",
            pinterest: "Pinterest",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setEditedPersona(prev => ({ ...prev, [name]: value }));
    };

    const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>, photoId: string) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (event) => {
            const result = event.target?.result;
            if (result && typeof result === 'string') {
                const newImageKey = await onSetImage(photoId, result);
                if (newImageKey) {
                    setEditedPersona(prev => {
                        const newPhotos = prev.photos.map(p => p.id === photoId ? { ...p, imageKey: newImageKey } : p);
                        return { ...prev, photos: newPhotos };
                    });
                }
            }
        };
        reader.readAsDataURL(file);
    };

    const handlePaste = async (e: React.ClipboardEvent<HTMLButtonElement>, photoId: string) => {
        e.preventDefault();
        e.stopPropagation();
        const file = e.clipboardData.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = async (event) => {
                const result = event.target?.result;
                if (result && typeof result === 'string') {
                    const newImageKey = await onSetImage(photoId, result);
                    if (newImageKey) {
                        setEditedPersona(prev => {
                            const newPhotos = prev.photos.map(p => p.id === photoId ? { ...p, imageKey: newImageKey } : p);
                            return { ...prev, photos: newPhotos };
                        });
                    }
                }
            };
            reader.readAsDataURL(file);
        }
    };

    const handleSave = () => {
        const personaToSave = { ...editedPersona };
        // Synthesize the single avatar from the first available photo for backward compatibility
        const firstPhotoWithImage = personaToSave.photos.find(p => generatedImages[p.imageKey]);
        if (firstPhotoWithImage) {
            personaToSave.avatarImageKey = firstPhotoWithImage.imageKey;
            personaToSave.avatarImageUrl = generatedImages[firstPhotoWithImage.imageKey];
        } else {
            personaToSave.avatarImageKey = undefined;
            personaToSave.avatarImageUrl = undefined;
        }

        onSave(personaToSave);
        setIsEditing(false);
    };

    const handleCancel = () => {
        if (isNew) onCancel();
        else {
            setIsEditing(false);
            setEditedPersona(persona);
        }
    };

    const renderPhotoUploader = (photo: PersonaPhoto, index: number) => {
        const imageUrl = generatedImages[photo.imageKey];
        const isUploading = isUploadingImage(photo.imageKey);

        return (
            <div key={photo.id} className="aspect-square relative">
                <input
                    type="file"
                    className="hidden"
                    ref={el => { fileInputRefs.current[index] = el; }}
                    onChange={(e) => handleFileChange(e, photo.id)}
                    accept="image/*"
                />
                <button
                    onPaste={(e) => handlePaste(e, photo.id)}
                    onClick={() => fileInputRefs.current[index]?.click()}
                    disabled={!isEditing || isUploading}
                    className={`w-full h-full rounded-md flex items-center justify-center border-2 border-dashed transition-colors ${imageUrl ? 'border-transparent' : 'border-gray-300 hover:border-brand-green'}`}
                    style={{ backgroundImage: `url(${imageUrl})`, backgroundSize: 'cover', backgroundPosition: 'center' }}
                    aria-label={`${texts.uploadHint} for photo ${index + 1}`}
                >
                    {!imageUrl && !isUploading && (
                        <div className="text-center text-gray-500">
                            <UploadIcon className="h-6 w-6 mx-auto"/>
                            <span className="text-xs mt-1 block">{texts.uploadHint}</span>
                        </div>
                    )}
                </button>
                 {isUploading && (
                    <div className="absolute inset-0 bg-white/70 flex items-center justify-center rounded-md">
                        <div className="w-6 h-6 border-2 border-t-transparent border-brand-green rounded-full animate-spin"></div>
                    </div>
                )}
            </div>
        );
    };

    const renderReadOnlyPhoto = (photo: PersonaPhoto) => {
        const imageUrl = generatedImages[photo.imageKey];
        if (!imageUrl) return null;
        return <div key={photo.id} className="aspect-square bg-gray-100 rounded-md" style={{ backgroundImage: `url(${imageUrl})`, backgroundSize: 'cover', backgroundPosition: 'center' }} />;
    };

    const handleConnectAccount = async (platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest') => {
        setConnectingPlatform(platform);
        try {
            const result = await connectSocialAccountToPersona(editedPersona, platform);
            console.log("Result from connectSocialAccountToPersona:", result);
            if ('pages' in result) {
                console.log("Multiple Facebook pages found. Opening selection modal.", result.pages);
                setFacebookPages(result.pages);
                setFacebookUserAccessToken(result.userAccessToken);
                setIsFacebookPageSelectionModalOpen(true);
            } else {
                console.log("Single Facebook page or other platform connected directly.", result);
                setEditedPersona(result);
                onUpdatePersona(result); // Propagate the change up
            }
        } catch (error) {
            console.error(`Failed to connect ${platform} account:`, error);
            console.log("Error object from connectSocialAccountToPersona:", error);
            // If connection fails, and it's Facebook, and no pages were returned, open the modal with an empty page list
            if (platform === 'Facebook' && error instanceof Error && error.message.includes("No Facebook Pages found")) {
                setFacebookPages([]);
                setFacebookUserAccessToken(null); // Clear any partial token
                setIsFacebookPageSelectionModalOpen(true);
            } else {
                // For other errors or non-Facebook platforms, show a generic alert
                alert(`Failed to connect ${platform} account. Please try again. Error: ${error instanceof Error ? error.message : String(error)}`);
            }
        } finally {
            setConnectingPlatform(null);
        }
    };

    const handleDisconnectAccount = async (platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest') => {
        if (!window.confirm(`Are you sure you want to disconnect the ${platform} account from ${editedPersona.nickName}?`)) {
            return;
        }
        setConnectingPlatform(platform); // Use connectingPlatform for disconnection too for simplicity
        try {
            const updated = disconnectSocialAccountFromPersona(editedPersona.id, platform);
            setEditedPersona(prev => ({
                ...prev,
                socialAccounts: prev.socialAccounts?.filter(acc => acc.platform !== platform)
            }));
            onUpdatePersona({
                ...editedPersona,
                socialAccounts: editedPersona.socialAccounts?.filter(acc => acc.platform !== platform)
            });
        } catch (error) {
            console.error(`Failed to disconnect ${platform} account:`, error);
            alert(`Failed to disconnect ${platform} account. Please try again. Error: ${error instanceof Error ? error.message : String(error)}`);
        } finally {
            setConnectingPlatform(null);
        }
    };

    const getPlatformIcon = (platform: string) => {
        switch (platform) {
            case 'Facebook': return <FacebookIcon className="h-5 w-5" />;
            case 'Instagram': return <InstagramIcon className="h-5 w-5" />;
            case 'TikTok': return <TikTokIcon className="h-5 w-5" />;
            case 'YouTube': return <YouTubeIcon className="h-5 w-5" />;
            case 'Pinterest': return <PinterestIcon className="h-5 w-5" />;
            default: return null;
        }
    };

    const getPlatformColor = (platform: string) => {
        switch (platform) {
            case 'Facebook': return 'bg-blue-600 hover:bg-blue-700';
            case 'Instagram': return 'bg-pink-600 hover:bg-pink-700';
            case 'TikTok': return 'bg-black hover:bg-gray-800';
            case 'YouTube': return 'bg-red-600 hover:bg-red-700';
            case 'Pinterest': return 'bg-red-700 hover:bg-red-800';
            default: return 'bg-gray-500 hover:bg-gray-600';
        }
    };

    const socialPlatforms: ('Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest')[] = ['Facebook', 'Instagram', 'TikTok', 'YouTube', 'Pinterest'];

    const handleFacebookPageSelected = (page: FacebookPage) => {
        const updatedPersona = handleConnectFacebookPage(
            editedPersona.id,
            page.id,
            page.access_token
        );
        setEditedPersona(updatedPersona);
        onUpdatePersona(updatedPersona);
        setIsFacebookPageSelectionModalOpen(false);
        setFacebookPages([]);
        setFacebookUserAccessToken(null);
    };

    const handleRetryFacebookConnect = () => {
        setIsFacebookPageSelectionModalOpen(false);
        // Re-initiate the Facebook connection flow
        handleConnectAccount('Facebook');
    };

    return (
        <div className="bg-white rounded-xl border border-gray-200 p-5 flex flex-col transition-all duration-200 shadow-sm">
            {isEditing ? (
                <>
                    <InputField label={texts.nickName} name="nickName" value={editedPersona.nickName} onChange={handleChange} required />
                    <InputField label={texts.mainStyle} name="mainStyle" value={editedPersona.mainStyle} onChange={handleChange} />
                    <InputField label={texts.activityField} name="activityField" value={editedPersona.activityField} onChange={handleChange} />
                    <TextAreaField label={texts.outfitDescription} name="outfitDescription" value={editedPersona.outfitDescription} onChange={handleChange} rows={3} />
                    
                    <label className="text-xs font-medium text-gray-500 mt-4 block">{texts.photos}</label>
                    <div className="grid grid-cols-5 gap-2 mt-1">
                        {editedPersona.photos.map(renderPhotoUploader)}
                    </div>

                    <div className="mt-4 pt-4 border-t border-gray-100 flex items-center justify-end gap-3">
                        <Button variant="tertiary" onClick={handleCancel}>{texts.cancel}</Button>
                        <Button onClick={handleSave}>{texts.save}</Button>
                    </div>
                </>
            ) : (
                <>
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                            {persona.avatarImageUrl || (persona.photos.length > 0 && generatedImages[persona.photos[0].imageKey]) ? (
                                <img
                                    src={persona.avatarImageUrl || generatedImages[persona.photos[0].imageKey]}
                                    alt={persona.nickName}
                                    className="h-16 w-16 rounded-full object-cover border border-gray-200"
                                />
                            ) : (
                                <div className="h-16 w-16 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-2xl font-semibold">
                                    <UsersIcon className="h-8 w-8" />
                                </div>
                            )}
                            <div>
                                <h3 className="text-lg font-bold text-gray-900 leading-tight">{persona.nickName}</h3>
                                <p className="text-sm text-gray-600">
                                    <span className="font-semibold">{texts.mainStyle}:</span> {persona.mainStyle}
                                </p>
                                <p className="text-sm text-gray-600">
                                    <span className="font-semibold">{texts.activityField}:</span> {persona.activityField}
                                </p>
                            </div>
                        </div>
                        <div className="relative">
                             <MenuDropDown
                                onEdit={() => setIsEditing(true)}
                                onDelete={onDelete}
                                texts={texts}
                            />
                        </div>
                    </div>
                    <div className="mt-4 pt-4 border-t border-gray-100">
                        <h4 className="text-md font-semibold text-gray-800 mb-2">{texts.socialAccounts}</h4>
                        <div className="grid grid-cols-1 gap-2">
                            {socialPlatforms.map(platform => {
                                const account = editedPersona.socialAccounts?.find(acc => acc.platform === platform);
                                const isLoading = connectingPlatform === platform;
                                return (
                                    <div key={platform} className="flex items-center justify-between p-2 border border-gray-200 rounded-md bg-gray-50/50">
                                        <div className="flex items-center gap-3">
                                            {getPlatformIcon(platform)}
                                            {account ? (
                                                <a href={account.profileUrl || '#'} target="_blank" rel="noopener noreferrer" className="text-sm font-semibold text-blue-600 hover:underline">
                                                    {account.displayName || `${platform} Connected`}
                                                </a>
                                            ) : (
                                                <span className="text-sm font-medium text-gray-700">{texts[platform.toLowerCase() as keyof typeof texts]}</span>
                                            )}
                                        </div>
                                        {account ? (
                                            <Button
                                                onClick={() => handleDisconnectAccount(platform)}
                                                variant="secondary"
                                                size="sm"
                                                disabled={isLoading}
                                            >
                                                {isLoading ? <div className="w-4 h-4 border-2 border-t-transparent border-gray-600 rounded-full animate-spin"></div> : texts.disconnect}
                                            </Button>
                                        ) : (
                                            <Button
                                                onClick={() => handleConnectAccount(platform)}
                                                className={`${getPlatformColor(platform)} text-white`}
                                                size="sm"
                                                disabled={isLoading}
                                            >
                                                {isLoading ? <div className="w-4 h-4 border-2 border-t-transparent border-white rounded-full animate-spin"></div> : texts.connect}
                                            </Button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </>
            )}
            <FacebookPageSelectionModal
                isOpen={isFacebookPageSelectionModalOpen}
                pages={facebookPages}
                onSelectPage={handleFacebookPageSelected}
                onClose={() => setIsFacebookPageSelectionModalOpen(false)}
                language={language}
                onRetryConnect={handleRetryFacebookConnect}
            />
        </div>
    );
});


interface PersonasDisplayProps {
    personas: Persona[];
    generatedImages: Record<string, string>;
    onSavePersona: (persona: Persona) => void;
    onDeletePersona: (personaId: string) => void;
    onSetPersonaImage: (dataUrl: string, imageKey: string, personaId: string) => void;
    isUploadingImage: (imageKey: string) => boolean;
    language: string;
    onUpdatePersona: (persona) => void; // New prop for updating persona after social account changes
    // Lazy loading props
    isDataLoaded?: boolean;
    onLoadData?: () => void;
    isLoading?: boolean;
}

const PersonasDisplay: React.FC<PersonasDisplayProps> = ({ personas, generatedImages, onSavePersona, onDeletePersona, onSetPersonaImage, isUploadingImage, language, onUpdatePersona, isDataLoaded, onLoadData, isLoading }) => {
    const [isPersonasDataLoaded, setIsPersonasDataLoaded] = useState(false);
    const [isLoadingPersonasData, setIsLoadingPersonasData] = useState(false);
    
    // Load data when component mounts if not already loaded
    useEffect(() => {
        if (!isDataLoaded && onLoadData && !isLoading) {
            setIsLoadingPersonasData(true);
            onLoadData().finally(() => {
                setIsLoadingPersonasData(false);
                setIsPersonasDataLoaded(true);
            });
        } else if (isDataLoaded) {
            setIsPersonasDataLoaded(true);
        }
    }, [isDataLoaded, onLoadData, isLoading]);
    
    const [newPersona, setNewPersona] = useState<Persona | null>(null);

    const T = {
        'Việt Nam': {
            title: "Quản lý KOL/KOC",
            subtitle: "Định nghĩa các nhân vật sẽ đại diện cho thương hiệu của bạn trong các chiến dịch.",
            addPersona: "Thêm KOL/KOC mới",
            noPersonas: "Chưa có KOL/KOC nào.",
            addFirst: "Thêm người đầu tiên để bắt đầu.",
            confirmDelete: "Bạn có chắc muốn xóa nhân vật này không? Điều này không thể hoàn tác.",
        },
        'English': {
            title: "KOL/KOC Management",
            subtitle: "Define the personas who will represent your brand in campaigns.",
            addPersona: "Add New KOL/KOC",
            noPersonas: "No personas yet.",
            addFirst: "Add your first one to get started.",
            confirmDelete: "Are you sure you want to delete this persona? This cannot be undone.",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const createEmptyPersona = (): Persona => {
        const id = crypto.randomUUID();
        return {
            id,
            nickName: '',
            outfitDescription: '',
            mainStyle: '',
            activityField: '',
            photos: Array.from({ length: 5 }, (_, i) => ({
                id: crypto.randomUUID(),
                imageKey: `persona_${id}_photo_${i}`
            })),
            socialAccounts: [],
        };
    };
    
    const handleAddNew = () => {
        setNewPersona(createEmptyPersona());
    };

    const handleSaveNew = (persona: Persona) => {
        onSavePersona(persona);
        setNewPersona(null);
    };

    const handleCancelNew = () => {
        setNewPersona(null);
    };

    const handleDelete = (personaId: string) => {
        if (window.confirm(texts.confirmDelete)) {
            onDeletePersona(personaId);
        }
    };

    return (
        <div className="h-full flex flex-col p-6 lg:p-10 bg-gray-50/50">
            {/* Loading indicator */}
            {isLoadingPersonasData && (
                <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50">
                    <div className="bg-white p-8 rounded-lg shadow-xl flex flex-col items-center">
                        <div className="w-12 h-12 border-4 border-brand-green border-t-transparent rounded-full animate-spin mb-4"></div>
                        <p className="text-gray-700 font-medium">Loading personas data...</p>
                    </div>
                </div>
            )}
            
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                 <div>
                    <h2 className="text-3xl font-bold font-sans text-gray-900 flex items-center gap-3"><UsersIcon className="h-8 w-8 text-brand-green"/> {texts.title}</h2>
                    <p className="text-lg text-gray-500 font-serif mt-1">{texts.subtitle}</p>
                </div>
                <div className="flex-shrink-0">
                    <Button onClick={handleAddNew} className="flex items-center gap-2">
                        <PlusIcon className="h-5 w-5"/> {texts.addPersona}
                    </Button>
                </div>
            </header>

             <main className="flex-grow overflow-y-auto -mx-2">
                {(!personas || personas.length === 0) && !newPersona ? (
                     <div className="text-center py-20 bg-white rounded-xl border-2 border-dashed border-gray-300">
                        <UsersIcon className="mx-auto h-16 w-16 text-gray-400" />
                        <h3 className="mt-2 text-2xl font-bold font-sans text-gray-900">{texts.noPersonas}</h3>
                        <p className="mt-1 text-md text-gray-500 font-serif">{texts.addFirst}</p>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 p-2">
                        {newPersona && (
                            <PersonaCard
                                persona={newPersona}
                                isNew
                                onSave={handleSaveNew}
                                onCancel={handleCancelNew}
                                onDelete={() => {}} // Not applicable for new
                                onSetImage={(photoId, dataUrl) => onSetPersonaImage(newPersona.id, photoId, dataUrl)}
                                generatedImages={generatedImages}
                                isUploadingImage={isUploadingImage}
                                language={language}
                                onUpdatePersona={onSavePersona} // Pass onSavePersona as onUpdatePersona for new personas
                            />
                        )}
                        {personas.map(p => (
                            <PersonaCard
                                key={p.id}
                                persona={p}
                                onSave={onSavePersona}
                                onDelete={() => handleDelete(p.id)}
                                onCancel={() => {}} // Not applicable
                                onSetImage={(photoId, dataUrl) => onSetPersonaImage(p.id, photoId, dataUrl)}
                                generatedImages={generatedImages}
                                isUploadingImage={isUploadingImage}
                                language={language}
                                onUpdatePersona={onUpdatePersona}
                            />
                        ))}
                    </div>
                )}
             </main>
        </div>
    );
};

export default PersonasDisplay;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PersonasDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PlanSelectionModal.tsx ---\n\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PlanSelectionModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostCard.tsx ---\n


import React, { useRef, useState, useEffect } from 'react';
import { Button } from './ui';
import { YouTubeIcon, FacebookIcon, InstagramIcon, TikTokIcon, PinterestIcon, SparklesIcon, CheckCircleIcon, PencilIcon, CopyIcon, CheckSolidIcon, DotsVerticalIcon, KhongMinhIcon, ChatBubbleLeftIcon, VideoCameraIcon } from './icons';
import type { MediaPlanPost, PostInfo } from '../types';

const platformIcons: Record<string, React.FC<any>> = {
    YouTube: YouTubeIcon,
    Facebook: FacebookIcon,
    Instagram: InstagramIcon,
    TikTok: TikTokIcon,
    Pinterest: PinterestIcon
};

export interface PostCardProps {
    postInfo: PostInfo;
    language: string;
    onViewDetails: (postInfo: PostInfo) => void;
    imageUrl?: string;
    videoUrl?: string;
    promotedProductsCount?: number;
    isDraft: boolean;
    isSelected: boolean;
    onToggleSelection: (postId: string) => void;
    scheduledAt?: string;
    publishedAt?: string;
    publishedUrl?: string;
}

const PostCard: React.FC<PostCardProps> = (props) => {
    const { postInfo, language, onViewDetails, imageUrl, videoUrl, promotedProductsCount, isDraft, isSelected, onToggleSelection, scheduledAt, publishedAt, publishedUrl } = props;
    const { post } = postInfo;
    const Icon = platformIcons[post.platform] || SparklesIcon;
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [copied, setCopied] = useState(false);
    const menuRef = useRef<HTMLDivElement>(null);

    const T = {
        'Việt Nam': {
            edit: "Xem / Chỉnh sửa",
            copy: "Sao chép Nội dung",
            copied: "Đã chép",
            draft: "Bản nháp",
            promoted: "SP KM",
            commented: "Bình luận",
            video: "Video",
            scheduled: "Đã lên lịch vào",
            published: "Đã đăng vào",
            viewPost: "Xem bài đăng",
        },
        'English': {
            edit: "View / Edit",
            copy: "Copy Content",
            copied: "Copied",
            draft: "Draft",
            promoted: "Promo",
            commented: "Comment",
            video: "Video",
            scheduled: "Scheduled at",
            published: "Published at",
            viewPost: "View Post",
        }
    };
    const texts = (T as any)[language] || T['English'];
    
    const textToCopy = [ post.title, post.content, (post.hashtags || []).join(' '), `CTA: ${post.cta}` ].filter(Boolean).join('\n\n');
    
    const handleCopy = () => {
        navigator.clipboard.writeText(textToCopy);
        setCopied(true);
        setTimeout(() => { setCopied(false); setIsMenuOpen(false); }, 2000);
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                setIsMenuOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleCardClick = (e: React.MouseEvent) => {
        if ((e.target as HTMLElement).closest('.no-expand') || (e.target as HTMLElement).closest('a')) {
            return;
        }
        onViewDetails(postInfo);
    };

    const order = post.mediaOrder || [];
    const media: {type: 'image' | 'video', url: string}[] = [];

    // Use a map to ensure we only add each type once, respecting the explicit order first.
    const mediaMap = new Map<'image' | 'video', string>();
    if(imageUrl) mediaMap.set('image', imageUrl);
    if(videoUrl) mediaMap.set('video', videoUrl);

    const orderedMedia: {type: 'image' | 'video', url: string}[] = [];
    const addedTypes = new Set<'image' | 'video'>();

    // Add based on explicit order
    for (const type of order) {
        if (mediaMap.has(type) && !addedTypes.has(type)) {
            orderedMedia.push({ type, url: mediaMap.get(type)! });
            addedTypes.add(type);
        }
    }
    // Add any remaining media (for backward compatibility)
    for (const [type, url] of mediaMap.entries()) {
        if (!addedTypes.has(type)) {
             orderedMedia.push({ type, url });
        }
    }

    const firstMedia = orderedMedia[0];

    const TitleComponent = publishedUrl ? 'a' : 'h4';
    const titleProps = publishedUrl ? { href: publishedUrl, target: '_blank', rel: 'noopener noreferrer', className: "hover:underline" } : {};


    return (
        <div 
            className={`relative bg-white rounded-xl p-4 flex flex-col h-full border-2 shadow-sm group transition-all duration-200 ease-in-out cursor-pointer hover:shadow-md hover:-translate-y-0.5
                ${isSelected ? 'border-brand-green bg-green-50/50 shadow-lg' : 'border-gray-200'}
                ${publishedUrl ? 'bg-blue-50/50' : ''}
            `}
            onClick={handleCardClick}
        >
            <div 
                role="checkbox"
                aria-checked={isSelected}
                className="absolute top-3 left-3 z-10 no-expand"
                onClick={(e) => {
                    e.stopPropagation();
                    onToggleSelection(post.id);
                }}
            >
                <div className={`h-6 w-6 rounded-md flex items-center justify-center border-2 transition-colors
                    ${isSelected ? 'bg-brand-green border-brand-green-dark' : 'bg-white border-gray-300 group-hover:border-gray-400'}
                `}>
                    {isSelected && <CheckSolidIcon className="h-4 w-4 text-white" />}
                </div>
            </div>

            <div className="absolute top-3 right-3 z-20 flex items-center gap-2 no-expand">
                {publishedUrl && (
                     <a href={publishedUrl} target="_blank" rel="noopener noreferrer" className="text-xs px-2 py-1 rounded-full font-semibold text-blue-800 bg-blue-100 hover:bg-blue-200 transition-colors flex items-center gap-1.5">
                        <CheckCircleIcon className="h-4 w-4" />
                        {texts.viewPost}
                    </a>
                )}
                <div className="relative" ref={menuRef}>
                    <button onClick={(e) => { e.stopPropagation(); setIsMenuOpen(o => !o); }} className="p-1.5 rounded-full text-gray-400 hover:bg-gray-100 hover:text-gray-700 transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100">
                        <DotsVerticalIcon className="h-5 w-5" />
                    </button>
                    {isMenuOpen && (
                        <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg border z-30">
                            <button onClick={() => { onViewDetails(postInfo); setIsMenuOpen(false); }} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                <PencilIcon className="h-4 w-4" /> {texts.edit}
                            </button>
                            <button onClick={handleCopy} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                {copied ? <CheckCircleIcon className="h-4 w-4 text-brand-green" /> : <CopyIcon className="h-4 w-4" />} {copied ? texts.copied : texts.copy}
                            </button>
                        </div>
                    )}
                </div>
            </div>

            <div className="flex-grow">
                 <div className="flex items-start gap-3 mb-3 ml-8">
                    <Icon className="h-10 w-10 mt-0.5 flex-shrink-0" />
                    <div className="flex-1 min-w-0">
                         <TitleComponent className="font-bold font-sans text-gray-900 truncate pr-8" title={post.title} {...titleProps}>{post.title}</TitleComponent>
                        <span className="text-sm text-gray-500 block truncate">{post.platform} - {post.contentType}</span>
                    </div>
                </div>

                {firstMedia && (
                    <div className="mb-2 rounded-lg overflow-hidden bg-gray-100 relative">
                        {firstMedia.type === 'image' ? (
                            <img src={firstMedia.url} alt={post.title} className="w-full h-full object-cover" />
                        ) : (
                            <>
                                <video src={firstMedia.url} className="w-full h-24 object-cover bg-black" />
                                <div className="absolute inset-0 flex items-center justify-center bg-black/30 pointer-events-none">
                                    <div className="bg-black/50 p-2 rounded-full">
                                        <VideoCameraIcon className="h-6 w-6 text-white" />
                                    </div>
                                </div>
                            </>
                        )}
                    </div>
                )}
            </div>
            
            <div className="mt-auto flex-shrink-0 pt-2 flex justify-start items-center flex-wrap gap-2">
                 {isDraft && !publishedAt && !scheduledAt && (
                    <div className="text-xs px-2 py-0.5 rounded-full font-medium text-gray-800 bg-gray-100">
                        {texts.draft}
                    </div>
                 )}
                 {scheduledAt && !publishedAt && (
                    <div className="text-xs px-2 py-0.5 rounded-full font-medium text-green-800 bg-green-100">
                        {texts.scheduled} {scheduledAt}
                    </div>
                 )}
                 {publishedAt && (
                    <div className="text-xs px-2 py-0.5 rounded-full font-medium text-blue-800 bg-blue-100">
                        {texts.published} {publishedAt}
                    </div>
                 )}
                 {post.videoKey && (
                     <div className="text-xs px-2 py-0.5 rounded-full font-medium text-blue-800 bg-blue-100 flex items-center gap-1">
                        <VideoCameraIcon className="h-3 w-3" />
                        <span>{texts.video}</span>
                    </div>
                 )}
                {promotedProductsCount && promotedProductsCount > 0 && (
                     <div className="text-xs px-2 py-0.5 rounded-full font-medium text-purple-800 bg-purple-100 flex items-center gap-1">
                        <KhongMinhIcon className="h-3 w-3" />
                        <span>{texts.promoted}</span>
                    </div>
                )}
                {post.autoComment && (
                     <div className="text-xs px-2 py-0.5 rounded-full font-medium text-sky-800 bg-sky-100 flex items-center gap-1">
                        <ChatBubbleLeftIcon className="h-3 w-3" />
                        <span>{texts.commented}</span>
                    </div>
                )}
            </div>
        </div>
    )
}

export default PostCard;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostCard.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostDetailModal.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';
import type { MediaPlanPost, AffiliateLink, SchedulingPost, PostInfo } from '../types';
import { Button, Input, TextArea, HoverCopyWrapper } from './ui';
import { DownloadIcon, SparklesIcon, YouTubeIcon, FacebookIcon, InstagramIcon, TikTokIcon, PinterestIcon, UploadIcon, LinkIcon, CheckCircleIcon, CalendarIcon, VideoCameraIcon } from './icons';
import KhongMinhSuggestion from './KhongMinhSuggestion';


const platformIcons: Record<string, React.FC<any>> = {
    YouTube: YouTubeIcon,
    Facebook: FacebookIcon,
    Instagram: InstagramIcon,
    TikTok: TikTokIcon,
    Pinterest: PinterestIcon
};

const renderPostContent = (content: string | any): string => {
    if (typeof content === 'string') {
        return content;
    }
    if (typeof content === 'object' && content !== null) {
        // This handles cases where the AI returns a structured object instead of a string.
        // We'll format it nicely into a readable string.
        return Object.entries(content)
            .map(([key, value]) => `**${key.charAt(0).toUpperCase() + key.slice(1)}:**\n${value}`)
            .join('\n\n');
    }
    return ''; // Return empty string for other types like null, undefined, etc.
};


const GenerateIdeaHandler: React.FC <{
    onGeneratePrompt: () => void;
    isGenerating: boolean;
    texts: any;
}> = ({ onGeneratePrompt, isGenerating, texts }) => {
    return (
        <div className="bg-white border border-gray-200 p-6 rounded-lg h-full flex flex-col items-center justify-center text-center">
            <SparklesIcon className="h-12 w-12 text-gray-400" />
            <h5 className="mt-4 font-semibold font-sans text-gray-800 text-lg">{texts.generateIdeaTitle}</h5>
            <p className="mt-1 text-gray-500 text-sm font-serif">{texts.generateIdeaDesc}</p>
            <Button
                onClick={onGeneratePrompt}
                disabled={isGenerating}
                className="mt-4 w-full flex items-center justify-center gap-2"
            >
                {isGenerating ? (
                    <>
                        <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                        <span>{texts.generatingIdea}</span>
                    </>
                ) : (
                    <>
                        <SparklesIcon className="h-5 w-5" />
                        {texts.generateIdea}
                    </>
                )}
            </Button>
        </div>
    );
};

interface MediaHandlerProps {
    postInfo: PostInfo;
    aspectRatio: "1:1" | "16:9";
    onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9") => void;
    onSetImage: (dataUrl: string, key: string) => void;
    onSetVideo: (dataUrl: string, key: string) => void;
    generatedImages: Record<string, string>;
    generatedVideos: Record<string, string>;
    isGenerating: boolean;
    texts: any;
};

const MediaHandler: React.FC<MediaHandlerProps> = ({ postInfo, aspectRatio, onGenerateImage, onSetImage, onSetVideo, generatedImages, generatedVideos, isGenerating, texts }) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const { post } = postInfo;

    const handleFile = (file: File | null) => {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target?.result as string;
            if (dataUrl) {
                if (file.type.startsWith('video/')) {
                    onSetVideo(dataUrl, post.id); // Use post id as base key
                } else if (file.type.startsWith('image/')) {
                    onSetImage(dataUrl, post.imageKey || post.id);
                }
            }
        };
        reader.readAsDataURL(file);
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        handleFile(e.target.files?.[0] || null);
    };
    
    const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.clipboardData.files.length > 0) {
            handleFile(e.clipboardData.files[0]);
        }
    };
    
    const generatedImage = post.imageKey ? generatedImages[post.imageKey] : undefined;
    const generatedVideo = post.videoKey ? generatedVideos[post.videoKey] : undefined;

    const renderImageComponent = () => {
        if (!generatedImage) return null;
        return (
             <div className="relative group rounded-lg overflow-hidden" tabIndex={0}>
                <img src={generatedImage} alt={post.mediaPrompt} className="w-full object-cover" style={{ aspectRatio }}/>
                <div className="absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                     <div className="flex flex-col gap-2 items-center p-2">
                        <Button onClick={() => onGenerateImage(post.mediaPrompt!, post.imageKey!, aspectRatio)} disabled={isGenerating} variant="primary" className="w-full flex items-center justify-center gap-2 text-xs py-1 px-2">
                            <SparklesIcon className="h-4 w-4" /> {texts.regenerate}
                        </Button>
                        <Button onClick={() => fileInputRef.current?.click()} variant="secondary" className="w-full flex items-center justify-center gap-2 text-xs py-1 px-2">
                           <UploadIcon className="h-4 w-4" /> {texts.changeImage}
                        </Button>
                    </div>
                    <a href={generatedImage} download={`${post.imageKey}.jpg`} className="absolute bottom-2 right-2 bg-gray-800 text-white p-2 rounded-full hover:bg-black transition-colors">
                       <DownloadIcon className="h-4 w-4"/>
                    </a>
                </div>
            </div>
        );
    };
    
    const renderVideoComponent = () => {
        if (!generatedVideo) return null;
        return (
            <div className="relative group rounded-lg overflow-hidden bg-black" tabIndex={0}>
                <video src={generatedVideo} controls className="w-full h-full object-cover" style={{ aspectRatio }} />
                <div className="absolute top-2 right-2 flex flex-col items-end gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                    <Button onClick={() => fileInputRef.current?.click()} variant="secondary" className="flex items-center justify-center gap-2 text-xs py-1 px-2 bg-white/80 hover:bg-white backdrop-blur-sm">
                       <UploadIcon className="h-4 w-4" /> {texts.changeVideo}
                    </Button>
                    <a href={generatedVideo} download={`${post.videoKey || 'video'}.mp4`} className="bg-gray-800/80 text-white p-2 rounded-full hover:bg-black transition-colors backdrop-blur-sm">
                       <DownloadIcon className="h-4 w-4"/>
                    </a>
                </div>
            </div>
        );
    };
    
    const renderImagePromptUploader = () => {
        if (!post.mediaPrompt) return null;

        const renderMediaPrompt = () => {
            if (Array.isArray(post.mediaPrompt)) {
                return (
                    <div className="space-y-2">
                        {post.mediaPrompt.map((prompt, index) => (
                            <HoverCopyWrapper key={index} textToCopy={prompt}>
                                <p className="text-gray-500 italic text-sm font-serif">{index + 1}: "{prompt}"</p>
                            </HoverCopyWrapper>
                        ))}
                    </div>
                )
            }
            return (
                <HoverCopyWrapper textToCopy={post.mediaPrompt as string}>
                    <p className="text-gray-500 italic mb-3 text-sm font-serif flex-grow">"{post.mediaPrompt}"</p>
                </HoverCopyWrapper>
            )
        }

        return (
            <div className="bg-white border border-gray-200 p-4 rounded-lg h-full flex flex-col">
                <h5 className="font-semibold font-sans text-gray-700 text-sm">{texts.prompt}</h5>
                {renderMediaPrompt()}
                {post.script && (
                    <>
                        <h5 className="font-semibold font-sans text-gray-700 text-sm mt-4">{texts.script}</h5>
                        <p className="text-gray-500 italic mb-3 text-sm font-serif flex-grow">{post.script}</p>
                    </>
                )}
                <div className="space-y-2 mt-auto">
                    <Button onClick={() => onGenerateImage(post.mediaPrompt!, post.imageKey || post.id, aspectRatio)} disabled={isGenerating} className="w-full flex items-center justify-center gap-2">
                        <SparklesIcon /> {texts.generate}
                    </Button>
                    <div 
                        className="relative w-full text-center border-2 border-dashed border-gray-300 rounded-lg p-4 hover:border-brand-green transition-colors cursor-pointer"
                        onClick={() => fileInputRef.current?.click()}
                    >
                        <UploadIcon className="mx-auto h-8 w-8 text-gray-400" />
                        <p className="text-xs text-gray-500 mt-1">{texts.uploadOrPaste}</p>
                    </div>
                </div>
            </div>
        );
    };

    const renderGenericUploader = () => (
        <div 
            className="w-full h-full min-h-[200px] bg-gray-50 flex flex-col justify-center items-center text-center p-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-brand-green transition-colors cursor-pointer"
            onClick={() => fileInputRef.current?.click()}
        >
            <div className="flex items-center gap-4 text-gray-400">
                <VideoCameraIcon className="h-10 w-10"/>
                <span className="text-2xl font-thin">/</span>
                <SparklesIcon className="h-10 w-10"/>
            </div>
            <p className="mt-4 text-sm font-semibold text-gray-600">{texts.uploadMedia}</p>
            <p className="text-xs text-gray-500 mt-1">{texts.uploadOrPaste}</p>
        </div>
    );
    
    if (isGenerating) {
        return (
            <div className="w-full bg-gray-100 flex flex-col items-center justify-center rounded-lg border border-gray-200" style={{ aspectRatio, minHeight: '150px' }}>
                <div className="w-8 h-8 border-2 border-t-transparent border-brand-green rounded-full animate-spin"></div>
                <span className="text-sm mt-2 text-gray-500">{texts.generating}</span>
            </div>
        );
    }

    const imageContent = generatedImage ? renderImageComponent() : renderImagePromptUploader();
    const videoContent = renderVideoComponent();
    
    const mediaMap = { image: imageContent, video: videoContent };
    let orderedComponents: (JSX.Element | null)[] = [];
    const order = post.mediaOrder || [];
    const addedTypes = new Set<'image' | 'video'>();

    for (const type of order) {
        if (mediaMap[type]) {
            orderedComponents.push(mediaMap[type]);
            addedTypes.add(type);
        }
    }
    for (const type of ['image', 'video'] as const) {
        if (!addedTypes.has(type) && mediaMap[type]) {
            orderedComponents.push(mediaMap[type]);
        }
    }
    
    if (orderedComponents.length === 0) {
        orderedComponents.push(renderGenericUploader());
    }

    return (
        <div onPaste={handlePaste} tabIndex={-1} className="focus:outline-none">
            <div className={`grid ${orderedComponents.filter(Boolean).length > 1 ? 'grid-cols-1 md:grid-cols-2 gap-4' : 'grid-cols-1'}`}>
                {orderedComponents.map((comp, index) => comp ? <div key={index}>{comp}</div> : null)}
            </div>
            <input type="file" ref={fileInputRef} className="hidden" accept="image/*,video/*" onChange={handleFileChange} />
        </div>
    );
};


interface PostDetailModalProps {
  isOpen: boolean;
  onClose: () => void;
  postInfo: PostInfo;
  language: string;
  weekTheme?: string;
  onUpdatePost: (postInfo: PostInfo) => void;
  onGenerateImage: (prompt: string, key: string, aspectRatio?: "1:1" | "16:9", postInfo?: PostInfo) => void;
  onSetImage: (dataUrl: string, key: string, postInfo?: PostInfo) => void;
  onSetVideo: (dataUrl: string, key: string, postInfo: PostInfo) => void;
  onGeneratePrompt: (postInfo: PostInfo) => void;
  onRefinePost: (text: string) => Promise<string>;
  onRunKhongMinhForPost: () => void;
  onAcceptSuggestion: (productId: string) => void;
  generatedImages: Record<string, string>;
  generatedVideos: Record<string, string>;
  isGeneratingImage: (key: string) => boolean;
  isGeneratingPrompt: boolean;
  isAnyAnalysisRunning: boolean;
  isAnalyzing: boolean;
  khongMinhSuggestions: Record<string, AffiliateLink[]>;
  affiliateLinks: AffiliateLink[];
  onGenerateComment: (postInfo: PostInfo) => void;
  isGeneratingComment: boolean;
  onOpenScheduleModal: (post: SchedulingPost) => void;
  onPublishPost: (postInfo: PostInfo) => Promise<void>; 
  publishedUrl?: string;
  publishedAt?: string;
}



const PostDetailModal: React.FC<PostDetailModalProps> = (props) => {
    const { isOpen, onClose, postInfo, language, onUpdatePost, onGenerateComment, isGeneratingComment, onOpenScheduleModal, onSetVideo, onPublishPost, publishedAt, publishedUrl } = props;
    const [isEditing, setIsEditing] = useState(false);
    const [isRefining, setIsRefining] = useState(false);
    const [isPublishing, setIsPublishing] = useState(false);
    const [editedPost, setEditedPost] = useState<MediaPlanPost | null>(postInfo.post);
    
    useEffect(() => {
        if (postInfo) {
            setEditedPost(postInfo.post);
        }
        if (isOpen) {
            setIsEditing(false); 
        }
    }, [postInfo, isOpen]);

    if (!isOpen || !postInfo || !editedPost) return null;
    const { post } = postInfo;
    const Icon = platformIcons[post.platform] || SparklesIcon;

    const T = {
        'Việt Nam': {
            edit: "Chỉnh sửa",
            schedule: "Lên lịch",
            draft: "Bản nháp",
            generateIdea: "Tạo ý tưởng ảnh",
            generateIdeaTitle: "Tạo một ý tưởng hình ảnh",
            generateIdeaDesc: "Để AI tạo một khái niệm hình ảnh cho bài đăng này dựa trên nội dung của nó.",
            generatingIdea: "Đang tạo...",
            save: "Lưu",
            cancel: "Hủy",
            refine_with_ai: "Làm mới bằng AI",
            refining: "Đang làm mới...",
            generate_comment: "Tạo bình luận (NgoSiLien)",
            generating_comment: "Đang tạo (NgoSiLien)...",
            auto_comment: "Bình luận được tạo tự động",
            no_comment: "Chưa có bình luận nào được tạo.",
            regenerate: "Tạo lại",
            promoted_products: "Sản phẩm quảng bá",
            hashtags_title: "Hashtags",
            cta_title: "Kêu gọi hành động",
            sources: "Nguồn",
            scheduled_for: "Lên lịch cho",
            generating: 'Đang tạo...',
            generate: 'Tạo ảnh',
            prompt: 'Prompt ảnh:',
            changeImage: 'Đổi ảnh',
            changeVideo: 'Đổi video',
            uploadOrPaste: 'Bấm để tải lên hoặc dán phương tiện',
            uploadMedia: 'Tải lên Ảnh hoặc Video',
            youtube_description: "Mô tả YouTube",
            youtube_script: "Kịch bản YouTube",
            script: "Kịch bản",
            publishNow: "Đăng ngay",
            publishing: "Đang đăng...",
            published: "Đã đăng vào",
            viewPost: "Xem bài đăng",
            postIsPublished: "Bài đăng này đã được xuất bản và không thể chỉnh sửa.",
        },
        'English': {
            edit: "Edit",
            schedule: "Schedule",
            draft: "Draft",
            generateIdea: "Generate Image Idea",
            generateIdeaTitle: "Generate an Image Idea",
            generateIdeaDesc: "Let AI create a visual concept for this post based on its content.",
            generatingIdea: "Generating...",
            save: "Save",
            cancel: "Cancel",
            refine_with_ai: "Refine with AI",
            refining: "Refining...",
            generate_comment: "Generate Comment (NgoSiLien)",
            generating_comment: "Generating (NgoSiLien)...",
            auto_comment: "Auto-Generated Comment",
            no_comment: "No comment generated yet.",
            regenerate: "Regenerate",
            promoted_products: "Promoted Products",
            hashtags_title: "Hashtags",
            cta_title: "Call to Action",
            sources: "Sources",
            scheduled_for: "Scheduled for",
            generating: 'Generating...',
            generate: 'Generate Image',
            prompt: 'Image Prompt:',
            changeImage: 'Change Image',
            changeVideo: 'Change Video',
            uploadOrPaste: 'Click to upload or paste media',
            uploadMedia: 'Upload Image or Video',
            youtube_description: "YouTube Description",
            youtube_script: "YouTube Script",
            script: "Script",
            publishNow: "Publish Now",
            publishing: "Publishing...",
            published: "Published at",
            viewPost: "View Post",
            postIsPublished: "This post has been published and cannot be edited.",
        }
    };
    const texts = (T as any)[language] || T['English'];
    const locale = language === 'Việt Nam' ? 'vi-VN' : 'en-US';

    const handleEditChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setEditedPost(prev => {
            if (!prev) return null;
            if (name === 'hashtags') {
                return { ...prev, hashtags: value.split(',').map(h => h.trim()) };
            }
            if (name === 'script') {
                return { ...prev, script: value };
            }
            return { ...prev, [name]: value };
        });
    };

    const handleSaveEdit = () => {
        if (editedPost) {
            const postToSave = { ...editedPost };
            if (typeof postToSave.content !== 'string') {
                postToSave.content = JSON.stringify(postToSave.content, null, 2);
            }
            if (postToSave.description && typeof postToSave.description !== 'string') {
                postToSave.description = JSON.stringify(postToSave.description, null, 2);
            }
            onUpdatePost({ ...postInfo, post: postToSave });
        }
        setIsEditing(false);
    };

    const handleCancelEdit = () => {
        setEditedPost(post);
        setIsEditing(false);
    };

    const handleRefine = async () => {
        if (!editedPost || isRefining) return;
        const contentToRefine = typeof editedPost.content === 'string' ? editedPost.content : JSON.stringify(editedPost.content, null, 2);
        if (!contentToRefine.trim()) return;

        setIsRefining(true);
        try {
            const refinedText = await props.onRefinePost(contentToRefine);
            setEditedPost(prev => prev ? { ...prev, content: refinedText } : null);
        } catch (error) {
            console.error("Refinement failed in modal:", error);
        } finally {
            setIsRefining(false);
        }
    };
    
    const handlePublish = async () => {
        if (isPublishing) return;
        setIsPublishing(true);
        try {
            await onPublishPost(postInfo);
            // Optionally close modal on success, or show a success message
            onClose(); 
        } catch (error) {
            console.error("Failed to publish post:", error);
            // Optionally show an error message to the user
        } finally {
            setIsPublishing(false);
        }
    };
    
    // Match promoted products with affiliate links
    // Handle both cases: IDs might be UUIDs or Airtable record IDs (starting with "rec")
    const acceptedProducts = props.affiliateLinks.filter(link => 
        (editedPost.promotedProductIds || []).some(id => {
            // Check if id and link.id are defined before calling trim
            if (id && link.id && id.trim() === link.id.trim()) {
                return true;
            }
            // If the promoted ID looks like an Airtable record ID, we might need to handle it differently
            // But since we've fixed the saving logic, this should be rare
            return false;
        })
    );
    const suggestedProducts = (props.khongMinhSuggestions[post.id] || []).filter(s => !(editedPost.promotedProductIds || []).includes(s.id));
    const hasPromotedProducts = (editedPost.promotedProductIds || []).length > 0;
    
    const hasMediaPath = editedPost.mediaPrompt || editedPost.script || (editedPost.imageKey && props.generatedImages[editedPost.imageKey]) || (editedPost.videoKey && props.generatedVideos[editedPost.videoKey]);

    const isYouTubePillar = post.isPillar && post.platform === 'YouTube';
    const isPublished = !!publishedUrl;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-40 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl border border-gray-200 m-4 max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                <header className="p-6 border-b border-gray-200 flex justify-between items-start gap-4">
                    <div className="flex items-center gap-3">
                        <Icon className="h-8 w-8 text-gray-700 flex-shrink-0" />
                        <div className="flex-1 min-w-0">
                            {isEditing && !isPublished ? (
                                <Input name="title" value={editedPost.title} onChange={handleEditChange} className="text-xl font-bold p-1" />
                            ) : (
                                <h2 className="text-2xl font-bold font-sans text-gray-900">{editedPost.title}</h2>
                            )}
                            <p className="text-md text-gray-500">{editedPost.platform} - {editedPost.contentType}</p>
                        </div>
                    </div>
                    <div className="flex items-center gap-2 flex-shrink-0">
                         {isPublished && (
                            <a href={publishedUrl} target="_blank" rel="noopener noreferrer" className="text-sm px-3 py-1.5 rounded-full font-semibold text-white bg-brand-green hover:bg-brand-green-dark transition-colors flex items-center gap-2">
                                <CheckCircleIcon className="h-5 w-5" />
                                {texts.viewPost}
                            </a>
                        )}
                        <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
                    </div>
                </header>

                <main className="flex-grow overflow-y-auto grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6 p-6">
                    {/* Left Column (Content) */}
                    <div className="lg:col-span-3 flex flex-col">
                        {isPublished && (
                             <div className="bg-blue-50 border-l-4 border-blue-400 p-4 rounded-r-lg mb-4">
                                <p className="text-sm text-blue-800">{texts.postIsPublished}</p>
                            </div>
                        )}
                        {isEditing && !isPublished ? (
                            <div className="flex-grow space-y-4">
                                { isYouTubePillar ? (
                                    <>
                                        <label className="font-bold text-sm">{texts.youtube_description}</label>
                                        <TextArea name="description" value={typeof editedPost.description === 'string' ? editedPost.description || '' : JSON.stringify(editedPost.description, null, 2)} onChange={handleEditChange} rows={5} className="text-base" />
                                        <label className="font-bold text-sm">{texts.youtube_script}</label>
                                        <TextArea name="content" value={typeof editedPost.content === 'string' ? editedPost.content : JSON.stringify(editedPost.content, null, 2)} onChange={handleEditChange} rows={10} className="text-base" />
                                    </>
                                ) : (
                                    <>
                                        <TextArea name="content" value={typeof editedPost.content === 'string' ? editedPost.content : JSON.stringify(editedPost.content, null, 2)} onChange={handleEditChange} rows={10} className="text-base" />
                                        {editedPost.contentType.includes('Video') || editedPost.contentType.includes('Shorts') || editedPost.contentType.includes('Story') ? (
                                            <>
                                                <label className="font-bold text-sm">{texts.script}</label>
                                                <TextArea name="script" value={editedPost.script || ''} onChange={handleEditChange} rows={5} className="text-base" />
                                            </>
                                        ) : null}
                                    </>
                                )}
                                <Input name="hashtags" value={(editedPost.hashtags || []).join(', ')} onChange={handleEditChange} placeholder="hashtags, comma, separated" />
                                <Input name="cta" value={editedPost.cta} onChange={handleEditChange} placeholder="Call to Action" />
                            </div>
                        ) : (
                            <div className="flex-grow flex flex-col">
                                { isYouTubePillar ? (
                                    <div className="space-y-4">
                                        <div>
                                            <h4 className="font-bold text-gray-800">{texts.youtube_description}</h4>
                                            <p className="text-gray-800 text-base mt-1 font-serif whitespace-pre-wrap border p-2 rounded-md bg-gray-50">{renderPostContent(editedPost.description)}</p>
                                        </div>
                                         <div>
                                            <h4 className="font-bold text-gray-800">{texts.youtube_script}</h4>
                                            <p className="text-gray-800 text-base mt-1 font-serif whitespace-pre-wrap">{renderPostContent(editedPost.content)}</p>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        <p className="text-gray-800 text-base mb-4 font-serif whitespace-pre-wrap">{renderPostContent(editedPost.content)}</p>
                                        {editedPost.script && (
                                            <div>
                                                <h4 className="font-bold text-gray-800">{texts.script}</h4>
                                                <p className="text-gray-800 text-base mt-1 font-serif whitespace-pre-wrap border p-2 rounded-md bg-gray-50">{editedPost.script}</p>
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                <div className="text-sm text-gray-500 my-4 flex flex-wrap gap-x-4 gap-y-1">
                                    {props.weekTheme && (
                                        <span className="font-semibold">Week {postInfo.weekIndex + 1}: <span className="font-normal">{props.weekTheme}</span></span>
                                    )}
                                    {editedPost.scheduledAt && !publishedAt && (
                                        <span>{texts.scheduled_for}: {new Date(editedPost.scheduledAt).toLocaleString(locale, { dateStyle: 'long', timeStyle: 'short' })}</span>
                                    )}
                                     {publishedAt && (
                                        <span>{texts.published}: {new Date(publishedAt).toLocaleString(locale, { dateStyle: 'long', timeStyle: 'short' })}</span>
                                    )}
                                </div>

                                <div className="mt-auto pt-4 space-y-5">
                                    {/* Promoted Products Section */}
                                    {acceptedProducts.length > 0 && (
                                        <div>
                                            <h5 className="text-sm font-bold text-gray-600 mb-1.5 font-sans uppercase tracking-wider">{texts.promoted_products}</h5>
                                            <div className="space-y-2">
                                                {acceptedProducts.map(product => (
                                                    <a href={product.productLink} target="_blank" rel="noopener noreferrer" key={product.id} className="flex items-center gap-2 bg-gray-100 p-2 rounded-lg hover:bg-gray-200 transition-colors">
                                                        <LinkIcon className="h-4 w-4 text-gray-500 flex-shrink-0" />
                                                        <span className="text-sm text-gray-800 font-medium truncate">{product.productName}</span>
                                                    </a>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    {/* Sources section */}
                                    {editedPost.sources && editedPost.sources.length > 0 && (
                                        <div>
                                            <h5 className="text-sm font-bold text-gray-600 mb-1.5 font-sans uppercase tracking-wider">{texts.sources}</h5>
                                            <div className="space-y-1">
                                                {editedPost.sources.map((source, index) => (
                                                    <a key={index} href={source.uri} target="_blank" rel="noopener noreferrer" className="text-sm text-gray-500 hover:text-brand-green font-sans flex items-center gap-1.5 transition-colors" title={source.uri} >
                                                        <LinkIcon className="h-4 w-4 flex-shrink-0" />
                                                        <span className="truncate">{source.title}</span>
                                                    </a>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    {/* Hashtags Section */}
                                    {editedPost.hashtags && editedPost.hashtags.length > 0 && (
                                        <div>
                                            <h5 className="text-sm font-bold text-gray-600 mb-2 font-sans uppercase tracking-wider">{texts.hashtags_title}</h5>
                                            <div className="flex flex-wrap gap-2">
                                                {editedPost.hashtags.map(tag => <span key={tag} className="text-sm bg-green-50 text-green-800 px-3 py-1 rounded-full font-sans">{tag}</span>)}
                                            </div>
                                        </div>
                                    )}

                                    {/* New CTA design */}
                                    <div>
                                        <h5 className="text-sm font-bold text-gray-600 mb-1.5 font-sans uppercase tracking-wider">{texts.cta_title}</h5>
                                        <div className="bg-brand-green/10 p-4 rounded-lg flex items-start gap-3 border border-brand-green/20">
                                            <div className="w-8 h-8 rounded-full bg-brand-green/20 flex items-center justify-center flex-shrink-0 mt-0.5">
                                                <span className="text-xl">📢</span>
                                            </div>
                                            <p className="text-gray-800 text-base font-serif italic">{editedPost.cta}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                         <div className="mt-auto pt-4 border-t border-gray-200">
                            {isEditing && !isPublished ? (
                                <div className="flex items-center justify-end gap-2">
                                    <Button variant="tertiary" onClick={handleCancelEdit}>{texts.cancel}</Button>
                                    <Button variant="secondary" onClick={handleRefine} disabled={isRefining || !(typeof editedPost?.content === 'string' && editedPost.content.trim())}>
                                        {isRefining ? (
                                            <>
                                                <div className="w-4 h-4 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div>
                                                <span>{texts.refining}</span>
                                            </>
                                        ) : (
                                            <>
                                                <SparklesIcon className="h-4 w-4" />
                                                <span>{texts.refine_with_ai}</span>
                                            </>
                                        )}
                                    </Button>
                                    <Button onClick={handleSaveEdit}>{texts.save}</Button>
                                </div>
                            ) : (
                                <div className="flex items-center justify-end gap-2">
                                    {!isPublished && (
                                        <>
                                            <Button variant="secondary" onClick={() => onOpenScheduleModal(postInfo as SchedulingPost)} className="flex items-center gap-2"><CalendarIcon className="h-4 w-4"/> {texts.schedule}</Button>
                                            <Button variant="secondary" onClick={handlePublish} disabled={isPublishing} className="flex items-center gap-2">
                                                {isPublishing ? (
                                                    <>
                                                        <div className="w-4 h-4 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div>
                                                        <span>{texts.publishing}</span>
                                                    </>
                                                ) : (
                                                    <>
                                                        <LinkIcon className="h-4 w-4"/> {texts.publishNow}
                                                    </>
                                                )}
                                            </Button>
                                        </>
                                    )}
                                    <Button variant="primary" onClick={() => setIsEditing(true)} disabled={isPublished}>{texts.edit}</Button>
                                </div>
                            )}
                        </div>
                    </div>
                    {/* Right Column (Tools) */}
                    <div className="lg:col-span-2 space-y-4">
                       { hasMediaPath ? (
                            <MediaHandler
                                postInfo={postInfo}
                                aspectRatio={editedPost.platform === 'YouTube' ? '16:9' : '1:1'}
                                onGenerateImage={(prompt, key, aspectRatio) => props.onGenerateImage(prompt, key, aspectRatio, postInfo)}
                                onSetImage={(dataUrl, key) => props.onSetImage(dataUrl, key, postInfo)}
                                onSetVideo={(dataUrl, key) => onSetVideo(dataUrl, key, postInfo)}
                                generatedImages={props.generatedImages}
                                generatedVideos={props.generatedVideos}
                                isGenerating={props.isGeneratingImage(editedPost.imageKey || editedPost.id)}
                                texts={texts}
                            />
                        ) : (
                            <GenerateIdeaHandler
                                onGeneratePrompt={() => props.onGeneratePrompt(postInfo)}
                                isGenerating={props.isGeneratingPrompt}
                                texts={texts}
                            />
                        )}

                        {(props.affiliateLinks.length > 0 || acceptedProducts.length > 0) && (
                            <KhongMinhSuggestion
                                language={language}
                                isAnyAnalysisRunning={props.isAnyAnalysisRunning}
                                isAnalyzing={props.isAnalyzing}
                                acceptedProducts={acceptedProducts}
                                suggestedProducts={suggestedProducts}
                                affiliateLinksCount={props.affiliateLinks.length}
                                onAccept={(productId) => {
                                    if (!editedPost.promotedProductIds?.includes(productId)) {
                                        const updatedPost = { ...editedPost, promotedProductIds: [...(editedPost.promotedProductIds || []), productId] };
                                        setEditedPost(updatedPost);
                                        props.onUpdatePost({ ...postInfo, post: updatedPost });
                                    }
                                }}
                                onRunAnalysis={() => props.onRunKhongMinhForPost()}
                            />
                        )}

                        <div className="p-4 bg-gray-50 border border-gray-200 rounded-lg">
                            <h5 className="font-bold text-sm text-gray-800 mb-2">{texts.auto_comment}</h5>
                            {isEditing && !isPublished ? (
                                <TextArea
                                    name="autoComment"
                                    value={editedPost.autoComment || ''}
                                    onChange={handleEditChange}
                                    rows={5}
                                    className="text-sm font-serif"
                                    placeholder="Generate or write a comment..."
                                />
                            ) : (
                                editedPost.autoComment ? (
                                    <p className="text-sm font-serif whitespace-pre-wrap bg-white p-2 rounded border">{editedPost.autoComment}</p>
                                ) : (
                                    <p className="text-sm text-gray-500 font-serif italic text-center py-4">{texts.no_comment}</p>
                                )
                            )}

                            {hasPromotedProducts && (
                                <div className="mt-3 text-right">
                                    <Button
                                        variant="secondary"
                                        onClick={() => {
                                            if (!isEditing) setIsEditing(true);
                                            onGenerateComment(postInfo);
                                        }}
                                        disabled={isGeneratingComment || isPublished}
                                        className="text-xs py-1.5 px-2.5 flex items-center justify-center gap-1.5"
                                    >
                                        {isGeneratingComment ? (
                                            <>
                                                <div className="w-4 h-4 border-2 border-t-transparent border-gray-500 rounded-full animate-spin"></div>
                                                <span>{texts.generating_comment}</span>
                                            </>
                                        ) : (
                                            <>
                                                <SparklesIcon className="h-4 w-4" />
                                                <span>{editedPost.autoComment ? texts.regenerate : texts.generate_comment}</span>
                                            </>
                                        )}
                                    </Button>
                                </div>
                            )}
                        </div>

                    </div>
                </main>
            </div>
        </div>
    );
};

export default PostDetailModal;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\PostDetailModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductCard.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';
import type { AffiliateLink } from '../types';
import { Button, Input } from './ui';
import { DotsVerticalIcon, PencilIcon, TrashIcon, LinkIcon, TagIcon, SparklesIcon } from './icons';

interface ProductCardProps {
    link: AffiliateLink;
    onSave: (link: AffiliateLink) => void;
    onDelete?: () => void;
    onCancel?: () => void;
    isNew?: boolean;
    language: string;
    formatCurrency: (value: number) => string;
    onGenerateIdeas?: (product: AffiliateLink) => void; // New prop for generating ideas
}

const ProductCard: React.FC<ProductCardProps> = ({ link, onSave, onDelete, onCancel, isNew = false, language, formatCurrency, onGenerateIdeas }) => {
    const [isEditing, setIsEditing] = useState(isNew);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [editedLink, setEditedLink] = useState<AffiliateLink>(link);
    const menuRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        setEditedLink(link);
    }, [link]);

    const T = {
        'Việt Nam': {
            edit: "Chỉnh sửa",
            delete: "Xóa",
            price: "Giá",
            commissionValue: "Giá trị HH",
            commissionRate: "Tỷ lệ HH",
            productId: "Mã SP",
            productLink: "Link sản phẩm",
            promoLink: "Link ưu đãi",
            save: "Lưu",
            cancel: "Hủy",
            productName: "Tên sản phẩm",
            providerName: "Nhà cung cấp",
            salesVolume: "Doanh số",
            generateIdeas: "Tạo ý tưởng",
        },
        'English': {
            edit: "Edit",
            delete: "Delete",
            price: "Price",
            commissionValue: "Commission",
            commissionRate: "Comm. Rate",
            productId: "Product ID",
            productLink: "Product Link",
            promoLink: "Promo Link",
            save: "Save",
            cancel: "Cancel",
            productName: "Product Name",
            providerName: "Provider",
            salesVolume: "Sales Volume",
            generateIdeas: "Generate Ideas",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const handleEditClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        setIsMenuOpen(false);
        setIsEditing(true);
    };

    const handleDeleteClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (onDelete) onDelete();
    };

    const handleCancel = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (isNew && onCancel) {
            onCancel();
        } else {
            setIsEditing(false);
            setEditedLink(link);
        }
    };

    const handleSave = (e: React.MouseEvent) => {
        e.stopPropagation();
        // For new links, generate a proper ID instead of using 'new'
        const linkToSave = isNew && editedLink.id === 'new' 
            ? { ...editedLink, id: crypto.randomUUID() } 
            : editedLink;
        onSave(linkToSave);
        setIsEditing(false);
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value, type } = e.target;
        setEditedLink(prev => {
            const newLink = { ...prev, [name]: type === 'number' ? parseFloat(value) || 0 : value };
            if (name === 'price' || name === 'commissionRate') {
                const price = name === 'price' ? parseFloat(value) || 0 : newLink.price;
                const rate = name === 'commissionRate' ? parseFloat(value) || 0 : newLink.commissionRate;
                newLink.commissionValue = Math.round(price * (rate / 100));
            }
            return newLink;
        });
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                setIsMenuOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const content = (
        <div className="flex-grow">
            <div className="mt-4 grid grid-cols-2 gap-4">
                {isEditing ? (
                    <>
                        <InputField label={texts.price} name="price" type="number" value={editedLink.price} onChange={handleChange} />
                        <InputField label={texts.commissionValue} name="commissionValue" type="number" value={editedLink.commissionValue} onChange={handleChange} />
                        <InputField label={texts.commissionRate} name="commissionRate" type="number" value={editedLink.commissionRate} onChange={handleChange} />
                        <InputField label={texts.productId} name="productId" value={editedLink.productId} onChange={handleChange} />
                    </>
                ) : (
                    <>
                        <InfoField label={texts.price} value={formatCurrency(link.price)} />
                        <InfoField label={texts.commissionValue} value={formatCurrency(link.commissionValue)} className="text-green-600" />
                        <InfoField label={texts.commissionRate} value={`${link.commissionRate}%`} />
                        <InfoField label={texts.productId} value={link.productId || 'N/A'} isTruncated />
                    </>
                )}
            </div>
             {isEditing && (
                <div className="space-y-3 mt-4">
                     <InputField label={texts.productLink} name="productLink" type="url" value={editedLink.productLink} onChange={handleChange} required />
                     <InputField label={texts.promoLink} name="promotionLink" type="url" value={editedLink.promotionLink} onChange={handleChange} />
                </div>
            )}
        </div>
    );

    return (
        <div
            className={`bg-white rounded-xl border border-gray-200 p-5 flex flex-col transition-all duration-200 shadow-sm`}
        >
            <div className="flex justify-between items-start">
                <div className="flex-1 min-w-0">
                    {isEditing ? (
                         <div className="space-y-2">
                             <InputField label={texts.productName} name="productName" value={editedLink.productName} onChange={handleChange} required />
                             <InputField label={texts.providerName} name="providerName" value={editedLink.providerName} onChange={handleChange} required />
                         </div>
                    ) : (
                        <>
                            <p className="text-xs text-gray-400">{link.providerName}</p>
                            <div className="flex items-center gap-3 mb-2">
                                {link.product_avatar ? (
                                    <img src={link.product_avatar} alt={link.productName} className="h-15 w-15 rounded-md object-cover border border-gray-200" />
                                ) : (
                                    <div className="h-10 w-10 rounded-md bg-gray-100 flex items-center justify-center text-gray-400">
                                        <TagIcon className="h-6 w-6" />
                                    </div>
                                )}
                            </div>
                            <div>
                                
                                <h3 className={`text-lg font-bold text-gray-900 leading-tight`}>{link.productName}</h3>
                                {link.product_rating !== undefined && link.product_rating !== null && (
                                    <p className="text-sm text-gray-600 flex items-center gap-1">
                                        <span className="text-yellow-500">★</span> {link.product_rating.toFixed(1)}
                                    </p>
                                )}
                            </div>
                        </>
                    )}
                </div>
                <div className="relative ml-2 no-expand" ref={menuRef}>
                    {!isNew && (
                         <button onClick={(e) => { e.stopPropagation(); setIsMenuOpen(!isMenuOpen); }} className="text-gray-400 hover:text-gray-700 p-1 rounded-full">
                            <DotsVerticalIcon className="h-5 w-5" />
                        </button>
                    )}
                    {isMenuOpen && (
                        <div className="absolute right-0 mt-2 w-40 bg-white rounded-md shadow-lg border z-10">
                            <button onClick={handleEditClick} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"><PencilIcon className="h-4 w-4"/> {texts.edit}</button>
                            <button onClick={handleDeleteClick} className="w-full text-left flex items-center gap-2 px-4 py-2 text-sm text-red-600 hover:bg-red-50"><TrashIcon className="h-4 w-4"/> {texts.delete}</button>
                        </div>
                    )}
                </div>
            </div>
            
            {content}

            <div className="mt-4 pt-4 border-t border-gray-100 flex items-center justify-end gap-3">
                 {isEditing ? (
                    <>
                        <Button variant="tertiary" onClick={handleCancel}>{texts.cancel}</Button>
                        <Button onClick={handleSave}>{texts.save}</Button>
                    </>
                ) : (
                    <>
                        {onGenerateIdeas && (
                            <Button 
                                variant="secondary" 
                                size="sm" 
                                onClick={(e) => { 
                                    e.stopPropagation();
                                    onGenerateIdeas(link);
                                }}
                                className="text-xs py-1 px-2"
                            >
                                <SparklesIcon className="h-4 w-4 mr-1" />
                                {texts.generateIdeas}
                            </Button>
                        )}
                        <a href={link.productLink} onClick={e => e.stopPropagation()} target="_blank" rel="noopener noreferrer" title={texts.productLink} className="text-gray-500 hover:text-brand-green transition-colors"><LinkIcon className="h-5 w-5"/></a>
                        {link.promotionLink && <a href={link.promotionLink} onClick={e => e.stopPropagation()} target="_blank" rel="noopener noreferrer" title={texts.promoLink} className="text-yellow-500 hover:text-yellow-700 transition-colors"><TagIcon className="h-5 w-5"/></a>}
                    </>
                )}
            </div>
        </div>
    );
};

const InfoField: React.FC<{ label: string; value: string; className?: string; isTruncated?: boolean }> = ({ label, value, className, isTruncated }) => (
    <div>
        <p className="text-xs text-gray-500">{label}</p>
        <p className={`text-md font-semibold text-gray-800 ${isTruncated ? 'truncate' : ''} ${className}`} title={value}>{value}</p>
    </div>
);

const InputField: React.FC<{ label: string; name: string, value: any, onChange: (e: React.ChangeEvent<HTMLInputElement>) => void, type?: string, required?: boolean }> = ({label, ...props}) => (
    <div>
        <label className="text-xs text-gray-500">{label}</label>
        <Input {...props} className="mt-1 p-1 text-sm"/>
    </div>
);

export default ProductCard;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductCard.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductSelector.tsx ---\n
import React, { useState, useMemo } from 'react';
import { AffiliateLink } from '../types';
import { Input, Select, Button } from './ui';
import { SearchIcon, LinkIcon, CheckCircleIcon } from './icons';

interface ProductSelectorProps {
    affiliateLinks: AffiliateLink[];
    onSelectProduct: (productId: string | null) => void;
    selectedProductId: string | null | undefined;
    language: string;
    autoSelectedProductId?: string;
}

const ProductSelector: React.FC<ProductSelectorProps> = ({ affiliateLinks, onSelectProduct, selectedProductId, language, autoSelectedProductId }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('productName-asc');

    const T = {
        'Việt Nam': {
            title: "Chọn Sản phẩm từ Kho Affiliate",
            subtitle: "Chọn một sản phẩm để quảng bá trong kế hoạch truyền thông này. Sản phẩm này sẽ được tự động liên kết với các bài đăng.",
            searchPlaceholder: "Tìm kiếm theo tên sản phẩm, ID, hoặc nhà cung cấp...",
            sortBy: "Sắp xếp theo",
            noProducts: "Không có sản phẩm nào trong Kho Affiliate.",
            noResults: "Không tìm thấy sản phẩm nào phù hợp với tìm kiếm của bạn.",
            selectProduct: "Chọn sản phẩm này",
            selected: "Đã chọn",
            clearSelection: "Xóa lựa chọn",
        },
        'English': {
            title: "Select Product from Affiliate Vault",
            subtitle: "Choose a product to promote in this media plan. This product will be automatically linked to the posts.",
            searchPlaceholder: "Search by product name, ID, or provider...",
            sortBy: "Sort by",
            noProducts: "No products available in Affiliate Vault.",
            noResults: "No products found matching your search.",
            selectProduct: "Select this product",
            selected: "Selected",
            clearSelection: "Clear Selection",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const processedLinks = useMemo(() => {
        const filtered = (affiliateLinks || []).filter(link =>
            link.productName.toLowerCase().includes(searchQuery.toLowerCase()) ||
            link.productId.toLowerCase().includes(searchQuery.toLowerCase()) ||
            (link.providerName && link.providerName.toLowerCase().includes(searchQuery.toLowerCase()))
        );

        const [sortKey, sortDir] = sortBy.split('-');

        return filtered.sort((a, b) => {
            let valA: any, valB: any;
            switch(sortKey) {
                case 'price':
                case 'commissionValue':
                    valA = a[sortKey as keyof AffiliateLink] as number;
                    valB = b[sortKey as keyof AffiliateLink] as number;
                    break;
                case 'productName':
                default:
                    valA = a.productName.toLowerCase();
                    valB = b.productName.toLowerCase();
                    break;
            }
            if (valA < valB) return sortDir === 'asc' ? -1 : 1;
            if (valA > valB) return sortDir === 'asc' ? 1 : -1;
            return 0;
        });
    }, [affiliateLinks, searchQuery, sortBy]);

    return (
        <div className="mt-6">
            {autoSelectedProductId && selectedProductId === autoSelectedProductId && (
                <div className="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                    <h3 className="text-lg font-bold text-gray-900 mb-2">
                        {language === 'Việt Nam' ? 'Sản phẩm đã được liên kết tự động' : 'Product Automatically Linked'}
                    </h3>
                    <p className="text-gray-600 mb-4">
                        {language === 'Việt Nam' 
                            ? 'Kế hoạch truyền thông này được tạo từ một ý tưởng sản phẩm, do đó sản phẩm đã được chọn tự động.' 
                            : 'This media plan is created from a product idea, so the product has been automatically selected.'}
                    </p>
                    {affiliateLinks.find(link => link.id === autoSelectedProductId) && (
                        <div className="bg-white p-4 rounded border">
                            <div className="flex items-center">
                                {affiliateLinks.find(link => link.id === autoSelectedProductId)?.product_avatar && (
                                    <img 
                                        src={affiliateLinks.find(link => link.id === autoSelectedProductId)?.product_avatar} 
                                        alt={affiliateLinks.find(link => link.id === autoSelectedProductId)?.productName} 
                                        className="w-16 h-16 rounded-md object-cover mr-4" 
                                    />
                                )}
                                <div>
                                    <h4 className="font-bold text-gray-900">
                                        {affiliateLinks.find(link => link.id === autoSelectedProductId)?.productName}
                                    </h4>
                                    <p className="text-sm text-gray-600">
                                        {language === 'Việt Nam' ? 'Nhà cung cấp' : 'Provider'}: {affiliateLinks.find(link => link.id === autoSelectedProductId)?.providerName}
                                    </p>
                                    <p className="text-sm text-gray-600">
                                        {language === 'Việt Nam' ? 'Giá' : 'Price'}: {new Intl.NumberFormat(language === 'Việt Nam' ? 'vi-VN' : 'en-US', { 
                                            style: 'currency', 
                                            currency: language === 'Việt Nam' ? 'VND' : 'USD' 
                                        }).format(affiliateLinks.find(link => link.id === autoSelectedProductId)?.price || 0)}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            )}
            <h3 className="text-2xl font-bold font-sans text-center text-gray-900">{texts.title}</h3>
            <p className="text-gray-500 font-serif text-center mt-1">{texts.subtitle}</p>

            <div className="mt-8 flex flex-col md:flex-row gap-4">
                <div className="relative flex-grow">
                    <Input
                        placeholder={texts.searchPlaceholder}
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        className="pl-10"
                    />
                    <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
                </div>
                <div className="flex items-center gap-2 flex-shrink-0">
                    <label htmlFor="sort-by" className="text-sm font-medium text-gray-700 whitespace-nowrap">{texts.sortBy}:</label>
                    <Select id="sort-by" value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                        <option value="productName-asc">{language === 'Việt Nam' ? 'Tên sản phẩm (A-Z)' : 'Product Name (A-Z)'}</option>
                        <option value="productName-desc">{language === 'Việt Nam' ? 'Tên sản phẩm (Z-A)' : 'Product Name (Z-A)'}</option>
                        <option value="price-desc">{language === 'Việt Nam' ? 'Giá (Cao-Thấp)' : 'Price (High-Low)'}</option>
                        <option value="price-asc">{language === 'Việt Nam' ? 'Giá (Thấp-Cao)' : 'Price (Low-High)'}</option>
                        <option value="commissionValue-desc">{language === 'Việt Nam' ? 'Hoa hồng (Cao-Thấp)' : 'Commission (High-Low)'}</option>
                        <option value="commissionValue-asc">{language === 'Việt Nam' ? 'Hoa hồng (Thấp-Cao)' : 'Commission (Low-High)'}</option>
                    </Select>
                </div>
            </div>

            {affiliateLinks.length === 0 ? (
                <div className="text-center py-20">
                    <LinkIcon className="mx-auto h-16 w-16 text-gray-400" />
                    <h3 className="mt-2 text-2xl font-bold font-sans text-gray-900">{texts.noProducts}</h3>
                </div>
            ) : processedLinks.length === 0 ? (
                <div className="text-center py-20">
                    <SearchIcon className="mx-auto h-16 w-16 text-gray-400" />
                    <h3 className="mt-2 text-2xl font-bold font-sans text-gray-900">{texts.noResults}</h3>
                </div>
            ) : (
                <div className="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-96 overflow-y-auto pr-2">
                    {processedLinks.map(link => (
                        <div
                            key={link.id}
                            className={`p-4 border rounded-lg shadow-sm flex flex-col ${selectedProductId === link.id ? 'border-brand-green bg-green-50' : 'bg-white hover:border-gray-300'}`}
                        >
                            <div className="flex items-center mb-2">
                                {link.product_avatar && (
                                    <img src={link.product_avatar} alt={link.productName} className="w-12 h-12 rounded-md object-cover mr-3" />
                                )}
                                <h4 className="font-bold text-gray-900 text-lg flex-grow">{link.productName}</h4>
                                {selectedProductId === link.id && (
                                    <CheckCircleIcon className="h-6 w-6 text-brand-green ml-2" />
                                )}
                            </div>
                            <p className="text-sm text-gray-600 mb-1"><strong>ID:</strong> {link.productId}</p>
                            <p className="text-sm text-gray-600 mb-1"><strong>{language === 'Việt Nam' ? 'Nhà cung cấp' : 'Provider'}:</strong> {link.providerName}</p>
                            <p className="text-sm text-gray-600 mb-2"><strong>{language === 'Việt Nam' ? 'Giá' : 'Price'}:</strong> {new Intl.NumberFormat(language === 'Việt Nam' ? 'vi-VN' : 'en-US', { style: 'currency', currency: language === 'Việt Nam' ? 'VND' : 'USD' }).format(link.price)}</p>
                            <div className="mt-auto pt-2 border-t border-gray-100">
                                {selectedProductId === link.id ? (
                                    <Button variant="secondary" onClick={() => onSelectProduct(null)} className="w-full">
                                        {texts.clearSelection}
                                    </Button>
                                ) : (
                                    <Button onClick={() => onSelectProduct(link.id)} className="w-full">
                                        {texts.selectProduct}
                                    </Button>
                                )}
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

export default ProductSelector;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ProductSelector.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ScheduleModal.tsx ---\n
import React, { useState, useEffect } from 'react';
import type { MediaPlanPost, SchedulingPost } from '../types';
import { Button } from './ui';

interface ScheduleModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSchedule: (postInfo: SchedulingPost, scheduleDate: string) => void;
  isScheduling: boolean;
  schedulingPost: SchedulingPost | null;
  language: string;
}

const ScheduleModal: React.FC<ScheduleModalProps> = ({ isOpen, onClose, onSchedule, isScheduling, schedulingPost, language }) => {
  const [scheduleDate, setScheduleDate] = useState('');
  const [scheduleTime, setScheduleTime] = useState('');

  useEffect(() => {
    if (schedulingPost?.post.scheduledAt) {
      const d = new Date(schedulingPost.post.scheduledAt);
      setScheduleDate(d.toISOString().split('T')[0]);
      setScheduleTime(d.toTimeString().substring(0, 5));
    } else {
      const now = new Date();
      now.setHours(now.getHours() + 1);
      now.setMinutes(0);
      setScheduleDate(now.toISOString().split('T')[0]);
      setScheduleTime(now.toTimeString().substring(0, 5));
    }
  }, [schedulingPost]);

  if (!isOpen || !schedulingPost) return null;

  const handleSchedule = () => {
    const combinedDateTime = new Date(`${scheduleDate}T${scheduleTime}:00`);
    onSchedule(schedulingPost, combinedDateTime.toISOString());
  };
  
  const T = {
    'Việt Nam': {
        title: 'Lên lịch bài đăng',
        schedule_for: 'Lên lịch cho:',
        date: 'Ngày',
        time: 'Thời gian',
        cancel: 'Hủy bỏ',
        schedule: 'Lên lịch',
        scheduling: 'Đang lên lịch...',
    },
    'English': {
        title: 'Schedule Post',
        schedule_for: 'Schedule for:',
        date: 'Date',
        time: 'Time',
        cancel: 'Cancel',
        schedule: 'Schedule Post',
        scheduling: 'Scheduling...',
    }
  };
  const texts = (T as any)[language] || T['English'];

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-8 border border-gray-200 m-4" onClick={(e) => e.stopPropagation()}>
        <h2 className="text-2xl font-bold text-gray-900">{texts.title}</h2>
        <p className="text-gray-500 font-serif mt-2">{texts.schedule_for} "{schedulingPost.post.title}"</p>
        
        <div className="mt-6 space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label htmlFor="schedule-date" className="block text-sm font-medium text-gray-700">{texts.date}</label>
              <input
                id="schedule-date"
                type="date"
                value={scheduleDate}
                onChange={(e) => setScheduleDate(e.target.value)}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-brand-green focus:border-brand-green sm:text-sm"
              />
            </div>
            <div>
              <label htmlFor="schedule-time" className="block text-sm font-medium text-gray-700">{texts.time}</label>
              <input
                id="schedule-time"
                type="time"
                value={scheduleTime}
                onChange={(e) => setScheduleTime(e.target.value)}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-brand-green focus:border-brand-green sm:text-sm"
              />
            </div>
          </div>
        </div>

        <div className="flex justify-end gap-4 pt-6 mt-6 border-t border-gray-200">
          <Button type="button" onClick={onClose} variant="tertiary" disabled={isScheduling}>
            {texts.cancel}
          </Button>
          <Button onClick={handleSchedule} disabled={isScheduling}>
            {isScheduling ? (
              <>
                <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin mr-2"></div>
                {texts.scheduling}
              </>
            ) : (
              texts.schedule
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default ScheduleModal;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ScheduleModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\SettingsModal.tsx ---\nimport React, { useState, useEffect } from 'react';
import type { Settings } from '../types';
import { Button, Input, TextArea, Select } from './ui';
import { SettingsIcon, TrashIcon, PlusIcon } from './icons';
import { fetchAdminDefaultsFromAirtable, fetchSettingsFromAirtable, saveSettingsToAirtable, loadAIServices } from '../services/databaseService';
import { configService } from '../services/configService';


// Helper function to get models by capability from AI services
const getModelsByCapability = (aiServices: any[], capability: 'text' | 'image') => {
  return aiServices
    .flatMap((service: any) => service.models)
    .filter((model: any) => model.capabilities.includes(capability))
    .map((model: any) => ({
      value: model.name,
      label: `${model.provider}: ${model.name}`
    }));
};

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
  brandId: string;
}

type ActiveTab = 'general' | 'generation' | 'affiliate';

const TabButton: React.FC<{
    tabId: ActiveTab;
    text: string;
    activeTab: ActiveTab;
    onClick: (tabId: ActiveTab) => void;
}> = ({tabId, text, activeTab, onClick}) => (
    <button
        onClick={() => onClick(tabId)}
        className={`px-4 py-2 text-md font-semibold rounded-t-lg transition-colors focus:outline-none ${
            activeTab === tabId
            ? 'border-b-2 border-brand-green text-gray-900'
            : 'text-gray-500 hover:text-gray-900'
        }`}
    >
        {text}
    </button>
);

const styleTemplates = [
    {
        name: 'Photorealistic',
        suffix: ', photorealistic, 8k, high quality, cinematic lighting, sharp focus',
        previewUrl: 'https://images.pexels.com/photos/1647976/pexels-photo-1647976.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1'
    },
    {
        name: 'Minimalist',
        suffix: ', minimalist, clean background, simple, elegant, studio lighting, flat design style',
        previewUrl: 'https://images.pexels.com/photos/262391/pexels-photo-262391.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1'
    },
    {
        name: 'Vintage',
        suffix: ', vintage style, retro, 1970s film photography, faded colors, film grain, nostalgic',
        previewUrl: 'https://images.pexels.com/photos/725255/pexels-photo-725255.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1'
    },
    {
        name: 'Vibrant & Abstract',
        suffix: ', vibrant abstract illustration, colorful, geometric shapes, energetic, modern art',
        previewUrl: 'https://images.pexels.com/photos/1616403/pexels-photo-1616403.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1'
    }
];


// Define texts before using it
const T = {
  'Việt Nam': {
    title: 'Cài đặt',
    subtitle: 'Tùy chỉnh hành vi của ứng dụng.',
    tab_general: 'Chung',
    tab_generation: 'Tạo nội dung',
    tab_affiliate: 'Affiliate',
    save: 'Lưu thay đổi',
    saving: 'Đang lưu...',
    cancel: 'Hủy',
    language: 'Ngôn ngữ mặc định',
    language_desc: 'Ngôn ngữ cho tất cả nội dung do AI tạo ra.',
    total_posts_per_month: 'Tổng số bài đăng mỗi kế hoạch',
    total_posts_per_month_desc: 'Tổng số bài đăng AI sẽ tạo cho một kế hoạch truyền thông mới.',
    media_prompt_suffix: 'Hậu tố Prompt ảnh',
    media_prompt_suffix_desc: 'Văn bản này sẽ được thêm vào cuối mỗi prompt tạo ảnh để đảm bảo phong cách nhất quán.',
    visual_style_templates: 'Mẫu Phong cách Trực quan',
    affiliate_kit_rules: 'Quy tắc Affiliate Content-Kit',
    affiliate_kit_rules_desc: 'Các quy tắc này (dưới dạng system instruction) sẽ được cung cấp cho AI khi tạo kế hoạch truyền thông để đảm bảo tuân thủ.',
    textGenerationModel: 'Mô hình Tạo văn bản',
    textGenerationModel_desc: 'Mô hình AI được sử dụng cho tất cả các tính năng tạo văn bản.',
    imageGenerationModel: 'Mô hình Tạo ảnh',
    imageGenerationModel_desc: 'Mô hình AI được sử dụng cho tất cả các tính năng tạo ảnh.',
  },
  'English': {
    title: 'Settings',
    subtitle: 'Customize the behavior of the application.',
    tab_general: 'General',
    tab_generation: 'Generation',
    tab_affiliate: 'Affiliate',
    save: 'Save Changes',
    saving: 'Saving...',
    cancel: 'Cancel',
    language: 'Default Language',
    language_desc: 'The language for all AI-generated content.',
    total_posts_per_month: 'Total Posts per Plan',
    total_posts_per_month_desc: 'The total number of posts the AI will generate for a new media plan.',
    media_prompt_suffix: 'Image Prompt Suffix',
    media_prompt_suffix_desc: 'This text will be added to the end of every image generation prompt to ensure consistent styling.',
    visual_style_templates: 'Visual Style Templates',
    affiliate_kit_rules: 'Affiliate Content-Kit Rules',
    affiliate_kit_rules_desc: 'These rules (as a system instruction) are fed to the AI when generating media plans to ensure compliance.',
    textGenerationModel: 'Text Generation Model',
    textGenerationModel_desc: 'The AI model to use for all text generation features.',
    imageGenerationModel: 'Image Generation Model',
    imageGenerationModel_desc: 'The AI model to use for all image generation features.',
  }
};

const SettingsModal: React.FC<SettingsModalProps> = ({ isOpen, onClose, brandId }) => {
  const [settings, setSettings] = useState<Settings | null>(null); // Initialize with null
  const [activeTab, setActiveTab] = useState<ActiveTab>('general');
  const [aiServices, setAiServices] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState<boolean>(false); // New state for saving

  // Load AI services from Airtable and brand-specific settings
  useEffect(() => {
    const loadAllData = async () => {
      if (!isOpen) {
        setSettings(null); // Reset settings when modal is closed
        return;
      }
      
      if (!brandId) {
        setError('No brand selected');
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);
      
      try {
        // Fetch brand-specific settings
        const fetchedSettings = await fetchSettingsFromAirtable(brandId);

        if (fetchedSettings) {
          setSettings({
            ...fetchedSettings,
          });
        } else {
          // If no settings found for the brand, initialize with admin defaults
          console.warn(`No settings found for brand ${brandId}. Initializing with admin defaults.`);
          const adminDefaults = await fetchAdminDefaultsFromAirtable();
          setSettings({
            ...adminDefaults,
          });
        }

        // Load AI services (for dropdowns)
        const loadedServices = await loadAIServices();
        setAiServices(loadedServices);

      } catch (err) {
        console.error('Failed to load data for settings modal:', err);
        setError('Failed to load settings: ' + (err instanceof Error ? err.message : 'Unknown error'));
        setSettings(null); // Set to null on error
      } finally {
        setLoading(false);
      }
    };

    if (isOpen) {
      loadAllData();
    }
  }, [isOpen, brandId]); // Depend on isOpen and brandId

  const texts = (T as any)[settings?.language || 'English'] || T['English'];

  if (!isOpen) {
    console.log('SettingsModal: Not open, returning null');
    return null;
  }
  
  // Check if settings are properly loaded
  if (!brandId) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
        <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-8 border border-gray-200 m-4 transform transition-all">
          <div className="flex justify-between items-start">
            <div>
              <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                <SettingsIcon className="h-8 w-8 text-brand-green" />
                {texts.title}
              </h2>
              <p className="text-red-500 mt-1 font-serif">Error: No brand selected</p>
            </div>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
          </div>
        </div>
      </div>
    );
  }
  
  if (!settings || loading) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
        <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-8 border border-gray-200 m-4 transform transition-all">
          <div className="flex justify-between items-start">
            <div>
              <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                <SettingsIcon className="h-8 w-8 text-brand-green" />
                {texts.title}
              </h2>
              <p className="text-gray-500 mt-1 font-serif">Loading settings...</p>
            </div>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
          </div>
          <div className="mt-6 flex justify-center">
            <div className="w-8 h-8 border-4 border-brand-green border-t-transparent rounded-full animate-spin"></div>
          </div>
        </div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
        <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-8 border border-gray-200 m-4 transform transition-all">
          <div className="flex justify-between items-start">
            <div>
              <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                <SettingsIcon className="h-8 w-8 text-brand-green" />
                {texts.title}
              </h2>
              <p className="text-red-500 mt-1 font-serif">Error: {error}</p>
            </div>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
          </div>
        </div>
      </div>
    );
  }

  const textGenerationModels = getModelsByCapability(aiServices, 'text');
  const imageGenerationModels = getModelsByCapability(aiServices, 'image');

  const handleSave = async () => {
    if (!settings || !brandId) return;

    setIsSaving(true);
    setError(null);
    try {
      // Save general settings
      await saveSettingsToAirtable(settings, brandId);

      // // Save AI model configuration
      // await saveAiModelConfigToAirtable({
      //   textModelFallbackOrder: settings.textModelFallbackOrder,
      //   visionModels: settings.visionModels,
      // }, brandId);

      onClose(); // Close modal on successful save
    } catch (err) {
      console.error('Failed to save settings:', err);
      setError('Failed to save settings: ' + (err instanceof Error ? err.message : 'Unknown error'));
    } finally {
      setIsSaving(false);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;
    setSettings(prev => ({
        ...prev,
        [name]: type === 'number' ? parseInt(value, 10) || 0 : value
    }));
  };

  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-30 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl p-8 border border-gray-200 m-4 transform transition-all max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-start">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
              <SettingsIcon className="h-8 w-8 text-brand-green" />
              {texts.title}
            </h2>
            <p className="text-gray-500 mt-1 font-serif">{texts.subtitle}</p>
          </div>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
        </div>
        
        <div className="border-b border-gray-200 mt-6">
            <div className="flex space-x-4">
                <TabButton tabId="general" text={texts.tab_general} activeTab={activeTab} onClick={setActiveTab} />
                <TabButton tabId="generation" text={texts.tab_generation} activeTab={activeTab} onClick={setActiveTab} />
                <TabButton tabId="affiliate" text={texts.tab_affiliate} activeTab={activeTab} onClick={setActiveTab} />
            </div>
        </div>

        <div className="mt-6 space-y-6 flex-grow overflow-y-auto pr-2">
            {activeTab === 'general' && (
                 <div className="space-y-4">
                    <label htmlFor="language" className="block text-lg font-medium text-gray-800">{texts.language}</label>
                     <select
                        id="language"
                        name="language"
                        value={settings.language}
                        onChange={handleInputChange}
                        className="w-full bg-white border border-gray-300 rounded-md py-2 px-3 text-gray-900 focus:outline-none focus:ring-2 focus:ring-brand-green focus:border-transparent transition-colors"
                    >
                        <option value="Việt Nam">Việt Nam</option>
                        <option value="English">English</option>
                    </select>
                    <p className="text-sm text-gray-500 font-serif">{texts.language_desc}</p>
                </div>
            )}
            {activeTab === 'generation' && (
                <div className="space-y-6">
                    <div>
                        <label htmlFor="textGenerationModel" className="block text-lg font-medium text-gray-800">{texts.textGenerationModel}</label>
                        <Select
                            id="textGenerationModel"
                            name="textGenerationModel"
                            value={settings.textGenerationModel}
                            onChange={handleInputChange}
                            className="mt-1"
                        >
                            {/* Show loading state */}
                            {loading && <option>Loading AI models...</option>}
                            
                            {/* Show error message if failed to load */}
                            {error && <option>Error loading models</option>}
                            
                            {/* Dynamically load text generation models from AI services */}
                            {textGenerationModels.map(model => (
                                <option key={model.value} value={model.value}>{model.label}</option>
                            ))}
                            
                            {/* Fallback option if the current value is not in the list */}
                            {!loading && !error && !textGenerationModels.some(model => model.value === settings.textGenerationModel) && settings.textGenerationModel && (
                                <option value={settings.textGenerationModel}>{settings.textGenerationModel} (Custom)</option>
                            )}
                            
                            {/* Default option if no models and no current value */}
                            {!loading && !error && textGenerationModels.length === 0 && !settings.textGenerationModel && (
                                <option value="">No models available</option>
                            )}
                        </Select>
                        <p className="text-sm text-gray-500 mt-1 font-serif">{texts.textGenerationModel_desc}</p>
                        {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
                    </div>
                     <div>
                        <label htmlFor="imageGenerationModel" className="block text-lg font-medium text-gray-800">{texts.imageGenerationModel}</label>
                        <Select
                            id="imageGenerationModel"
                            name="imageGenerationModel"
                            value={settings.imageGenerationModel}
                            onChange={handleInputChange}
                            className="mt-1"
                        >
                            {/* Show loading state */}
                            {loading && <option>Loading AI models...</option>}
                            
                            {/* Show error message if failed to load */}
                            {error && <option>Error loading models</option>}
                            
                            {/* Dynamically load image generation models from AI services */}
                            {imageGenerationModels.map(model => (
                                <option key={model.value} value={model.value}>{model.label}</option>
                            ))}
                            
                            {/* Fallback option if the current value is not in the list */}
                            {!loading && !error && !imageGenerationModels.some(model => model.value === settings.imageGenerationModel) && settings.imageGenerationModel && (
                                <option value={settings.imageGenerationModel}>{settings.imageGenerationModel} (Custom)</option>
                            )}
                            
                            {/* Default option if no models and no current value */}
                            {!loading && !error && imageGenerationModels.length === 0 && !settings.imageGenerationModel && (
                                <option value="">No models available</option>
                            )}
                        </Select>
                        <p className="text-sm text-gray-500 mt-1 font-serif">{texts.imageGenerationModel_desc}</p>
                        {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
                    </div>
                    <div>
                        <label htmlFor="totalPostsPerMonth" className="block text-lg font-medium text-gray-800">{texts.total_posts_per_month}</label>
                        <Input
                            id="totalPostsPerMonth"
                            name="totalPostsPerMonth"
                            type="number"
                            value={settings.totalPostsPerMonth}
                            onChange={handleInputChange}
                            min="4"
                            max="40"
                            className="mt-1"
                        />
                        <p className="text-sm text-gray-500 mt-1 font-serif">{texts.total_posts_per_month_desc}</p>
                    </div>
                     <div>
                        <label className="block text-lg font-medium text-gray-800">{texts.visual_style_templates}</label>
                         <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-2">
                            {styleTemplates.map((template) => (
                                <button
                                    key={template.name}
                                    onClick={() => setSettings(prev => ({...prev, mediaPromptSuffix: template.suffix}))}
                                    className={`relative rounded-lg overflow-hidden border-4 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-green transition-all ${
                                        settings.mediaPromptSuffix === template.suffix ? 'border-brand-green' : 'border-transparent hover:border-gray-300'
                                    }`}
                                >
                                    <img src={template.previewUrl} alt={template.name} className="h-24 w-full object-cover"/>
                                    <div className="absolute inset-0 bg-gradient-to-t from-black/70 to-transparent"></div>
                                    <p className="absolute bottom-2 left-2 text-white font-bold text-sm">{template.name}</p>
                                </button>
                            ))}
                         </div>
                    </div>
                     <div>
                        <label htmlFor="mediaPromptSuffix" className="block text-lg font-medium text-gray-800">{texts.media_prompt_suffix}</label>
                        <TextArea
                            id="mediaPromptSuffix"
                            name="mediaPromptSuffix"
                            value={settings.mediaPromptSuffix}
                            onChange={handleInputChange}
                            rows={3}
                            className="mt-1 font-mono text-sm"
                        />
                        <p className="text-sm text-gray-500 mt-1 font-serif">{texts.media_prompt_suffix_desc}</p>
                    </div>

                    {/* Text Model Fallback Order */}
                    <div className="mb-6">
                        <label className="block text-lg font-medium text-gray-800">Text Model Fallback Order</label>
                        <div className="space-y-2">
                            {settings!.textModelFallbackOrder.map((model, index) => (
                                <div key={index} className="flex items-center gap-2">
                                    <Input
                                        value={model}
                                        onChange={(e) => {
                                            const newOrder = [...settings!.textModelFallbackOrder];
                                            newOrder[index] = e.target.value;
                                            setSettings({ ...settings!, textModelFallbackOrder: newOrder });
                                        }}
                                        className="flex-grow"
                                    />
                                    <Button
                                        variant="tertiary"
                                        onClick={() => {
                                            const newOrder = settings!.textModelFallbackOrder.filter((_, i) => i !== index);
                                            setSettings({ ...settings!, textModelFallbackOrder: newOrder });
                                        }}
                                    >
                                        <TrashIcon className="h-5 w-5 text-red-600" />
                                    </Button>
                                </div>
                            ))}
                        </div>
                        <Button
                            className="mt-3 flex items-center gap-2"
                            onClick={() => setSettings({ ...settings!, textModelFallbackOrder: [...settings!.textModelFallbackOrder, ''] })}
                        >
                            <PlusIcon className="h-5 w-5" />
                            Add Text Model
                        </Button>
                    </div>

                    {/* Vision Models */}
                    <div>
                        <label className="block text-lg font-medium text-gray-800">Vision Models</label>
                        <div className="space-y-2">
                            {settings!.visionModels.map((model, index) => (
                                <div key={index} className="flex items-center gap-2">
                                    <Input
                                        value={model}
                                        onChange={(e) => {
                                            const newModels = [...settings!.visionModels];
                                            newModels[index] = e.target.value;
                                            setSettings({ ...settings!, visionModels: newModels });
                                        }}
                                        className="flex-grow"
                                    />
                                    <Button
                                        variant="tertiary"
                                        onClick={() => {
                                            const newModels = settings!.visionModels.filter((_, i) => i !== index);
                                            setSettings({ ...settings!, visionModels: newModels });
                                        }}
                                    >
                                        <TrashIcon className="h-5 w-5 text-red-600" />
                                    </Button>
                                </div>
                            ))}
                        </div>
                        <Button
                            className="mt-3 flex items-center gap-2"
                            onClick={() => setSettings({ ...settings!, visionModels: [...settings!.visionModels, ''] })}
                        >
                            <PlusIcon className="h-5 w-5" />
                            Add Vision Model
                        </Button>
                    </div>
                </div>
            )}
             {activeTab === 'affiliate' && (
                <div>
                    <label htmlFor="affiliateContentKit" className="block text-lg font-medium text-gray-800">{texts.affiliate_kit_rules}</label>
                    <TextArea
                        id="affiliateContentKit"
                        name="affiliateContentKit"
                        value={settings.affiliateContentKit}
                        onChange={handleInputChange}
                        rows={15}
                        className="mt-1 font-mono text-sm"
                    />
                    <p className="text-sm text-gray-500 mt-1 font-serif">{texts.affiliate_kit_rules_desc}</p>
                </div>
            )}
        </div>

        <div className="flex justify-end gap-4 pt-6 mt-auto border-t border-gray-200">
            <Button type="button" onClick={onClose} variant="tertiary">
                {texts.cancel}
            </Button>
            <Button type="button" onClick={handleSave} disabled={isSaving} className="w-36 flex justify-center">
                 {isSaving ? (
                    <>
                        <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
                        <span className="ml-2">{texts.saving}</span>
                    </>
                ) : (
                    texts.save
                )}
            </Button>
        </div>
      </div>
    </div>
  );
};

export default SettingsModal;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\SettingsModal.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\StrategyDisplay.tsx ---\nimport React, { useState, useMemo, useEffect } from 'react';
import type { Trend, Idea, Settings, Persona, AffiliateLink } from '../types';
import { Button, Input, TextArea, Switch, HoverCopyWrapper } from './ui';
import { PlusIcon, LightBulbIcon, TrashIcon, PencilIcon, SparklesIcon, SearchIcon, TagIcon } from './icons';
import ContentPackageWizardModal from './ContentPackageWizardModal';

// --- SUB-COMPONENTS ---

const TrendForm: React.FC<{ 
    trend: Partial<Trend>;
    onSave: (trendData: Omit<Partial<Trend>, 'keywords' | 'links'> & { keywords?: string; links?: string }) => void;
    onCancel: () => void;
    language: string;
}> = ({ trend, onSave, onCancel, language }) => {
    const [formData, setFormData] = useState({
        topic: trend.topic || '',
        industry: trend.industry || '',
        keywords: (trend.keywords || []).join(', '),
        links: (trend.links || []).map(l => `${l.title}: ${l.url}`).join('\n'),
        notes: trend.notes || '',
    });

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleSave = () => {
        onSave({ ...trend, ...formData });
    };

    const T = {
        'Việt Nam': { topic: 'Chủ đề', industry: 'Ngành', keywords: 'Từ khóa (phân tách bằng dấu phẩy)', links: 'Liên kết (Mỗi dòng một link, định dạng: Tiêu đề: URL)', notes: 'Ghi chú', save: 'Lưu', cancel: 'Hủy' },
        'English': { topic: 'Topic', industry: 'Industry', keywords: 'Keywords (comma-separated)', links: 'Links (One per line, format: Title: URL)', notes: 'Notes', save: 'Save', cancel: 'Cancel' }
    };
    const texts = (T as any)[language] || T['English'];

    return (
        <div className="space-y-4">
            <Input name="topic" placeholder={texts.topic} value={formData.topic} onChange={handleChange} />
            <Input name="industry" placeholder={texts.industry} value={formData.industry} onChange={handleChange} />
            <TextArea name="keywords" placeholder={texts.keywords} value={formData.keywords} onChange={handleChange} rows={2} />
            <TextArea name="links" placeholder={texts.links} value={formData.links} onChange={handleChange} rows={3} />
            <TextArea name="notes" placeholder={texts.notes} value={formData.notes} onChange={handleChange} rows={3} />
            <div className="flex justify-end gap-2">
                <Button variant="tertiary" onClick={onCancel}>{texts.cancel}</Button>
                <Button onClick={handleSave}>{texts.save}</Button>
            </div>
        </div>
    );
};

// --- IDEA LIST COMPONENT ---

const IdeaCard: React.FC<{ 
    idea: Idea;
    onCreatePlanFromIdea: (prompt: string, productId?: string) => void;
    onOpenContentPackageWizard: (idea: Idea) => void;
    language: string;
}> = ({ idea, onCreatePlanFromIdea, onOpenContentPackageWizard, language }) => {
    const T = {
        'Việt Nam': {
            createPlan: "Tạo Kế hoạch",
            createPackage: "Tạo Gói Nội dung",
            target: "Đối tượng:",
            imagePrompt: "Prompt hình ảnh:",
            cta: "CTA:"
        },
        'English': {
            createPlan: "Create Plan",
            createPackage: "Create Content Package",
            target: "Target:",
            imagePrompt: "Image Prompt:",
            cta: "CTA:"
        }
    };
    const texts = (T as any)[language] || T['English'];

    return (
        <div key={idea.id} className="bg-white p-4 rounded-lg border border-gray-200">
            <h4 className="font-bold text-gray-900">{idea.title}</h4>
            <p className="text-sm text-gray-600 mt-1">{idea.description}</p>
            {idea.targetAudience && <p className="text-xs text-gray-400 mt-2">{texts.target} {idea.targetAudience}</p>}
            {idea.mediaPrompt && <HoverCopyWrapper textToCopy={idea.mediaPrompt}><p className="text-xs text-gray-400 mt-1">{texts.imagePrompt} {idea.mediaPrompt}</p></HoverCopyWrapper>}
            {idea.cta && <p className="text-xs text-gray-400 mt-1">{texts.cta} {idea.cta}</p>}
            <div className="flex justify-end gap-2 mt-3">
                <Button variant="secondary" onClick={() => onCreatePlanFromIdea(idea.description, idea.productId)} className="text-xs py-1 px-2">{texts.createPlan}</Button>
                <Button variant="primary" onClick={() => onOpenContentPackageWizard(idea)} className="text-xs py-1 px-2">{texts.createPackage}</Button>
            </div>
        </div>
    );
};

// --- MAIN DISPLAY COMPONENT ---

interface StrategyDisplayProps {
    language: string;
    trends: Trend[];
    ideas: Idea[];
    personas: Persona[];
    affiliateLinks: AffiliateLink[];
    generatedImages: Record<string, string>;
    settings: Settings;
    onSaveTrend: (trend: Trend) => void;
    onDeleteTrend: (trendId: string) => void;
    onGenerateIdeas: (trend: Trend, useSearch: boolean) => void;
    onCreatePlanFromIdea: (prompt: string, productId?: string) => void;
    onGenerateContentPackage: (idea: Idea, personaId: string | null, selectedProductId: string | null, options: { tone: string; style: string; length: string; includeEmojis: boolean; }) => void;
    isGeneratingIdeas: boolean;
    onGenerateFacebookTrends: (industry: string) => void;
    isGeneratingTrendsFromSearch: boolean;
    productTrendToSelect?: string | null;
    onLoadIdeasForTrend?: (trendId: string) => void;
    // Lazy loading props
    isDataLoaded?: boolean;
    onLoadData?: () => void;
    isLoading?: boolean;
}

const StrategyDisplay: React.FC<StrategyDisplayProps> = (props) => {
    const { language, trends, ideas, personas, affiliateLinks, generatedImages, settings, onSaveTrend, onDeleteTrend, onGenerateIdeas, onCreatePlanFromIdea, onGenerateContentPackage, isGeneratingIdeas, onGenerateFacebookTrends, isGeneratingTrendsFromSearch, productTrendToSelect, onLoadIdeasForTrend, isDataLoaded, onLoadData, isLoading } = props;
    
    const [selectedTrend, setSelectedTrend] = useState<Trend | null>(null);
    const [editingTrend, setEditingTrend] = useState<Partial<Trend> | null>(null);
    const [useSearchForIdeas, setUseSearchForIdeas] = useState(false);
    const isGeminiModel = settings.textGenerationModel.startsWith('gemini-');
    const [wizardIdea, setWizardIdea] = useState<Idea | null>(null);
    const [isStrategyHubDataLoaded, setIsStrategyHubDataLoaded] = useState(false);
    const [isLoadingStrategyHubData, setIsLoadingStrategyHubData] = useState(false);

    const [industryForSearch, setIndustryForSearch] = useState('');

    // Load data when component mounts if not already loaded
    useEffect(() => {
        if (!isDataLoaded && onLoadData && !isLoading) {
            setIsLoadingStrategyHubData(true);
            onLoadData().finally(() => {
                setIsLoadingStrategyHubData(false);
                setIsStrategyHubDataLoaded(true);
            });
        } else if (isDataLoaded) {
            setIsStrategyHubDataLoaded(true);
        }
    }, [isDataLoaded, onLoadData, isLoading]);

    useEffect(() => {
        if (isStrategyHubDataLoaded && productTrendToSelect && trends.length > 0) {
            const trendToSelect = trends.find(t => t.id === productTrendToSelect);
            if (trendToSelect) {
                setSelectedTrend(trendToSelect);
                if (onLoadIdeasForTrend) {
                    onLoadIdeasForTrend(trendToSelect.id);
                }
            }
        } else if (isStrategyHubDataLoaded && !selectedTrend && trends.length > 0) {
            setSelectedTrend(trends[0]);
            if (onLoadIdeasForTrend) {
                onLoadIdeasForTrend(trends[0].id);
            }
        }
    }, [trends, productTrendToSelect, selectedTrend, onLoadIdeasForTrend, isStrategyHubDataLoaded]);
    
    const T = {
        'Việt Nam': {
            trends: "Xu hướng",
            addTrend: "Thêm Xu hướng",
            ideasFor: "Ý tưởng cho:",
            noTrendSelected: "Chọn một xu hướng để xem ý tưởng.",
            generateIdeas: "Tạo Ý tưởng",
            generating: "Đang tạo...",
            useSearch: "Dùng Google Search",
            useSearchDesc: "Sử dụng Google Tìm kiếm để có nội dung thực tế, cập nhật.",
            geminiOnly: "Chỉ dành cho Gemini",
            createPlan: "Tạo Kế hoạch",
            createPackage: "Tạo Gói Nội dung",
            confirmDelete: "Bạn có chắc muốn xóa xu hướng này và tất cả các ý tưởng liên quan không?",
            trendSearchTitle: "Tự động hóa Chiến lược Facebook",
            trendSearchSubtitle: "Tự động tìm kiếm và lưu lại các Xu hướng từ Facebook bằng công cụ tìm kiếm của Google.",
            industryPlaceholder: "Nhập ngành của bạn (ví dụ: Thời trang, Công nghệ, Ẩm thực)",
            analyzeTrends: "Tìm kiếm Xu hướng",
            analyzing: "Đang tìm kiếm...",
        },
        'English': {
            trends: "Trends",
            addTrend: "Add Trend",
            ideasFor: "Ideas for:",
            noTrendSelected: "Select a trend to see ideas.",
            generateIdeas: "Generate Ideas",
            generating: "Generating...",
            useSearch: "Use Google Search",
            useSearchDesc: "Uses Google Search for factual, up-to-date content.",
            geminiOnly: "Gemini only",
            createPlan: "Create Plan",
            createPackage: "Generate Content Package",
            confirmDelete: "Are you sure you want to delete this trend and all its associated ideas?",
            trendSearchTitle: "Facebook Strategy Automation",
            trendSearchSubtitle: "Automatically search and save Trends from Facebook using Google Search engine.",
            industryPlaceholder: "Enter your industry (e.g., Fashion, Tech, Food)",
            analyzeTrends: "Search Trends",
            analyzing: "Searching...",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const handleSaveTrend = (trendData: Omit<Partial<Trend>, 'keywords' | 'links'> & { keywords?: string; links?: string }) => {
        const parsedKeywords = (trendData.keywords || '').split(',').map(k => k.trim()).filter(Boolean);
        const parsedLinks = (trendData.links || '').split('\n').map(line => {
            const parts = line.split(':');
            if (parts.length < 2) return null;
            const title = parts[0].trim();
            const url = parts.slice(1).join(':').trim();
            return (title && url) ? { title, url } : null;
        }).filter((l): l is { title: string, url: string } => l !== null);

        const trendToSave: Trend = {
            id: trendData.id || crypto.randomUUID(),
            brandId: '', // App.tsx will fill this
            industry: trendData.industry || '',
            topic: trendData.topic || 'New Trend',
            keywords: parsedKeywords,
            links: parsedLinks,
            notes: trendData.notes || '',
            analysis: trendData.analysis || '',
            createdAt: trendData.createdAt || new Date().toISOString(),
        };
        onSaveTrend(trendToSave);
        setEditingTrend(null);
        setSelectedTrend(trendToSave);
    };

    const handleDeleteTrend = (trendId: string) => {
        if(window.confirm(texts.confirmDelete)) {
            onDeleteTrend(trendId);
            if (selectedTrend?.id === trendId) {
                setSelectedTrend(trends.length > 1 ? trends.find(t => t.id !== trendId) || null : null);
            }
        }
    };

    const ideasForSelectedTrend = useMemo(() => {
        if (!selectedTrend) {
            return [];
        }
        
        const exactMatch = ideas.filter(idea => idea.trendId === selectedTrend.id);
        
        if (exactMatch.length > 0) {
            return exactMatch;
        }
        
        if (selectedTrend.id.startsWith('product-')) {
            const productId = selectedTrend.id.replace('product-', '');
            const partialMatch = ideas.filter(idea => 
                idea.trendId === selectedTrend.id || 
                (idea.productId && idea.productId === productId)
            );
            return partialMatch;
        }
        
        return [];
    }, [ideas, selectedTrend]);

    return (
        <div className="h-full flex flex-col p-6 lg:p-10 bg-gray-50/50">
            {/* Loading indicator */}
            {isLoadingStrategyHubData && (
                <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50">
                    <div className="bg-white p-8 rounded-lg shadow-xl flex flex-col items-center">
                        <div className="w-12 h-12 border-4 border-brand-green border-t-transparent rounded-full animate-spin mb-4"></div>
                        <p className="text-gray-700 font-medium">Loading strategy hub data...</p>
                    </div>
                </div>
            )}
            {/* Loading indicator */}
            {isLoadingStrategyHubData && (
                <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50">
                    <div className="bg-white p-8 rounded-lg shadow-xl flex flex-col items-center">
                        <div className="w-12 h-12 border-4 border-brand-green border-t-transparent rounded-full animate-spin mb-4"></div>
                        <p className="text-gray-700 font-medium">Loading strategy hub data...</p>
                    </div>
                </div>
            )}
            
             <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                 <div>
                    <h2 className="text-3xl font-bold font-sans text-gray-900 flex items-center gap-3"><LightBulbIcon className="h-8 w-8 text-brand-green"/> Content Strategy</h2>
                </div>
            </header>

            <div className="h-full flex flex-col xl:flex-row pt-6">
                <aside className="w-full xl:w-1/3 border-b xl:border-b-0 xl:border-r border-gray-200 bg-white p-6 flex flex-col">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="text-xl font-bold text-gray-800">{texts.trends}</h3>
                        <Button variant="secondary" onClick={() => setEditingTrend({})} className="flex items-center gap-1.5 !px-2 !py-1">
                            <PlusIcon className="h-4 w-4"/> {texts.addTrend}
                        </Button>
                    </div>
                    <div className="mt-4 mb-6">
                        <h3 className="text-lg font-bold text-gray-800">{texts.trendSearchTitle}</h3>
                        <p className="text-gray-500 font-serif mt-1 text-sm">{texts.trendSearchSubtitle}</p>
                        <div className="mt-3 flex gap-2">
                            <Input value={industryForSearch} onChange={e => setIndustryForSearch(e.target.value)} placeholder={texts.industryPlaceholder} />
                            <Button onClick={() => onGenerateFacebookTrends(industryForSearch)} disabled={!industryForSearch || isGeneratingTrendsFromSearch} className="w-48">
                               {isGeneratingTrendsFromSearch ? texts.analyzing : <><SearchIcon className="h-4 w-4 mr-2" />{texts.analyzeTrends}</>}
                            </Button>
                        </div>
                    </div>
                    <div className="flex-grow overflow-y-auto space-y-2 -mr-2 pr-2">
                        {trends.map(trend => {
                            const isProductTrend = trend.id.startsWith('product-');
                            return (
                                <button 
                                    key={trend.id} 
                                    onClick={() => { 
                                        setSelectedTrend(trend);
                                        setEditingTrend(null);
                                        if (onLoadIdeasForTrend) {
                                            onLoadIdeasForTrend(trend.id);
                                        }
                                    }} 
                                    className={`w-full text-left p-3 rounded-md transition-colors ${selectedTrend?.id === trend.id && !editingTrend ? 'bg-green-100' : 'hover:bg-gray-100'}`}
                                >
                                    <div className="flex items-start gap-2">
                                        {isProductTrend && (
                                            <TagIcon className="h-4 w-4 text-blue-500 flex-shrink-0 mt-0.5" />
                                        )}
                                        <div className="flex-grow min-w-0">
                                            <p className="font-semibold text-gray-900 truncate">{trend.topic}</p>
                                            <p className="text-xs text-gray-500 truncate">{trend.keywords ? trend.keywords.join(', ') : ''}</p>
                                        </div>
                                    </div>
                                </button>
                            );
                        })}
                    </div>
                </aside>

                <main className="flex-1 p-6 lg:p-10 overflow-y-auto">
                    {editingTrend ? (
                        <TrendForm trend={editingTrend} onSave={handleSaveTrend} onCancel={() => setEditingTrend(null)} language={language} />
                    ) : selectedTrend ? (
                        <div>
                            <div className="flex justify-between items-start mb-4">
                                <div>
                                    <h3 className="text-xl font-bold text-gray-800">
                                        {selectedTrend.id.startsWith('product-') ? 'Product Ideas for:' : texts.ideasFor}
                                    </h3>
                                    <p className="text-2xl font-bold text-brand-green">{selectedTrend.topic}</p>
                                </div>
                                <div className="flex items-center gap-2">
                                    {!selectedTrend.id.startsWith('product-') && (
                                        <>
                                            <Button variant="tertiary" onClick={() => setEditingTrend(selectedTrend)}><PencilIcon className="h-4 w-4"/></Button>
                                            <Button variant="tertiary" onClick={() => handleDeleteTrend(selectedTrend.id)} className="text-red-600 hover:bg-red-50"><TrashIcon className="h-4 w-4"/></Button>
                                        </>
                                    )}
                                    <Button 
                                        onClick={() => onGenerateIdeas(selectedTrend, useSearchForIdeas)} 
                                        disabled={isGeneratingIdeas || selectedTrend.id.startsWith('product-')} 
                                        className="flex items-center justify-center gap-1.5 w-40"
                                        title={selectedTrend.id.startsWith('product-') ? "Cannot generate new ideas for product-based trends" : ""}
                                    >
                                        {isGeneratingIdeas ? '...' : (
                                            <>
                                                <SparklesIcon className="h-4 w-4"/> 
                                                {selectedTrend.id.startsWith('product-') ? "Product Ideas" : texts.generateIdeas}
                                            </>
                                        )}
                                    </Button>
                                </div>
                            </div>
                            {!selectedTrend.id.startsWith('product-') && selectedTrend.analysis && (
                                <p className="text-sm text-gray-600 italic border-l-4 border-gray-200 pl-4 my-4">{selectedTrend.analysis}</p>
                            )}
                            {!selectedTrend.id.startsWith('product-') && (
                                <div className="p-4 bg-gray-100 rounded-lg border mb-4">
                                    <Switch id="idea-hub-use-search" label={texts.useSearch} checked={useSearchForIdeas} onChange={setUseSearchForIdeas} disabled={!isGeminiModel}/>
                                    <p className="text-sm text-gray-500 mt-1">{texts.useSearchDesc} <span className="font-bold text-gray-600">{texts.geminiOnly}</span></p>
                                </div>
                            )}
                            <div className="space-y-4">
                                {ideasForSelectedTrend.length > 0 ? (
                                    ideasForSelectedTrend.map(idea => (
                                        <IdeaCard 
                                            key={idea.id} 
                                            idea={idea} 
                                            onCreatePlanFromIdea={onCreatePlanFromIdea} 
                                            onOpenContentPackageWizard={setWizardIdea} 
                                            language={language} 
                                        />
                                    ))
                                ) : (
                                    <div className="text-center py-10 text-gray-500">
                                        <LightBulbIcon className="h-12 w-12 text-gray-300 mx-auto mb-3" />
                                        <p className="font-medium">No ideas generated yet</p>
                                        <p className="text-sm mt-1">Click "Generate Ideas" to create content ideas for this trend</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : (
                        <div className="text-center py-20 text-gray-400 h-full flex flex-col items-center justify-center">
                            <LightBulbIcon className="h-16 w-16 text-gray-300 mb-4" />
                            <p className="text-lg font-semibold">{texts.noTrendSelected}</p>
                        </div>
                    )}
                </main>
            </div>
            
            <ContentPackageWizardModal
                isOpen={!!wizardIdea}
                onClose={() => setWizardIdea(null)}
                idea={wizardIdea}
                onGenerate={(idea, personaId, selectedProductId, options) => {
                    onGenerateContentPackage(idea, personaId, selectedProductId, options);
                    setWizardIdea(null);
                }}
                language={language}
                personas={personas}
                affiliateLinks={affiliateLinks}
                generatedImages={generatedImages}
                isGenerating={isGeneratingIdeas}
            />
        </div>
    );
};

export default StrategyDisplay;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\StrategyDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Toast.tsx ---\n
import React, { useEffect, useState } from 'react';
import { CheckCircleIcon, InformationCircleIcon, XIcon } from './icons';

interface ToastProps {
  message: string;
  type: 'success' | 'error';
  onClose: () => void;
}

const Toast: React.FC<ToastProps> = ({ message, type, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose();
    }, 5000); // Auto-close after 5 seconds

    return () => {
      clearTimeout(timer);
    };
  }, [onClose]);

  const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
  const Icon = type === 'success' ? CheckCircleIcon : InformationCircleIcon;

  return (
    <div className={`fixed bottom-5 right-5 flex items-center p-4 rounded-lg text-white ${bgColor} shadow-lg z-50`}>
      <Icon className="h-6 w-6 mr-3" />
      <span>{message}</span>
      <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20">
        <XIcon className="h-5 w-5" />
      </button>
    </div>
  );
};

export default Toast;
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\Toast.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\TrendHubDisplay.tsx ---\n

import React, { useState, useMemo, useEffect } from 'react';
import type { Trend, Idea, Settings, Persona } from '../types';
import { Button, Input, TextArea, Switch } from './ui';
import { PlusIcon, LightBulbIcon, TrashIcon, PencilIcon, SparklesIcon, DotsVerticalIcon, FacebookIcon, SearchIcon, LinkIcon } from './icons';
import ContentPackageWizardModal from './ContentPackageWizardModal';

// --- SUB-COMPONENTS ---

const TrendForm: React.FC<{
    trend: Partial<Trend>;
    onSave: (trendData: Omit<Partial<Trend>, 'keywords' | 'links'> & { keywords?: string; links?: string }) => void;
    onCancel: () => void;
    language: string;
}> = ({ trend, onSave, onCancel, language }) => {
    const [formData, setFormData] = useState({
        topic: trend.topic || '',
        industry: trend.industry || '',
        keywords: (trend.keywords || []).join(', '),
        links: (trend.links || []).map(l => `${l.title}: ${l.url}`).join('\n'),
        notes: trend.notes || '',
    });

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleSave = () => {
        onSave({ ...trend, ...formData });
    };

    const T = {
        'Việt Nam': { topic: 'Chủ đề', industry: 'Ngành', keywords: 'Từ khóa (phân tách bằng dấu phẩy)', links: 'Liên kết (Mỗi dòng một link, định dạng: Tiêu đề: URL)', notes: 'Ghi chú', save: 'Lưu', cancel: 'Hủy' },
        'English': { topic: 'Topic', industry: 'Industry', keywords: 'Keywords (comma-separated)', links: 'Links (One per line, format: Title: URL)', notes: 'Notes', save: 'Save', cancel: 'Cancel' }
    };
    const texts = (T as any)[language] || T['English'];

    return (
        <div className="space-y-4">
            <Input name="topic" placeholder={texts.topic} value={formData.topic} onChange={handleChange} />
            <Input name="industry" placeholder={texts.industry} value={formData.industry} onChange={handleChange} />
            <TextArea name="keywords" placeholder={texts.keywords} value={formData.keywords} onChange={handleChange} rows={2} />
            <TextArea name="links" placeholder={texts.links} value={formData.links} onChange={handleChange} rows={3} />
            <TextArea name="notes" placeholder={texts.notes} value={formData.notes} onChange={handleChange} rows={3} />
            <div className="flex justify-end gap-2">
                <Button variant="tertiary" onClick={onCancel}>{texts.cancel}</Button>
                <Button onClick={handleSave}>{texts.save}</Button>
            </div>
        </div>
    );
};

// --- MAIN DISPLAY COMPONENT ---

interface TrendHubDisplayProps {
    language: string;
    trends: Trend[];
    ideas: Idea[];
    personas: Persona[];
    generatedImages: Record<string, string>;
    settings: Settings;
    onSaveTrend: (trend: Trend) => void;
    onDeleteTrend: (trendId: string) => void;
    onGenerateIdeas: (trend: Trend, useSearch: boolean) => void;
    onCreatePlanFromIdea: (prompt: string, productId?: string) => void;
    onGenerateContentPackage: (idea: Idea, pillarPlatform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest', personaId: string | null) => void;
    isGeneratingIdeas: boolean;
}

const TrendHubDisplay: React.FC<TrendHubDisplayProps> = (props) => {
    const { language, trends, ideas, personas, generatedImages, settings, onSaveTrend, onDeleteTrend, onGenerateIdeas, onCreatePlanFromIdea, onGenerateContentPackage, isGeneratingIdeas } = props;
    
    const [selectedTrend, setSelectedTrend] = useState<Trend | null>(null);
    const [editingTrend, setEditingTrend] = useState<Partial<Trend> | null>(null);
    const [useSearchForIdeas, setUseSearchForIdeas] = useState(false);
    const isGeminiModel = settings.textGenerationModel.startsWith('gemini-');
    const [wizardIdea, setWizardIdea] = useState<Idea | null>(null);

    // Facebook Strategy State
    

    // Facebook Strategy State
    

    // Facebook Strategy State
    
    
    const T = {
        'Việt Nam': {
            trends: "Xu hướng",
            addTrend: "Thêm Xu hướng",
            ideasFor: "Ý tưởng cho:",
            noTrendSelected: "Chọn một xu hướng để xem ý tưởng.",
            generateIdeas: "Tạo Ý tưởng",
            generating: "Đang tạo...",
            useSearch: "Dùng Google Search",
            useSearchDesc: "Sử dụng Google Tìm kiếm để có nội dung thực tế, cập nhật.",
            geminiOnly: "Chỉ dành cho Gemini",
            createPlan: "Tạo Kế hoạch",
            createPackage: "Tạo Gói Nội dung",
            confirmDelete: "Bạn có chắc muốn xóa xu hướng này và tất cả các ý tưởng liên quan không?",
            fbStrategyTitle: "Tự động hóa Chiến lược Facebook",
            fbStrategySubtitle: "Phân tích xu hướng và tạo ý tưởng bài đăng cho ngành của bạn.",
            industryPlaceholder: "Nhập ngành của bạn (ví dụ: Thời trang, Công nghệ, Ẩm thực)",
            analyzeTrends: "Phân tích Xu hướng",
            analyzing: "Đang phân tích...",
        },
        'English': {
            trends: "Trends",
            addTrend: "Add Trend",
            ideasFor: "Ideas for:",
            noTrendSelected: "Select a trend to see ideas.",
            generateIdeas: "Generate Ideas",
            generating: "Generating...",
            useSearch: "Use Google Search",
            useSearchDesc: "Uses Google Search for factual, up-to-date content.",
            geminiOnly: "Gemini only",
            createPlan: "Create Plan",
            createPackage: "Generate Content Package",
            confirmDelete: "Are you sure you want to delete this trend and all its associated ideas?",
            fbStrategyTitle: "Facebook Strategy Automation",
            fbStrategySubtitle: "Analyze trends and generate post ideas for your industry.",
            industryPlaceholder: "Enter your industry (e.g., Fashion, Tech, Food)",
            analyzeTrends: "Analyze Trends",
            analyzing: "Analyzing...",
        }
    };
    const texts = (T as any)[language] || T['English'];

    const handleSaveTrend = (trendData: Omit<Partial<Trend>, 'keywords' | 'links'> & { keywords?: string; links?: string }) => {
        const parsedKeywords = (trendData.keywords || '').split(',').map(k => k.trim()).filter(Boolean);
        const parsedLinks = (trendData.links || '').split('\n').map(line => {
            const parts = line.split(':');
            if (parts.length < 2) return null;
            const title = parts[0].trim();
            const url = parts.slice(1).join(':').trim();
            return (title && url) ? { title, url } : null;
        }).filter((l): l is { title: string, url: string } => l !== null);

        const trendToSave: Trend = {
            id: trendData.id || crypto.randomUUID(),
            brandId: '', // App.tsx will fill this
            industry: trendData.industry || '',
            topic: trendData.topic || 'New Trend',
            keywords: parsedKeywords,
            links: parsedLinks,
            notes: trendData.notes || '',
            createdAt: trendData.createdAt || new Date().toISOString(),
        };
        onSaveTrend(trendToSave);
        setEditingTrend(null);
        setSelectedTrend(trendToSave);
    };

    const handleDeleteTrend = (trendId: string) => {
        if(window.confirm(texts.confirmDelete)) {
            onDeleteTrend(trendId);
            if (selectedTrend?.id === trendId) {
                setSelectedTrend(trends.length > 1 ? trends.find(t => t.id !== trendId) || null : null);
            }
        }
    };

    

    return (
        <div className="h-full flex flex-col p-6 lg:p-10 bg-gray-50/50">
             <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                 <div>
                    <h2 className="text-3xl font-bold font-sans text-gray-900 flex items-center gap-3"><LightBulbIcon className="h-8 w-8 text-brand-green"/> Content Strategy</h2>
                </div>
            </header>

            <div className="h-full flex flex-col xl:flex-row pt-6">
                <aside className="w-full xl:w-1/3 border-b xl:border-b-0 xl:border-r border-gray-200 bg-white p-6 flex flex-col">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="text-xl font-bold text-gray-800">{texts.trends}</h3>
                        <Button variant="secondary" onClick={() => setEditingTrend({})} className="flex items-center gap-1.5 !px-2 !py-1">
                            <PlusIcon className="h-4 w-4"/> {texts.addTrend}
                        </Button>
                    </div>
                    <div className="mt-4 mb-4">
                        <h3 className="text-lg font-bold font-sans text-gray-900">{texts.fbStrategyTitle}</h3>
                        <p className="text-gray-500 font-serif text-sm mt-1">{texts.fbStrategySubtitle}</p>
                        <div className="mt-2 flex gap-2">
                            <Input value={fbIndustry} onChange={e => setFbIndustry(e.target.value)} placeholder={texts.industryPlaceholder} />
                            <Button onClick={() => props.onGenerateFacebookTrends(fbIndustry)} disabled={!fbIndustry || props.isGeneratingFacebookTrends} className="w-48">
                               {props.isGeneratingFacebookTrends ? texts.analyzing : texts.analyzeTrends}
                            </Button>
                        </div>
                    </div>
                    <div className="flex-grow overflow-y-auto space-y-2 -mr-2 pr-2">
                        {trends.map(trend => (
                            <button key={trend.id} onClick={() => { setSelectedTrend(trend); setEditingTrend(null); }} className={`w-full text-left p-3 rounded-md transition-colors ${selectedTrend?.id === trend.id && !editingTrend ? 'bg-green-100' : 'hover:bg-gray-100'}`}>
                                <p className="font-semibold text-gray-900 truncate">{trend.topic}</p>
                                <p className="text-xs text-gray-500 truncate">{trend.keywords.join(', ')}</p>
                            </button>
                        ))}
                    </div>
                </aside>

                <main className="flex-1 p-6 lg:p-10 overflow-y-auto">
                    {editingTrend ? (
                        <TrendForm trend={editingTrend} onSave={handleSaveTrend} onCancel={() => setEditingTrend(null)} language={language} />
                    ) : selectedTrend ? (
                        <div>
                            <div className="flex justify-between items-start mb-4">
                                <div>
                                    <h3 className="text-xl font-bold text-gray-800">{texts.ideasFor}</h3>
                                    <p className="text-2xl font-bold text-brand-green">{selectedTrend.topic}</p>
                                </div>
                                <div className="flex items-center gap-2">
                                    <Button variant="tertiary" onClick={() => setEditingTrend(selectedTrend)}><PencilIcon className="h-4 w-4"/></Button>
                                    <Button variant="tertiary" onClick={() => handleDeleteTrend(selectedTrend.id)} className="text-red-600 hover:bg-red-50"><TrashIcon className="h-4 w-4"/></Button>
                                    <Button onClick={() => onGenerateIdeas(selectedTrend, useSearchForIdeas)} disabled={isGeneratingIdeas} className="flex items-center justify-center gap-1.5 w-40">
                                        {isGeneratingIdeas ? '...' : <><SparklesIcon className="h-4 w-4"/> {texts.generateIdeas}</>}
                                    </Button>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-100 rounded-lg border mb-4">
                                <Switch id="idea-hub-use-search" label={texts.useSearch} checked={useSearchForIdeas} onChange={setUseSearchForIdeas} disabled={!isGeminiModel}/>
                                <p className="text-sm text-gray-500 mt-1">{texts.useSearchDesc} <span className="font-bold text-gray-600">{texts.geminiOnly}</span></p>
                            </div>
                            <div className="space-y-4">
                                {ideasForSelectedTrend.map(idea => (
                                    <div key={idea.id} className="bg-white p-4 rounded-lg border border-gray-200">
                                        <h4 className="font-bold text-gray-900">{idea.title}</h4>
                                        <p className="text-sm text-gray-600 mt-1">{idea.description}</p>
                                        <p className="text-xs text-gray-400 mt-2">Target: {idea.targetAudience}</p>
                                        <div className="flex justify-end gap-2 mt-3">
                                            <Button variant="secondary" onClick={() => onCreatePlanFromIdea(idea.description, idea.productId)} className="text-xs py-1 px-2">{texts.createPlan}</Button>
                                            <Button variant="primary" onClick={() => setWizardIdea(idea)} className="text-xs py-1 px-2">{texts.createPackage}</Button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ) : (
                        <div className="text-center py-20 text-gray-400 h-full flex flex-col items-center justify-center">
                            <LightBulbIcon className="h-16 w-16 text-gray-300 mb-4" />
                            <p className="text-lg font-semibold">{texts.noTrendSelected}</p>
                        </div>
                    )}
                </main>
            </div>
            
            <ContentPackageWizardModal
                isOpen={!!wizardIdea}
                onClose={() => setWizardIdea(null)}
                idea={wizardIdea}
                onGenerate={(idea, platform, personaId) => {
                    onGenerateContentPackage(idea, platform, personaId);
                    setWizardIdea(null);
                }}
                language={language}
                personas={personas}
                generatedImages={generatedImages}
            />
        </div>
    );
};

export default StrategyDisplay;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\TrendHubDisplay.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ui.tsx ---\nimport React, { useState } from 'react';
import { CopyIcon, CheckCircleIcon } from './icons';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'tertiary';
  isLoading?: boolean;
}

export const Button: React.FC<ButtonProps> = ({ children, className, variant = 'primary', isLoading, ...props }) => {
  const baseClasses = 'px-4 py-2 rounded-full font-semibold text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-green disabled:opacity-50 disabled:cursor-not-allowed';
  
  const variantClasses = {
    primary: 'bg-brand-green text-white hover:bg-brand-green-dark',
    secondary: 'bg-white text-brand-green border border-brand-green hover:bg-green-50',
    tertiary: 'bg-transparent text-gray-600 hover:bg-gray-100'
  };

  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${className}`}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? (
        <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin"></div>
      ) : (
        children
      )}
    </button>
  );
};

export const Input: React.FC<React.InputHTMLAttributes<HTMLInputElement>> = ({ className, ...props }) => (
  <input
    className={`w-full bg-white border border-gray-300 rounded-md py-2 px-3 text-gray-900 focus:outline-none focus:ring-2 focus:ring-brand-green focus:border-transparent transition-colors ${className}`}
    {...props}
  />
);

export const Select: React.FC<React.SelectHTMLAttributes<HTMLSelectElement>> = ({ className, ...props }) => (
    <select
      className={`w-full bg-white border border-gray-300 rounded-md py-2 px-3 text-gray-900 focus:outline-none focus:ring-2 focus:ring-brand-green focus:border-transparent transition-colors ${className}`}
      {...props}
    />
);

export const TextArea: React.FC<React.TextareaHTMLAttributes<HTMLTextAreaElement>> = ({ className, ...props }) => (
  <textarea
    className={`w-full bg-white border border-gray-300 rounded-md py-2 px-3 text-gray-900 focus:outline-none focus:ring-2 focus:ring-brand-green focus:border-transparent transition-colors ${className}`}
    rows={3}
    {...props}
  />
);

export const Section: React.FC<{ title: string; children: React.ReactNode, id?: string }> = ({ title, children, id }) => (
  <div id={id} className="py-8">
    <h3 className="text-3xl font-bold font-sans text-gray-900 mb-2 pb-4 border-b border-gray-200">{title}</h3>
    <div className="mt-4 font-serif text-gray-700 space-y-4">
        {children}
    </div>
  </div>
);

export const CopyableText: React.FC<{ text: string }> = ({ text }) => {
    const [copied, setCopied] = useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    return (
        <div className="flex items-center justify-between bg-gray-50 p-3 rounded-lg my-1 border border-gray-200">
            <code className="text-gray-700 break-all">{text}</code>
            <button onClick={handleCopy} className="ml-4 text-gray-500 hover:text-gray-900 transition-colors flex-shrink-0">
                {copied ? 'Copied!' : <CopyIcon className="h-5 w-5"/>}
            </button>
        </div>
    );
};

export const HoverCopyWrapper: React.FC<{ children: React.ReactNode; textToCopy: string; className?: string; }> = ({ children, textToCopy, className }) => {
    const [copied, setCopied] = useState(false);

    const handleCopy = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (!textToCopy) return;
        navigator.clipboard.writeText(textToCopy);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    return (
        <div className={`relative group ${className || ''}`}>
            {children}
            <button
                onClick={handleCopy}
                className="absolute top-1 right-1 p-1.5 bg-white/70 backdrop-blur-sm rounded-full text-gray-500 hover:text-gray-900 transition-all opacity-0 group-hover:opacity-100 focus:opacity-100 disabled:opacity-50"
                aria-label="Copy text"
                disabled={!textToCopy}
            >
                {copied ? <CheckCircleIcon className="h-5 w-5 text-brand-green" /> : <CopyIcon className="h-5 w-5" />}
            </button>
        </div>
    );
};


export const Switch: React.FC<{
  checked: boolean;
  onChange: (checked: boolean) => void;
  label: string;
  id: string;
  disabled?: boolean;
}> = ({ checked, onChange, label, id, disabled = false }) => (
  <div className="flex items-center">
    <button
      id={id}
      type="button"
      role="switch"
      aria-checked={checked}
      onClick={() => !disabled && onChange(!checked)}
      disabled={disabled}
      className={`${
        checked ? 'bg-brand-green' : 'bg-gray-200'
      } relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brand-green focus:ring-offset-2 ${
        disabled ? 'opacity-50 cursor-not-allowed' : ''
      }`}
    >
      <span
        aria-hidden="true"
        className={`${
          checked ? 'translate-x-5' : 'translate-x-0'
        } pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out`}
      />
    </button>
    <label htmlFor={id} className={`ml-3 text-sm font-medium ${disabled ? 'text-gray-400' : 'text-gray-700'}`}>
      {label}
    </label>
  </div>
);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\ui.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\FunnelIcon.tsx ---\nimport React from 'react';

export const FunnelIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
  </svg>
);\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\FunnelIcon.tsx ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\index.ts ---\nexport { ArchiveIcon } from '../icons';
export { CalendarIcon } from '../icons';
export { ChatBubbleLeftIcon } from '../icons';
export { CheckCircleIcon } from '../icons';
export { CheckSolidIcon } from '../icons';
export { ChevronDownIcon } from '../icons';
export { ChevronLeftIcon } from '../icons';
export { ChevronRightIcon } from '../icons';
export { CollectionIcon } from '../icons';
export { DotsVerticalIcon } from '../icons';
export { FacebookIcon } from '../icons';
export { FunnelIcon } from '../icons';
export { InstagramIcon } from '../icons';
export { KhongMinhIcon } from '../icons';
export { LightBulbIcon } from '../icons';
export { LinkIcon } from '../icons';
export { ListBulletIcon } from '../icons';
export { PencilIcon } from '../icons';
export { PinterestIcon } from '../icons';
export { PlusIcon } from '../icons';
export { SearchIcon } from '../icons';
export { SparklesIcon } from '../icons';
export { TagIcon } from '../icons';
export { TrashIcon } from '../icons';
export { UsersIcon } from '../icons';
export { YouTubeIcon } from '../icons';
export { TikTokIcon } from '../icons';\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\components\icons\index.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useInfiniteScroll.ts ---\nimport { useState, useCallback, useEffect } from 'react';
import { loadMediaPlanPostsWithPagination } from '../services/databaseService';
import type { MediaPlanPost } from '../types';

/**
 * Hook to handle infinite scrolling for media plan posts
 */
export const useInfiniteScroll = (
    planId: string | null,
    initialPosts: MediaPlanPost[] = []
) => {
    const [posts, setPosts] = useState<MediaPlanPost[]>(initialPosts);
    const [currentPage, setCurrentPage] = useState(1);
    const [hasMore, setHasMore] = useState(true);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [totalPosts, setTotalPosts] = useState(0);

    const loadMorePosts = useCallback(async () => {
        if (!planId || !hasMore || loading) return;

        setLoading(true);
        setError(null);

        try {
            const { posts: newPosts, pagination } = await loadMediaPlanPostsWithPagination(
                planId,
                currentPage + 1,
                30 // 30 posts per page
            );

            setPosts(prev => [...prev, ...newPosts]);
            setCurrentPage(pagination.currentPage);
            setHasMore(pagination.hasNextPage);
            setTotalPosts(pagination.totalPosts);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load more posts');
        } finally {
            setLoading(false);
        }
    }, [planId, hasMore, loading, currentPage]);

    // Reset when planId changes
    useEffect(() => {
        if (planId) {
            setPosts(initialPosts);
            setCurrentPage(1);
            setHasMore(true);
            setError(null);
            setTotalPosts(0);
        }
    }, [planId, initialPosts]);

    return {
        posts,
        loadMorePosts,
        hasMore,
        loading,
        error,
        totalPosts
    };
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useInfiniteScroll.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useMediaPlanPagination.ts ---\nimport { useCallback } from 'react';
import { MediaPlanPost, PostInfo } from '../types';
import { loadMediaPlanPostsWithPagination } from '../services/databaseService';

/**
 * Hook to handle loading additional pages of posts for a media plan with pagination
 */
export const useMediaPlanPagination = (
    activePlanId: string | null,
    generatedImages: Record<string, string>,
    setGeneratedImages: (images: Record<string, string>) => void,
    dispatchAssets: (action: any) => void
) => {
    const loadAdditionalPosts = useCallback(async (
        planId: string,
        page: number = 1,
        limit: number = 30
    ) => {
        if (!activePlanId) return;

        try {
            // Load posts with pagination
            const { posts, pagination } = await loadMediaPlanPostsWithPagination(planId, page, limit);
            
            // Update generated images with new image URLs
            const newImageUrls: Record<string, string> = {};
            posts.forEach(post => {
                if (post.imageKey && post.imageKey.startsWith('data:')) {
                    newImageUrls[post.imageKey] = post.imageKey;
                }
            });
            
            setGeneratedImages(prev => ({...prev, ...newImageUrls}));
            
            // Update the plan with the new posts
            dispatchAssets({ 
                type: 'UPDATE_PLAN_POSTS', 
                payload: { 
                    planId, 
                    posts,
                    pagination
                } 
            });
            
            return { posts, pagination };
        } catch (error) {
            console.error(`Failed to load additional posts for plan ${planId}:`, error);
            throw error;
        }
    }, [activePlanId, generatedImages, setGeneratedImages, dispatchAssets]);

    return { loadAdditionalPosts };
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\hooks\useMediaPlanPagination.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\bffService.ts ---\nimport type { MediaPlanPost, AffiliateLink, BrandFoundation, Persona } from '../types';

// Get the BFF URL from environment variables or use default
// In production, VITE_BFF_URL should be set to your actual BFF deployment URL
const BFF_URL = import.meta.env.VITE_BFF_URL || '';

// Generic fetch helper with error handling
export const bffFetch = async (endpoint: string, options: RequestInit = {}) => {
  // Use relative path when proxying through Vite in development
  // Use full URL in production when VITE_BFF_URL is set
  const url = BFF_URL ? `${BFF_URL}${endpoint}` : endpoint;
  
  try {
    const fetchOptions: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      mode: 'cors',
      credentials: 'include',
    };
    
    const response = await fetch(url, fetchOptions);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `BFF request failed with status ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    // Re-throw the error to be handled by the calling function
    throw error;
  }
};

// --- Gemini API Functions ---

export const generateContentWithBff = async (
  model: string,
  contents: string,
  config?: any
): Promise<string> => {
  try {
    const response = await bffFetch('/api/gemini/generate', {
      method: 'POST',
      body: JSON.stringify({ model, contents, config }),
    });
    
    return response.text;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/gemini/generate:`, error);
    throw error;
  }
};

export const generateImageWithBff = async (
  model: string,
  prompt: string,
  config?: any
): Promise<string> => {
  try {
    const response = await bffFetch('/api/gemini/generate-image', {
      method: 'POST',
      body: JSON.stringify({ model, prompt, config }),
    });
    
    return response.image;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/gemini/generate-image:`, error);
    throw error;
  }
};

// --- OpenRouter API Functions ---

export const generateContentWithOpenRouterBff = async (
  model: string,
  messages: any[],
  responseFormat?: any
): Promise<string> => {
  try {
    const response = await bffFetch('/api/openrouter/generate', {
      method: 'POST',
      body: JSON.stringify({ model, messages, responseFormat }),
    });
    
    return response.text;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/openrouter/generate:`, error);
    throw error;
  }
};

export const generateImageWithOpenRouterBff = async (
  model: string,
  messages: any[],
  responseFormat?: any
): Promise<string> => {
  try {
    const response = await bffFetch('/api/openrouter/generate-image', {
      method: 'POST',
      body: JSON.stringify({ model, messages, responseFormat }),
    });
    
    return response.image;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/openrouter/generate-image:`, error);
    throw error;
  }
};

// --- Cloudinary API Functions ---

export const uploadMediaWithBff = async (
  media: Record<string, string>,
  cloudName: string,
  uploadPreset: string
): Promise<Record<string, string>> => {
  try {
    const response = await bffFetch('/api/cloudinary/upload', {
      method: 'POST',
      body: JSON.stringify({ media, cloudName, uploadPreset }),
    });
    
    return response.uploadedUrls;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/cloudinary/upload:`, error);
    throw error;
  }
};

// --- Facebook API Functions ---

export const publishToFacebookWithBff = async (
  post: MediaPlanPost,
  imageUrl: string | undefined,
  pageId: string,
  accessToken: string,
  videoUrl?: string
): Promise<{ publishedUrl: string }> => {
  try {
    const response = await bffFetch('/api/facebook/publish', {
      method: 'POST',
      body: JSON.stringify({ post, imageUrl, pageId, accessToken, videoUrl }),
    });
    
    return response;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/facebook/publish:`, error);
    throw error;
  }
};

// --- Airtable API Functions ---

export const airtableRequestWithBff = async (
  method: string,
  path: string,
  body?: any,
  headers?: Record<string, string>
): Promise<any> => {
  try {
    const response = await bffFetch('/api/airtable/request', {
      method: 'POST',
      body: JSON.stringify({ method, path, body, headers }),
    });
    
    return response;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/airtable/request:`, error);
    throw error;
  }
};

// --- Health Check ---

export const checkBffHealth = async (): Promise<{
  status: string;
  timestamp: string;
  services: Record<string, boolean>;
}> => {
  try {
    return await bffFetch('/api/health');
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/health:`, error);
    throw error;
  }
};

// --- Cloudflare API Functions ---

export const generateImageWithCloudflareBff = async (
  prompt: string,
  model: string,
  image?: number[]
): Promise<string> => {
  try {
    const response = await bffFetch('/api/cloudflare/generate-image', {
      method: 'POST',
      body: JSON.stringify({ prompt, model, image }),
    });
    
    return response.image;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/cloudflare/generate-image:`, error);
    throw error;
  }
};

// --- Gemini Embedding Functions ---

export const generateEmbeddingsWithBff = async (
  texts: string[],
  taskTypes: string[]
): Promise<number[][]> => {
  try {
    const response = await bffFetch('/api/gemini/embed', {
      method: 'POST',
      body: JSON.stringify({ texts, taskTypes }),
    });
    
    return response.embeddings;
  } catch (error) {
    console.error(`Error calling BFF endpoint /api/gemini/embed:`, error);
    throw error;
  }
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\bffService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudflareService.ts ---\n// services/cloudflareService.ts
import { generateImageWithCloudflareBff } from './bffService';

const fileToUint8Array = (file: File): Promise<Uint8Array> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(new Uint8Array(reader.result as ArrayBuffer));
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
};

/**
 * Generates an image using a Cloudflare AI model. Supports text-to-image and image-to-image.
 * @param prompt - The text instruction for the image generation.
 * @param model - The specific Cloudflare model to use (e.g., '@cf/stabilityai/stable-diffusion-xl-base-1.0').
 * @param productImages - An array of product images. If provided, the first image will be used for image-to-image tasks.
 * @returns A Promise that resolves to a data URL string of the generated image.
 */
export const generateImageWithCloudflare = async (
    prompt: string,
    model: string,
    productImages: File[]
): Promise<string> => {
    if (!prompt || prompt.trim() === '') {
        throw new Error("Prompt cannot be empty for Cloudflare image generation.");
    }

    let imageBytes: number[] | undefined;
    if (productImages && productImages.length > 0) {
        // If images are provided, use the first one for image-to-image generation.
        // The API expects the image as an array of bytes.
        const uint8Array = await fileToUint8Array(productImages[0]);
        imageBytes = Array.from(uint8Array);
    }
    
    // Use BFF for secure Cloudflare image generation
    return await generateImageWithCloudflareBff(
        prompt,
        model,
        imageBytes
    );
};
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudflareService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudinaryService.ts ---\nimport { uploadMediaWithBff } from './bffService';

export const uploadMediaToCloudinary = async (
    media: Record<string, string>
): Promise<Record<string, string>> => {

    const mediaToUpload = Object.entries(media).filter(
        ([, url]) => url && url.startsWith('data:')
    );

    if (mediaToUpload.length === 0) {
        return {};
    }
    
    // Use BFF exclusively for secure Cloudinary uploads
    return await uploadMediaWithBff(media);
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\cloudinaryService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\configService.ts ---\n
import type { Settings } from '../types';
import { saveSettingsToAirtable, fetchSettingsFromAirtable, fetchAdminDefaultsFromAirtable, saveAdminDefaultsToAirtable } from './databaseService';

// Define AiModelConfig as a type that extracts the AI model related fields from Settings
export type AiModelConfig = Pick<Settings, 'textModelFallbackOrder' | 'visionModels'>;

interface AppConfig {
    settings: Settings;
}

// Default values for initial setup
const DEFAULT_AFFILIATE_CONTENT_KIT = `Bạn là một chuyên gia sáng tạo nội dung tuân thủ "Bộ quy tắc Sáng tạo Nội dung Affiliate". Nguyên tắc cốt lõi của bạn là: "Hãy hành động như một CHUYÊN GIA TƯ VẤN ĐÁNG TIN CẬY, không phải một người bán hàng." Mọi nội dung bạn tạo ra phải tuân thủ nghiêm ngặt các quy tắc sau:

**1. Ngôn ngữ và Giọng văn (Cực kỳ quan trọng):**
*   **Tư duy như một chuyên gia đánh giá và cố vấn.** Mục tiêu của bạn là giúp người dùng đưa ra quyết định sáng suốt.
*   **NÊN DÙNG các động từ này:** đánh giá, trải nghiệm, trên tay, so sánh, phân tích, gợi ý, đề xuất, hướng dẫn, lựa chọn, tìm hiểu.
*   **TUYỆT ĐỐI TRÁNH các động từ này:** bán, cung cấp, phân phối, ship, vận chuyển, thanh toán, đặt hàng, mua ngay.
*   **NÊN DÙNG các đại từ xưng hô:** "Mình/Chúng tôi" (với tư cách người trải nghiệm), "bên mình" (khi nói về team review).
*   **TUYỆT ĐỐI TRÁNH các từ này:** "shop", "cửa hàng", "công ty" (khi bán hàng).
*   **NÊN DÙNG các cụm từ này:** "ưu/nhược điểm", "phù hợp với ai", "lưu ý khi sử dụng", "trải nghiệm thực tế của mình là...", "so với sản phẩm X...".
*   **TUYỆT ĐỐI TRÁNH các cụm từ này:** "sản phẩm của chúng tôi", "hàng của shop", "giá bên em", "chính sách bảo hành", "cam kết chính hãng".

**2. Kêu gọi hành động (CTA):**
*   **CTA của bạn phải trao quyền cho người dùng tự nghiên cứu và quyết định.**
*   **NÊN DÙNG các CTA này:** "Tham khảo giá tốt nhất tại [Tên Sàn]", "Xem chi tiết sản phẩm tại [Website Hãng]", "Tìm hiểu thêm và đặt mua tại [Link Affiliate]".
*   **TUYỆT ĐỐI TRÁNH các CTA này:** "Mua ngay!", "Đặt hàng ngay!", "Inbox để được tư vấn giá", "Để lại SĐT để đặt hàng".

**3. Cấu trúc và Triết lý Nội dung:**
*   **Bắt đầu bằng Vấn đề của Người dùng:** Luôn đề cập đến một nỗi đau hoặc nhu cầu trước, sau đó mới giới thiệu sản phẩm như một giải pháp.
*   **Khách quan - Nêu cả Ưu và Nhược điểm:** Mọi bài đánh giá phải cân bằng. Đề cập đến nhược điểm sẽ xây dựng sự tin cậy. Không có sản phẩm nào hoàn hảo.
*   **Tập trung vào "Trải nghiệm" và "Hướng dẫn":** Tạo nội dung cho thấy sản phẩm đang được sử dụng, giải thích cách dùng, và chia sẻ kết quả hoặc kinh nghiệm thực tế. Tránh chỉ liệt kê thông số kỹ thuật của nhà sản xuất.

**4. Prompt tạo Hình ảnh:**
*   Khi tạo hãy mô tả một cảnh thực tế, có bối cảnh. Thay vì "sản phẩm trên nền trắng", hãy mô tả "một người đang sử dụng sản phẩm trong một bối cảnh đời thực". Điều này phù hợp với quy tắc sử dụng hình ảnh chân thực, tự sản xuất.

Bằng cách tuân thủ nghiêm ngặt các quy tắc này, bạn sẽ tạo ra nội dung có giá trị cao, đáng tin cậy, giúp ích cho người dùng, thay vì chỉ cố gắng bán hàng cho họ.`;

const DEFAULT_APP_SETTINGS: Settings = {
    language: 'Việt Nam',
    totalPostsPerMonth: 16,
    mediaPromptSuffix: ', photorealistic, 8k, high quality, vietnamese style, vietnam',
    affiliateContentKit: DEFAULT_AFFILIATE_CONTENT_KIT,
    textGenerationModel: 'gemini-2.5-pro',
    imageGenerationModel: 'imagen-4.0-ultra-generate-preview-06-06',
    textModelFallbackOrder: [
        'qwen/qwen3-235b-a22b:free',
        'deepseek/deepseek-r1-0528:free',
        'google/gemini-2.0-flash-exp:free',
        'gemini-2.5-flash'
    ],
    visionModels: [
        'imagen-4.0-ultra-generate-preview-06-06',
        'imagen-3.0-generate-002'
    ],
};

class ConfigService {
    private settings: Settings;
    private brandId: string | null = null;

    constructor() {
        this.settings = DEFAULT_APP_SETTINGS;
    }

    async initializeConfig(): Promise<void> {
        // Load admin defaults on initialization
        const adminSettings = await fetchAdminDefaultsFromAirtable();
        if (adminSettings) {
            this.settings = { ...this.settings, ...adminSettings };
        }
    }

    // Set the brand ID to enable database operations
    async setBrandId(brandId: string): Promise<void> {
        this.brandId = brandId;
        // Load config from database
        await this.loadConfigFromDatabase();
    }

    private async loadConfigFromDatabase(): Promise<void> {
        if (!this.brandId) return;

        try {
            // Load settings from database
            const dbSettings = await fetchSettingsFromAirtable(this.brandId);
            if (dbSettings) {
                this.settings = { ...this.settings, ...dbSettings };
            }
        } catch (e) {
            console.error("Failed to load config from database:", e);
        }
    }

    getAppSettings(): Settings {
        return this.settings;
    }

    async updateAppSettings(newSettings: Partial<Settings>): Promise<void> {
        this.settings = { ...this.settings, ...newSettings };
        
        // Save to database if brandId is set
        if (this.brandId) {
            try {
                await saveSettingsToAirtable(this.settings, this.brandId);
            } catch (e) {
                console.error("Failed to save settings to database:", e);
                throw e;
            }
        }
    }

    async getAdminDefaults(): Promise<Settings> {
        const settings = await fetchAdminDefaultsFromAirtable();
        return settings || DEFAULT_APP_SETTINGS;
    }

    async saveAdminDefaults(settings: Settings): Promise<void> {
        try {
            await saveAdminDefaultsToAirtable(settings);
        } catch (e) {
            console.error("Failed to save admin defaults to database:", e);
            throw e;
        }
    }

    async cloneDefaultConfig(): Promise<Settings> {
        return await this.getAdminDefaults();
    }
    
    // New method to get brand-specific settings without affecting the global config
    async getBrandSettings(brandId: string): Promise<Settings | null> {
        return await fetchSettingsFromAirtable(brandId);
    }
    
    // New method to save brand-specific settings
    async saveBrandSettings(brandId: string, settings: Settings): Promise<void> {
        await saveSettingsToAirtable(settings, brandId);
    }
    
    // Method to get AI model configuration (merged with Settings)
    getAiModelConfig(): AiModelConfig {
        return {
            textModelFallbackOrder: this.settings.textModelFallbackOrder,
            visionModels: this.settings.visionModels
        };
    }
}

export const configService = new ConfigService();\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\configService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\databaseService.ts ---\nimport type { GeneratedAssets, Settings, MediaPlan, CoreMediaAssets, UnifiedProfileAssets, MediaPlanGroup, BrandFoundation, MediaPlanPost, AffiliateLink, Persona, PostStatus, Trend, Idea, ColorPalette, FontRecommendations, LogoConcept, PersonaPhoto, AIService } from '../types';

// Since we're migrating from Airtable to MongoDB, we'll keep the same function names
// but implement them using fetch requests to our MongoDB-based API endpoints

// --- NEW FUNCTIONS FOR MONGODB INTEGRATION ---

/**\n * Fetch settings from MongoDB\n */
export const fetchSettingsFromDatabase = async (brandId: string): Promise<Settings | null> => {
  try {
    const response = await fetch('/api/mongodb?action=fetch-settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch settings: ${response.statusText}`);
    }

    const settings = await response.json();
    return settings;
  } catch (error) {
    console.error('Failed to fetch settings from database:', error);
    throw error;
  }
};

/**\n * Save settings to MongoDB\n */
export const saveSettingsToDatabase = async (settings: Settings, brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ settings, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save settings: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Settings saved successfully:', result);
  } catch (error) {
    console.error('Failed to save settings to database:', error);
    throw error;
  }
};

/**
 * Fetch admin defaults from MongoDB
 */
export const fetchAdminDefaultsFromDatabase = async (): Promise<Settings> => {
  try {
    const response = await fetch('/api/mongodb?action=fetch-admin-defaults', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch admin defaults: ${response.statusText}`);
    }

    const settings = await response.json();
    return settings;
  } catch (error) {
    console.error('Failed to fetch admin defaults from database:', error);
    throw error;
  }
};

/**
 * Save admin defaults to MongoDB
 */
export const saveAdminDefaultsToDatabase = async (settings: Settings): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-admin-defaults', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(settings),
    });

    if (!response.ok) {
      throw new Error(`Failed to save admin defaults: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Admin defaults saved successfully:', result);
  } catch (error) {
    console.error('Failed to save admin defaults to database:', error);
    throw error;
  }
};

/**
 * Create or update a brand record in MongoDB
 */
export const createOrUpdateBrandRecordInDatabase = async (
  assets: GeneratedAssets,
  imageUrls: Record<string, string>,
  brandId: string | null
): Promise<string> => {
  try {
    const response = await fetch('/api/mongodb?action=create-or-update-brand', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ assets, imageUrls, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to create or update brand record: ${response.statusText}`);
    }

    const result = await response.json();
    return result.brandId;
  } catch (error) {
    console.error('Failed to create or update brand record in database:', error);
    throw error;
  }
};

/**
 * Load complete assets from MongoDB
 */
export const loadCompleteAssetsFromDatabase = async (brandId: string): Promise<{
  assets: GeneratedAssets;
  generatedImages: Record<string, string>;
  generatedVideos: Record<string, string>;
  brandId: string;
}> => {
  console.log("DEBUG: Loading complete assets for brand ID:", brandId);
  
  try {
    // We'll need to make several API calls to get all the data
    // For now, we'll return a placeholder implementation
    // In a full implementation, this would fetch all brand data from MongoDB
    
    const response = await fetch('/api/mongodb/initial-load', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to load complete assets: ${response.statusText}`);
    }

    const result = await response.json();
    
    // Transform the result to match the expected format
    const assets: GeneratedAssets = {
      brandFoundation: result.brandKitData.brandFoundation,
      coreMediaAssets: result.brandKitData.coreMediaAssets,
      unifiedProfileAssets: result.brandKitData.unifiedProfileAssets,
      mediaPlans: [], // Will be populated later
      affiliateLinks: [], // Will be populated later
      personas: [], // Will be populated later
      trends: [], // Will be populated later
      ideas: [], // Will be populated later
    };
    
    const generatedImages: Record<string, string> = {};
    const generatedVideos: Record<string, string> = {};
    
    return { assets, generatedImages, generatedVideos, brandId };
  } catch (error) {
    console.error("Failed to load complete assets from database:", error);
    throw error;
  }
};

/**
 * Sync asset media with MongoDB
 */
export const syncAssetMediaWithDatabase = async (
  imageUrls: Record<string, string>,
  brandId: string,
  assets: GeneratedAssets
): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=sync-asset-media', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ imageUrls, brandId, assets }),
    });

    if (!response.ok) {
      throw new Error(`Failed to sync asset media: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Asset media synced successfully:', result);
  } catch (error) {
    console.error('Failed to sync asset media with database:', error);
    throw error;
  }
};

/**
 * Save affiliate links to MongoDB
 */
export const saveAffiliateLinksToDatabase = async (links: AffiliateLink[], brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-affiliate-links', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ links, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save affiliate links: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Affiliate links saved successfully:', result);
  } catch (error) {
    console.error('Failed to save affiliate links to database:', error);
    throw error;
  }
};

/**
 * Fetch affiliate links for brand from MongoDB
 */
export const fetchAffiliateLinksForBrandFromDatabase = async (brandId: string): Promise<AffiliateLink[]> => {
  try {
    const response = await fetch('/api/mongodb?action=fetch-affiliate-links', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch affiliate links: ${response.statusText}`);
    }

    const result = await response.json();
    return result.affiliateLinks;
  } catch (error) {
    console.error('Failed to fetch affiliate links from database:', error);
    throw error;
  }
};

/**
 * Delete affiliate link from MongoDB
 */
export const deleteAffiliateLinkFromDatabase = async (linkId: string, brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=delete-affiliate-link', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ linkId, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete affiliate link: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Affiliate link deleted successfully:', result);
  } catch (error) {
    console.error('Failed to delete affiliate link from database:', error);
    throw error;
  }
};

/**
 * Save persona to MongoDB
 */
export const savePersonaToDatabase = async (persona: Persona, brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-persona', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ persona, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save persona: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Persona saved successfully:', result);
  } catch (error) {
    console.error('Failed to save persona to database:', error);
    throw error;
  }
};

/**
 * Delete persona from MongoDB
 */
export const deletePersonaFromDatabase = async (personaId: string, brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=delete-persona', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ personaId, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete persona: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Persona deleted successfully:', result);
  } catch (error) {
    console.error('Failed to delete persona from database:', error);
    throw error;
  }
};

/**
 * Assign persona to plan in MongoDB
 */
export const assignPersonaToPlanInDatabase = async (
  planId: string,
  personaId: string | null,
  updatedPosts: MediaPlanPost[],
  brandId: string
): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=assign-persona-to-plan', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ planId, personaId, updatedPosts, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to assign persona to plan: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Persona assigned to plan successfully:', result);
  } catch (error) {
    console.error('Failed to assign persona to plan in database:', error);
    throw error;
  }
};

/**
 * Update media plan post in MongoDB
 */
export const updateMediaPlanPostInDatabase = async (
  post: MediaPlanPost,
  brandId: string,
  imageUrl?: string,
  videoUrl?: string
): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=update-media-plan-post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ post, brandId, imageUrl, videoUrl }),
    });

    if (!response.ok) {
      throw new Error(`Failed to update media plan post: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Media plan post updated successfully:', result);
  } catch (error) {
    console.error('Failed to update media plan post in database:', error);
    throw error;
  }
};

/**
 * Save media plan group to MongoDB
 */
export const saveMediaPlanGroupToDatabase = async (
  group: MediaPlanGroup,
  imageUrls: Record<string, string>,
  brandId: string
): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-media-plan-group', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ group, imageUrls, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save media plan group: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Media plan group saved successfully:', result);
  } catch (error) {
    console.error('Failed to save media plan group to database:', error);
    throw error;
  }
};

/**
 * Save trend to MongoDB
 */
export const saveTrendToDatabase = async (trend: Trend, brandId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-trend', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ trend, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save trend: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Trend saved successfully:', result);
  } catch (error) {
    console.error('Failed to save trend to database:', error);
    throw error;
  }
};

/**
 * Delete trend from MongoDB
 */
export const deleteTrendFromDatabase = async (trendId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=delete-trend', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ trendId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete trend: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Trend deleted successfully:', result);
  } catch (error) {
    console.error('Failed to delete trend from database:', error);
    throw error;
  }
};

/**
 * Save ideas to MongoDB
 */
export const saveIdeasToDatabase = async (ideas: Idea[]): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-ideas', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ ideas }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save ideas: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Ideas saved successfully:', result);
  } catch (error) {
    console.error('Failed to save ideas to database:', error);
    throw error;
  }
};

/**
 * Save AI service to MongoDB
 */
export const saveAIServiceToDatabase = async (service: { id: string; name: string; description: string }): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=save-ai-service', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ service }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save AI service: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('AI service saved successfully:', result);
  } catch (error) {
    console.error('Failed to save AI service to database:', error);
    throw error;
  }
};

/**
 * Delete AI service from MongoDB
 */
export const deleteAIServiceFromDatabase = async (serviceId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb?action=delete-ai-service', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ serviceId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete AI service: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('AI service deleted successfully:', result);
  } catch (error) {
    console.error('Failed to delete AI service from database:', error);
    throw error;
  }
};

/**
 * Save AI model to MongoDB
 */
export const saveAIModelToDatabase = async (model: { id: string; name: string; provider: string; capabilities: string[] }, serviceId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=save-ai-model', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ model, serviceId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save AI model: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('AI model saved successfully:', result);
  } catch (error) {
    console.error('Failed to save AI model to database:', error);
    throw error;
  }
};

/**
 * Delete AI model from MongoDB
 */
export const deleteAIModelFromDatabase = async (modelId: string): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=delete-ai-model', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ modelId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete AI model: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('AI model deleted successfully:', result);
  } catch (error) {
    console.error('Failed to delete AI model from database:', error);
    throw error;
  }
};

/**
 * Load AI services from MongoDB
 */
export const loadAIServicesFromDatabase = async (): Promise<AIService[]> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=load-ai-services', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      throw new Error(`Failed to load AI services: ${response.statusText}`);
    }

    const result = await response.json();
    return result.services;
  } catch (error) {
    console.error('Failed to load AI services from database:', error);
    throw error;
  }
};

/**
 * List media plan groups for brand from MongoDB
 */
export const listMediaPlanGroupsForBrandFromDatabase = async (brandId: string): Promise<{
  id: string;
  name: string;
  prompt: string;
  source?: MediaPlanGroup['source'];
  productImages?: { name: string; type: string; data: string }[];
  personaId?: string;
}[]> => {
  try {
    const response = await fetch('/api/mongodb/list-media-plan-groups', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to list media plan groups: ${response.statusText}`);
    }

    const result = await response.json();
    return result.groups;
  } catch (error) {
    console.error('Failed to list media plan groups from database:', error);
    throw error;
  }
};

/**
 * Load media plan from MongoDB
 */
export const loadMediaPlanFromDatabase = async (planId: string): Promise<{
  plan: MediaPlan;
  imageUrls: Record<string, string>;
  videoUrls: Record<string, string>;
}> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=load-media-plan', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ planId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to load media plan: ${response.statusText}`);
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Failed to load media plan from database:', error);
    throw error;
  }
};

/**
 * Bulk patch posts in MongoDB
 */
export const bulkPatchPostsInDatabase = async (updates: { postId: string; fields: Record<string, any> }[]): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=bulk-patch-posts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ updates }),
    });

    if (!response.ok) {
      throw new Error(`Failed to bulk patch posts: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Posts bulk patched successfully:', result);
  } catch (error) {
    console.error('Failed to bulk patch posts in database:', error);
    throw error;
  }
};

/**
 * Bulk update post schedules in MongoDB
 */
export const bulkUpdatePostSchedulesInDatabase = async (updates: { postId: string; scheduledAt: string; status: 'scheduled' }[]): Promise<void> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=bulk-update-post-schedules', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ updates }),
    });

    if (!response.ok) {
      throw new Error(`Failed to bulk update post schedules: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Post schedules bulk updated successfully:', result);
  } catch (error) {
    console.error('Failed to bulk update post schedules in database:', error);
    throw error;
  }
};

/**
 * List brands from MongoDB
 */
export const listBrandsFromDatabase = async (): Promise<{ id: string; name: string }[]> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=list-brands', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      throw new Error(`Failed to list brands: ${response.statusText}`);
    }

    const result = await response.json();
    return result.brands;
  } catch (error) {
    console.error('Failed to list brands from database:', error);
    throw error;
  }
};

/**
 * Check database credentials
 */
export const checkDatabaseCredentials = async (): Promise<boolean> => {
  try {
    const response = await fetch('/api/mongodb/[action]?action=check-credentials', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      console.error(`Failed to check database credentials: ${response.statusText}`);
      return false;
    }

    const result = await response.json();
    console.log('Database credentials verified:', result);
    return true;
  } catch (error) {
    console.error('Failed to check database credentials:', error);
    return false;
  }
};

/**
 * Load a complete project from MongoDB
 */
export const loadProjectFromDatabase = async (brandId: string): Promise<{
  assets: GeneratedAssets;
  generatedImages: Record<string, string>;
  generatedVideos: Record<string, string>;
  brandId: string;
}> => {
  try {
    console.log(`Loading complete project for brand ID: ${brandId}`);
    
    // Make an API call to load the complete project
    const response = await fetch('/api/mongodb/[action]?action=load-complete-project', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to load complete project: ${response.statusText}`);
    }

    const result = await response.json();
    console.log(`Loaded complete project for brand ID: ${brandId}`);
    return result;
  } catch (error) {
    console.error('Failed to load complete project from database:', error);
    throw error;
  }
};

// --- LEGACY FUNCTIONS FOR BACKWARD COMPATIBILITY ---
// These functions maintain the same names as the original Airtable functions
// but now call the new MongoDB-based implementations

export const fetchSettingsFromAirtable = fetchSettingsFromDatabase;
export const saveSettingsToAirtable = saveSettingsToDatabase;
export const fetchAdminDefaultsFromAirtable = fetchAdminDefaultsFromDatabase;
export const saveAdminDefaultsToAirtable = saveAdminDefaultsToDatabase;
export const createOrUpdateBrandRecord = createOrUpdateBrandRecordInDatabase;
export const loadCompleteAssets = loadCompleteAssetsFromDatabase;
export const syncAssetMedia = syncAssetMediaWithDatabase;
export const saveAffiliateLinks = saveAffiliateLinksToDatabase;
export const fetchAffiliateLinksForBrand = fetchAffiliateLinksForBrandFromDatabase;
export const deleteAffiliateLink = deleteAffiliateLinkFromDatabase;
export const savePersona = savePersonaToDatabase;
export const deletePersonaFromAirtable = deletePersonaFromDatabase;
export const assignPersonaToPlanInAirtable = assignPersonaToPlanInDatabase;
export const updateMediaPlanPostInAirtable = updateMediaPlanPostInDatabase;
export const saveMediaPlanGroup = saveMediaPlanGroupToDatabase;
export const saveTrend = saveTrendToDatabase;
export const deleteTrendFromAirtable = deleteTrendFromDatabase;
export const saveIdeas = saveIdeasToDatabase;
export const saveAIService = saveAIServiceToDatabase;
export const deleteAIService = deleteAIServiceFromDatabase;
export const saveAIModel = saveAIModelToDatabase;
export const deleteAIModel = deleteAIModelFromDatabase;
export const loadAIServices = loadAIServicesFromDatabase;
export const listMediaPlanGroupsForBrand = listMediaPlanGroupsForBrandFromDatabase;
export const loadMediaPlan = loadMediaPlanFromDatabase;
export const bulkPatchPosts = bulkPatchPostsInDatabase;
export const bulkUpdatePostSchedules = bulkUpdatePostSchedulesInDatabase;
export const listBrandsFromAirtable = listBrandsFromDatabase;
export const checkAirtableCredentials = checkDatabaseCredentials;
export const loadProjectFromAirtable = loadProjectFromDatabase;

/**
 * Check if a product exists in the database by its ID
 */
export const checkIfProductExistsInAirtable = async (productId: string): Promise<boolean> => {
  try {
    // This would typically make an API call to check if a product exists
    // For now, we'll implement a simple version that returns true
    // In a full implementation, this would check the database
    console.log(`Checking if product exists in database: ${productId}`);
    
    // Make an API call to check if the product exists
    const response = await fetch('/api/mongodb/[action]?action=check-product-exists', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ productId }),
    });

    if (!response.ok) {
      console.error(`Failed to check if product exists: ${response.statusText}`);
      return false;
    }

    const result = await response.json();
    return result.exists || false;
  } catch (error) {
    console.error('Failed to check if product exists in database:', error);
    return false;
  }
};

/**
 * Load ideas for a specific trend
 */
export const loadIdeasForTrend = async (trendId: string, brandId: string): Promise<Idea[]> => {
  try {
    console.log(`Loading ideas for trend ID: ${trendId} and brand ID: ${brandId}`);
    
    // Make an API call to load ideas for the trend
    const response = await fetch('/api/mongodb/[action]?action=load-ideas-for-trend', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ trendId, brandId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to load ideas for trend: ${response.statusText}`);
    }

    const result = await response.json();
    console.log(`Loaded ${result.ideas.length} ideas for trend ${trendId}`);
    return result.ideas;
  } catch (error) {
    console.error('Failed to load ideas for trend from database:', error);
    throw error;
  }
};

// --- NEW FUNCTIONS FOR OPTIMIZED LOADING ---

/**
 * Load initial project data for fast rendering of the BrandKitView
 */
export const loadInitialProjectData = async (brandId: string): Promise<{
  brandSummary: { id: string; name: string; logoUrl?: string };
  brandKitData: {
    brandFoundation: BrandFoundation;
    coreMediaAssets: CoreMediaAssets;
    unifiedProfileAssets: UnifiedProfileAssets;
  };
}> => {
  const response = await fetch('/api/mongodb/initial-load', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ brandId }),
  });

  if (!response.ok) {
    throw new Error(`Failed to load initial project data: ${response.statusText}`);
  }

  return await response.json();
};

/**
 * Load media plan groups list for the MediaPlanView
 */
export const loadMediaPlanGroupsList = async (brandId: string): Promise<{
  id: string;
  name: string;
  prompt: string;
  source?: MediaPlanGroup['source'];
  productImages?: { name: string; type: string; data: string }[];
  personaId?: string;
}[]> => {
  const response = await fetch('/api/mongodb/list-media-plan-groups', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ brandId }),
  });

  if (!response.ok) {
    throw new Error(`Failed to load media plan groups: ${response.statusText}`);
  }

  const { groups } = await response.json();
  return groups;
};

/**
 * Load strategy hub data (trends and ideas)
 */
export const loadStrategyHubData = async (brandId: string): Promise<{
  trends: Trend[];
  ideas: Idea[];
}> => {
  const response = await fetch('/api/mongodb/strategy-hub', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json',},
    body: JSON.stringify({ brandId }),
  });

  if (!response.ok) {
    throw new Error(`Failed to load strategy hub data: ${response.statusText}`);
  }

  return await response.json();
};

/**
 * Load affiliate vault data
 */
export const loadAffiliateVaultData = async (brandId: string): Promise<AffiliateLink[]> => {
  const response = await fetch('/api/mongodb/affiliate-vault', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ brandId }),
  });

  if (!response.ok) {
    throw new Error(`Failed to load affiliate vault data: ${response.statusText}`);
  }

  const { affiliateLinks } = await response.json();
  return affiliateLinks;
};

/**
 * Load personas data
 */
export const loadPersonasData = async (brandId: string): Promise<Persona[]> => {
  const response = await fetch('/api/mongodb/personas', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ brandId }),
  });

  if (!response.ok) {
    throw new Error(`Failed to load personas data: ${response.statusText}`);
  }

  const { personas } = await response.json();
  return personas;
};

/**
 * Load media plan posts with pagination
 * Note: This implementation is for MongoDB. When migrating from Airtable,
 * this should be updated to use proper database pagination for better performance.
 * @param offset - The number of records to skip
 * @param pageSize - The number of records to load
 * @param baseId - The MongoDB connection string (not used in this implementation)
 * @param tableId - The collection name (not used in this implementation)
 */
export const loadMediaPlanPostsWithPagination = async (
  offset: number,
  pageSize: number,
  baseId: string,
  tableId: string
) => {
  // This is a placeholder implementation
  // In a real implementation, this would fetch posts from MongoDB with pagination
  console.log(`Loading posts with offset: ${offset}, pageSize: ${pageSize}, baseId: ${baseId}, tableId: ${tableId}`);
  return { posts: [], total: 0 };
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\databaseService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\exportService.ts ---\n
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType, VerticalAlign, AlignmentType, BorderStyle, ShadingType } from 'docx';
import ExcelJS from 'exceljs';
import type { GeneratedAssets, ColorInfo, MediaPlan, MediaPlanGroup } from '../types';

const getTranslation = (language: string) => {
    const translations = {
        'Việt Nam': {
            // DOCX
            title: 'Bộ nhận diện Thương hiệu',
            brand_foundation: 'Nền tảng Thương hiệu',
            brand_name: 'Tên thương hiệu',
            mission: 'Sứ mệnh',
            usp: 'Điểm bán hàng độc nhất (USP)',
            values: 'Giá trị Cốt lõi',
            key_messaging: 'Thông điệp Chính',
            target_audience: 'Đối tượng Mục tiêu',
            personality: 'Tính cách Thương hiệu',
            core_media_assets: 'Tài sản Truyền thông Cốt lõi',
            logo_concepts: 'Ý tưởng Logo',
            logo_style: 'Phong cách',
            logo_prompt: 'Prompt',
            color_palette: 'Bảng màu',
            color_name: 'Tên màu',
            hex_code: 'Mã Hex',
            font_recs: 'Gợi ý Phông chữ',
            headlines: 'Tiêu đề',
            body: 'Nội dung',
            unified_profile_assets: 'Tài sản Hồ sơ Thống nhất',
            account_name: 'Tên tài khoản',
            username: 'Tên người dùng',
            profile_pic_prompt: 'Prompt Ảnh đại diện',
            cover_photo_concept: 'Ý tưởng Ảnh bìa',
            cover_photo_prompt: 'Prompt Ảnh bìa',
            // Media Plan XLSX
            sheet_media_plan: 'Kế hoạch Truyền thông',
            col_plan_name: 'Tên Kế hoạch',
            col_week: 'Tuần',
            col_theme: 'Chủ đề',
            col_platform: 'Nền tảng',
            col_content_type: 'Loại Nội dung',
            col_title: 'Tiêu đề',
            col_content: 'Nội dung',
            col_hashtags: 'Hashtags',
            col_cta: 'CTA',
            col_image_prompt: 'Prompt Ảnh',
            col_video_key: 'Video Key',
        },
        'English': {
            // DOCX
            title: 'Brand Kit',
            brand_foundation: 'Brand Foundation',
            brand_name: 'Brand Name',
            mission: 'Mission',
            usp: 'Unique Selling Proposition (USP)',
            values: 'Core Values',
            key_messaging: 'Key Messaging',
            target_audience: 'Target Audience',
            personality: 'Brand Personality',
            core_media_assets: 'Core Media Assets',
            logo_concepts: 'Logo Concepts',
            logo_style: 'Style',
            logo_prompt: 'Prompt',
            color_palette: 'Color Palette',
            color_name: 'Color Name',
            hex_code: 'Hex Code',
            font_recs: 'Font Recommendations',
            headlines: 'Headlines',
            body: 'Body',
            unified_profile_assets: 'Unified Profile Assets',
            account_name: 'Account Name',
            username: 'Username',
            profile_pic_prompt: 'Profile Picture Prompt',
            cover_photo_concept: 'Cover Photo Concept',
            cover_photo_prompt: 'Cover Photo Prompt',
             // Media Plan XLSX
            sheet_media_plan: 'Media Plan',
            col_plan_name: 'Plan Name',
            col_week: 'Week',
            col_theme: 'Theme',
            col_platform: 'Platform',
            col_content_type: 'Content Type',
            col_title: 'Title',
            col_content: 'Content',
            col_hashtags: 'Hashtags',
            col_cta: 'CTA',
            col_image_prompt: 'Image Prompt',
            col_video_key: 'Video Key',
        }
    };
    return (translations as any)[language] || translations['English'];
}

const createStyledParagraph = (text: string, bold: boolean = false) => new Paragraph({
    children: [new TextRun({ text, bold, font: "Calibri", size: 22 })],
    spacing: { after: 120 },
});

export const createDocxBlob = async (assets: GeneratedAssets, language: string): Promise<Blob> => {
    const T = getTranslation(language);
    const { brandFoundation, coreMediaAssets, unifiedProfileAssets } = assets;

    const children = [
        new Paragraph({ text: `${brandFoundation?.brandName || 'Brand'} - ${T.title}`, heading: HeadingLevel.TITLE, alignment: AlignmentType.CENTER }),

        new Paragraph({ text: T.brand_foundation, heading: HeadingLevel.HEADING_1 }),
        createStyledParagraph(`${T.brand_name}: ${brandFoundation?.brandName || ''}`, true),
        createStyledParagraph(`${T.mission}: ${brandFoundation?.mission || ''}`),
        createStyledParagraph(`${T.usp}: ${brandFoundation?.usp || ''}`),
        createStyledParagraph(`${T.target_audience}: ${brandFoundation?.targetAudience || ''}`),
        createStyledParagraph(`${T.personality}: ${brandFoundation?.personality || ''}`),
        createStyledParagraph(`${T.values}:`, true),
        ...(brandFoundation?.values || []).map(v => createStyledParagraph(`- ${v}`)),
        createStyledParagraph(`${T.key_messaging}:`, true),
        ...(brandFoundation?.keyMessaging || []).map(m => createStyledParagraph(`- ${m}`)),
        
        new Paragraph({ text: T.core_media_assets, heading: HeadingLevel.HEADING_1 }),
        new Paragraph({ text: T.logo_concepts, heading: HeadingLevel.HEADING_2 }),
        ...(coreMediaAssets?.logoConcepts || []).flatMap(logo => [
            createStyledParagraph(`${T.logo_style}: ${logo.style}`, true),
            createStyledParagraph(`${T.logo_prompt}: ${logo.prompt}`),
        ]),
        new Paragraph({ text: T.color_palette, heading: HeadingLevel.HEADING_2 }),
        new Table({
            rows: [
                new TableRow({
                    children: [new TableCell({ children: [createStyledParagraph(T.color_name, true)] }), new TableCell({ children: [createStyledParagraph(T.hex_code, true)] })],
                }),
                ...Object.values(coreMediaAssets?.colorPalette || {}).map(color => new TableRow({
                    children: [new TableCell({ children: [createStyledParagraph((color as ColorInfo)?.name || '')] }), new TableCell({ children: [createStyledParagraph((color as ColorInfo)?.hex || '')] })],
                }))
            ],
            width: { size: 100, type: WidthType.PERCENTAGE }
        }),
        new Paragraph({ text: T.font_recs, heading: HeadingLevel.HEADING_2 }),
        createStyledParagraph(`${T.headlines}: ${coreMediaAssets?.fontRecommendations?.headlines?.name || ''} ${coreMediaAssets?.fontRecommendations?.headlines?.weight || ''}`),
        createStyledParagraph(`${T.body}: ${coreMediaAssets?.fontRecommendations?.body?.name || ''} ${coreMediaAssets?.fontRecommendations?.body?.weight || ''}`),

        new Paragraph({ text: T.unified_profile_assets, heading: HeadingLevel.HEADING_1 }),
        createStyledParagraph(`${T.account_name}: ${unifiedProfileAssets?.accountName || ''}`, true),
        createStyledParagraph(`${T.username}: ${unifiedProfileAssets?.username || ''}`),
        createStyledParagraph(`${T.profile_pic_prompt}: ${unifiedProfileAssets?.profilePicturePrompt || ''}`),
        createStyledParagraph(`${T.cover_photo_concept}: ${unifiedProfileAssets?.coverPhoto?.designConcept || ''}`, true),
        createStyledParagraph(`${T.cover_photo_prompt}: ${unifiedProfileAssets?.coverPhoto?.prompt || ''}`),
    ];

    const doc = new Document({
        sections: [{ children }],
        styles: {
            default: {
                heading1: { run: { size: 32, bold: true, color: "2E2E2E" } },
                heading2: { run: { size: 28, bold: true, color: "4F46E5" } },
            }
        }
    });

    const blob = await Packer.toBlob(doc);
    return blob;
};

export const createMediaPlanXlsxBlob = async (mediaPlans: MediaPlanGroup[], language: string): Promise<Blob> => {
    const T = getTranslation(language);
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'SocialSync Pro';
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet(T.sheet_media_plan);

    worksheet.columns = [
        { header: T.col_plan_name, key: 'planName', width: 30 },
        { header: T.col_week, key: 'week', width: 10 },
        { header: T.col_theme, key: 'theme', width: 30 },
        { header: T.col_platform, key: 'platform', width: 15 },
        { header: T.col_content_type, key: 'contentType', width: 20 },
        { header: T.col_title, key: 'title', width: 40 },
        { header: T.col_content, key: 'content', width: 60 },
        { header: T.col_hashtags, key: 'hashtags', width: 40 },
        { header: T.col_cta, key: 'cta', width: 20 },
        { header: T.col_image_prompt, key: 'imagePrompt', width: 60 },
        { header: T.col_video_key, key: 'videoKey', width: 60 },
    ];

    worksheet.getRow(1).font = { bold: true };

    (mediaPlans || []).forEach(group => {
        (group.plan || []).forEach(week => {
            (week.posts || []).forEach(post => {
                worksheet.addRow({
                    planName: group.name,
                    week: week.week,
                    theme: week.theme,
                    platform: post.platform,
                    contentType: post.contentType,
                    title: post.title,
                    content: post.content,
                    hashtags: (post.hashtags || []).join(', '),
                    cta: post.cta,
                    imagePrompt: post.imagePrompt || '',
                    videoKey: post.videoKey || ''
                });
            });
        });
    });

    const buffer = await workbook.xlsx.writeBuffer();
    return new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\exportService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\facebookService.ts ---\nimport type { MediaPlanPost, FacebookLoginResponse, FacebookPage } from '../types';
import { publishToFacebookWithBff } from './bffService';

declare const FB: any; // Declare the FB object from the SDK

// Logs the user in and gets their pages
export const connectAndGetPageToken = async (): Promise<FacebookLoginResponse> => {
    if (typeof FB === 'undefined' || !FB.login) {
        throw new Error("Facebook SDK is not available or initialized. Please wait a moment and try again.");
    }
    
    return new Promise((resolve, reject) => {
        // Enforce HTTPS. The FB SDK throws an error if called from http.
        if (window.location.protocol !== 'https:') {
            // Updated error message to be more helpful for developers.
            return reject(new Error('Facebook Login requires a secure (HTTPS) connection. To test this feature, please run your development server over HTTPS or use a tunneling service like ngrok.'));
        }

        FB.login((response: any) => {
            if (response.authResponse) {
                console.log('Facebook login successful:', response);
                const userAccessToken = response.authResponse.accessToken;

                // Get user's pages
                FB.api('/me/accounts', { access_token: userAccessToken }, (pageResponse: any) => {
                    console.log("Raw Facebook /me/accounts response:", pageResponse);
                    if (pageResponse && !pageResponse.error) {
                        if (pageResponse.data && pageResponse.data.length > 0) {
                            const pages: FacebookPage[] = pageResponse.data.map((page: any) => ({
                                id: page.id,
                                name: page.name,
                                access_token: page.access_token,
                                category: page.category,
                                category_list: page.category_list,
                                tasks: page.tasks,
                            }));
                            resolve({
                                userAccessToken,
                                pages,
                            });
                        } else {
                            reject(new Error("No Facebook Pages found for this account with the granted permissions. Please try connecting again and ensure you grant access to the Facebook Pages you wish to manage."));
                        }
                    } else {
                        reject(new Error(pageResponse.error?.message || "Failed to fetch Facebook pages."));
                    }
                });
            } else {
                reject(new Error('User cancelled login or did not fully authorize.'));
            }
        }, { scope: 'pages_show_list,pages_read_engagement,pages_manage_posts' });
    });
};

// Publishes to the page using the Graph API
export const publishToFacebookPage = async (
    post: MediaPlanPost,
    imageUrl: string | undefined,
    pageId: string,
    accessToken: string,
    videoUrl?: string
): Promise<{ publishedUrl: string }> => {
    console.log("publishToFacebookPage received args:", { post, imageUrl, pageId, accessToken: accessToken ? '[REDACTED]' : '[MISSING]', videoUrl });
    
    // Use BFF exclusively for secure Facebook publishing
    return await publishToFacebookWithBff(post, imageUrl, pageId, accessToken, videoUrl);
};;\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\facebookService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts ---\nimport { GoogleGenAI, Type, GenerateContentResponse } from "@google/genai";
import { generateContentWithBff, generateImageWithBff } from './bffService';
import type { BrandInfo, GeneratedAssets, MediaPlan, BrandFoundation, MediaPlanGroup, MediaPlanPost, AffiliateLink, Persona, Trend, Idea, FacebookTrend, FacebookPostIdea } from '../types';

export const sanitizeAndParseJson = (jsonText: string) => {
    // This function attempts to fix common JSON errors produced by AI models.
    if (!jsonText) {
        throw new Error("Received empty JSON string from AI.");
    }

    let sanitized = jsonText.trim();

    // First, try to parse the JSON as is - if it works, return it immediately
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        // If it fails, continue with sanitization
    }

    // Remove any markdown code block markers if present
    const markdownMatch = sanitized.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (markdownMatch && markdownMatch[1]) {
        sanitized = markdownMatch[1];
    }

    // The single-line comment removal was removed because it was corrupting
    // base64 strings in image generation which can contain "//".
    // The AI models should be trusted to return valid JSON when requested.

    // 2. Fix for observed error: `... ,"=value" ...` which should be `... ,"value" ...`
    // This regex looks for a comma or opening bracket, optional whitespace,
    // then the erroneous `="` followed by a string, and a closing `"`.
    // It reconstructs it as a valid JSON string.
    sanitized = sanitized.replace(/([,[\]\s*=\s*"([^"]*)"/g, '$1"$2"');

    // 3. Fix for Pinterest posts generating "infographicContent" instead of "content".
    sanitized = sanitized.replace(/"infographicContent":/g, '"content":');
    
    // 4. Fix for hashtags missing an opening quote, e.g., [... , #tag"] or [#tag"]
    // This looks for a comma/bracket followed by whitespace, then a #, then captures the tag content, and the closing quote.
    // It then reconstructs it with the opening quote.
    sanitized = sanitized.replace(/([,[\]\s*)#([^\"]+)(")/g, '$1"#$2$3');

    // 5. Removed risky unescaped quote sanitizer. Relying on responseMimeType: "application/json".
    // sanitized = sanitized.replace(/(?<![[\]{\s:,])"(?![\]s,}\]:])/g, '"');

    // 6. Remove trailing commas, which are valid in JS but not in strict JSON.
    // e.g., `{"key":"value",}` or `["item1",]`
    sanitized = sanitized.replace(/,(\s*[}\]])/g, '$1');
    
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        console.error("Failed to parse AI JSON response for product-based ideas:", jsonText);
        throw new Error("The AI returned a malformed or unexpected response. This may be a temporary issue with the model. Please try again later or configure a different model in Settings.");
    }
};

export const normalizeMediaPlanGroupResponse = (data: any): { name: string; plan: MediaPlan } => {
    if (!data) throw new Error("Invalid or empty data provided to normalizeMediaPlanGroupResponse.");

    let effectiveData = data;
    let name = '';
    let plan: MediaPlan = [];

    // Handle wrapped responses (e.g., from OpenRouter models)
    if (data.result && typeof data.result === 'object') {
        effectiveData = data.result;
    }

    // Extract name if present at the root level
    if (effectiveData.name && typeof effectiveData.name === 'string') {
        name = effectiveData.name;
    }

    // Try to find the plan array in various possible locations
    if (Array.isArray(effectiveData)) {
        // If the root is an array, assume it's the plan
        plan = effectiveData;
    } else if (typeof effectiveData === 'object') {
        // Check for common keys that might contain the plan
        const possiblePlanKeys = ['plan', 'weeks', 'mediaPlan'];
        for (const key of possiblePlanKeys) {
            if (effectiveData[key] && Array.isArray(effectiveData[key])) {
                plan = effectiveData[key];
                break;
            }
        }

        // Also check for nested structures
        if (effectiveData.plan && typeof effectiveData.plan === 'object' && !Array.isArray(effectiveData.plan)) {
            if (effectiveData.plan.name) name = effectiveData.plan.name;
            const possibleNestedKeys = ['weeks', 'mediaPlan'];
            for (const key of possibleNestedKeys) {
                if (effectiveData.plan[key] && Array.isArray(effectiveData.plan[key])) {
                    plan = effectiveData.plan[key];
                    break;
                }
            }
        }
    }

    if (!Array.isArray(plan)) {
        console.warn("Could not find a valid 'plan' or 'weeks' array in the AI response.", data); // Log original data for debugging
    }
    
    return { name: name || 'Untitled Plan', plan };
};

export const normalizePillarContent = (data: any): Omit<MediaPlanPost, 'id'|'platform'|'status'|'isPillar'> => {
    if (!data || typeof data !== 'object') {
        throw new Error("Invalid data for pillar content normalization.");
    }
    
    const pillarPost = { ...data };

    // Handle cases where the AI returns a structured array for 'content'.
    if (Array.isArray(pillarPost.content)) {
        pillarPost.content = (pillarPost.content as { section?: string, script?: string }[])
            .map(part => `${part.section ? `## ${part.section}\
\
` : ''}${part.script || ''}`)
            .join('\n\n');
    }

    // Handle cases where the AI returns a string for 'hashtags'.
    if (typeof pillarPost.hashtags === 'string') {
        pillarPost.hashtags = pillarPost.hashtags.split(/[, ]+/) 
            .map((h: string) => h.trim())
            .filter(Boolean)
            .map((h: string) => h.startsWith('#') ? h : `#${h}`);
    } else if (!Array.isArray(pillarPost.hashtags)) {
        pillarPost.hashtags = [];
    }
    
    return pillarPost;
};

export const normalizeArrayResponse = <T>(data: any, keyHint: string): T[] => {
    if (!data) return [];
    if (Array.isArray(data)) return data as T[];

    if (typeof data === 'object' && data !== null) {
        // First try the specific hint
        if (data[keyHint] && Array.isArray(data[keyHint])) {
            return data[keyHint] as T[];
        }
        // Then try a generic hint
        const genericHint = `${keyHint}s`; // e.g., idea -> ideas, post -> posts
        if (data[genericHint] && Array.isArray(data[genericHint])) {
            return data[genericHint] as T[];
        }
        // Fallback: find the first key that holds an array
        const arrayKey = Object.keys(data).find(key => Array.isArray(data[key]));
        if (arrayKey) {
            return data[arrayKey] as T[];
        }

        // NEW FALLBACK: If all else fails and we have a non-array object, wrap it in an array.
        // This handles cases where the AI was supposed to return an array but returned a single object instead.
        if (Object.keys(data).length > 0) { // Ensure it's not an empty object {}
             return [data as T];
        }
    }
    
    console.warn(`Could not find a valid array in the response with hint "${keyHint}".`, data);
    return [];
};


export const geminiFetchWithRetry = async <T extends GenerateContentResponse>(apiCall: () => Promise<T>, retries = 3, initialDelay = 2000): Promise<T> => {
    let lastError: Error | null = null;
    let delay = initialDelay;

    for (let i = 0; i < retries; i++) {
        try {
            const result = await apiCall();
            console.log("Raw Gemini API response (result object):", result);
            if (result.candidates && result.candidates.length > 0) {
                console.log("Gemini candidate content:", result.candidates[0].content);
            }
            window.dispatchEvent(new CustomEvent('rateLimitWaitClear'));
            return result;
        } catch (e: any) {
            lastError = e;
            if (e.message && (e.message.includes('RESOURCE_EXHAUSTED') || e.message.includes('429'))) {
                 console.warn(`Gemini API rate limit hit. Retrying in ${delay / 1000}s... (Attempt ${i + 1}/${retries})`);
                 window.dispatchEvent(new CustomEvent('rateLimitWait', { 
                     detail: { service: 'Gemini', seconds: delay / 1000, attempt: i + 1, total: retries } 
                 }));
                 await new Promise(res => setTimeout(res, delay));
                 delay *= 2;
                 continue;
            } else {
                throw e;
            }
        }
    }
    
    window.dispatchEvent(new CustomEvent('rateLimitWaitClear'));
    throw new Error(`Gemini API request failed after ${retries} attempts. Last error: ${lastError?.message}`);
};

const colorInfoSchema = {
    type: Type.OBJECT,
    properties: {
        name: { type: Type.STRING },
        hex: { type: Type.STRING },
    },
    required: ['name', 'hex']
};

const brandInfoSchema = {
    type: Type.OBJECT,
    properties: {
        name: { type: Type.STRING, description: "A creative and fitting brand name." },
        mission: { type: Type.STRING, description: "A powerful, one-sentence mission statement." },
        values: { type: Type.STRING, description: "A comma-separated string of 4-5 core brand values." },
        audience: { type: Type.STRING, description: "A brief description of the target audience." },
        personality: { type: Type.STRING, description: "3-4 keywords describing the brand's personality." },
    },
    required: ['name', 'mission', 'values', 'audience', 'personality']
};


const mediaPlanSchema = {
    type: Type.ARRAY,
    description: "A 4-week media plan.",
    items: {
        type: Type.OBJECT,
        properties: {
            week: { type: Type.INTEGER },
            theme: { type: Type.STRING },
            posts: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        platform: { type: Type.STRING, description: "Platform for the post. Must be one of: 'YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest'." },
                        contentType: { type: Type.STRING },
                        title: { type: Type.STRING },
                        content: { type: Type.STRING },
                        hashtags: { type: Type.ARRAY, items: { type: Type.STRING } },
                        cta: { type: Type.STRING },
                        mediaPrompt: {
                            oneOf: [
                                { type: Type.STRING },
                                { type: Type.ARRAY, items: { type: Type.STRING } }
                            ],
                            description: "A detailed prompt for the media content. Can be a string or an array of strings for carousels."
                        }, 
                        script: { type: Type.STRING, description: "A detailed script for video content." }
                    },
                    required: ['platform', 'contentType', 'title', 'content', 'hashtags', 'cta', 'mediaPrompt']
                }
            }
        },
        required: ['week', 'theme', 'posts']
    }
};

const brandKitResponseSchema = {
  type: Type.OBJECT,
  properties: {
    brandFoundation: {
      type: Type.OBJECT,
      properties: {
        brandName: { type: Type.STRING },
        mission: { type: Type.STRING },
        values: { type: Type.ARRAY, items: { type: Type.STRING } },
        targetAudience: { type: Type.STRING },
        personality: { type: Type.STRING },
        keyMessaging: { type: Type.ARRAY, items: { type: Type.STRING } },
        usp: { type: Type.STRING },
      },
      required: ['brandName', 'mission', 'values', 'targetAudience', 'personality', 'keyMessaging', 'usp']
    },
    coreMediaAssets: {
      type: Type.OBJECT,
      properties: {
        logoConcepts: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              style: { type: Type.STRING },
              prompt: { type: Type.STRING },
            },
            required: ['style', 'prompt']
          },
        },
        colorPalette: {
          type: Type.OBJECT,
          properties: {
            primary: colorInfoSchema,
            secondary: colorInfoSchema,
            accent: colorInfoSchema,
            text: colorInfoSchema,
          },
          required: ['primary', 'secondary', 'accent', 'text']
        },
        fontRecommendations: {
          type: Type.OBJECT,
          properties: {
            headlines: { type: Type.OBJECT, properties: { name: { type: Type.STRING }, weight: { type: Type.STRING } } },
            body: { type: Type.OBJECT, properties: { name: { type: Type.STRING }, weight: { type: Type.STRING } } },
          },
          required: ['headlines', 'body']
        },
      },
      required: ['logoConcepts', 'colorPalette', 'fontRecommendations']
    },
    unifiedProfileAssets: {
      type: Type.OBJECT,
      properties: {
        accountName: { type: Type.STRING },
        username: { type: Type.STRING },
        profilePicturePrompt: { type: Type.STRING },
        coverPhoto: {
          type: Type.OBJECT,
          properties: {
            prompt: { type: Type.STRING },
            designConcept: { type: Type.STRING },
          },
          required: ['prompt', 'designConcept']
        },
      },
      required: ['accountName', 'username', 'profilePicturePrompt', 'coverPhoto']
    },
    mediaPlan: mediaPlanSchema,
  },
  required: ['brandFoundation', 'coreMediaAssets', 'unifiedProfileAssets', 'mediaPlan']
};

export const refinePostContentWithGemini = async (postText: string, model: string): Promise<string> => {
    // Use BFF for content generation to keep API keys secure
    const prompt = `You are a world-class social media copywriter. Refine the following post content to maximize engagement and impact, while preserving its core message. The output should ONLY be the refined text, without any introductory phrases, explanations, or quotes.

Original content:
"""${postText}"""`;

    return await generateContentWithBff(model, prompt);
};

export const generateBrandProfile = async (idea: string, language: string, model: string): Promise<BrandInfo> => {
    // Use BFF for content generation to keep API keys secure
    const prompt = `
You are an expert brand strategist. Based on the user's business idea, generate a concise and compelling brand profile IN ${language}.
Business Idea:
"${idea}"

Generate a JSON object with the following fields in ${language}:
- name: A creative and fitting brand name.
- mission: A powerful, one-sentence mission statement.
- values: A comma-separated string of 4-5 core brand values.
- audience: A brief description of the target audience.
- personality: 3-4 keywords describing the brand's personality.
`;
    // console.log("Prompt for generateBrandProfile:", prompt);
    
    const jsonText = await generateContentWithBff(model, prompt);
    if (!jsonText) throw new Error("Received empty response from AI.");
    return sanitizeAndParseJson(jsonText) as BrandInfo;
};

export const generateBrandKit = async (brandInfo: BrandInfo, language: string, model: string): Promise<Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'>> => {
    const prompt = `
You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a complete and professional set of branding and social media assets IN ${language}, based on the user's input.

Brand Input (in ${language}):
- Brand Name: ${brandInfo.name}
- Brand Mission: ${brandInfo.mission}
- Brand Values: ${brandInfo.values}
- Target Audience: ${brandInfo.audience}
- Brand Personality: ${brandInfo.personality}

Generate the following assets IN ${language}:
1.  **Brand Foundation**
: Summarize the core identity. All subsequent generations must be perfectly aligned with this foundation.
2.  **Core Media Assets**
: Create logo concepts (prompts for an image generation model), a 4-color palette, and font recommendations. Logo prompts must be in English.
3.  **Unified Profile Assets**
: Create a single set of assets for use across all platforms (account name, username, profile picture prompt, cover photo prompt). Image prompts must be in English.
4.  **Initial 1-Month Media Plan**
: Generate a 4-week media plan designed for a brand launch. It should have a clear theme for each week. Create 4 posts per week, distributed across YouTube, Facebook, Instagram, TikTok, and Pinterest. For each post, provide a detailed, English media prompt appropriate for the content type (e.g., image prompt, video script, carousel prompts). For video content, provide a separate 'script' field. The 'content' field should always be the post caption.
`;
    const jsonText = await generateContentWithBff(
        model,
        prompt,
        { responseMimeType: "application/json", responseSchema: brandKitResponseSchema }
    );
    const parsedJson = sanitizeAndParseJson(jsonText);

    if (!parsedJson.brandFoundation || !parsedJson.coreMediaAssets || !parsedJson.unifiedProfileAssets || (!parsedJson.mediaPlan && !parsedJson.initial1MonthMediaPlan)) {
        console.error("AI response is missing one or more root keys. Parsed JSON:", parsedJson);
        throw new Error("The AI returned a JSON object with a missing or incorrect structure. Please try again.");
    }
    
    if (parsedJson.coreMediaAssets?.logoConcepts) {
        parsedJson.coreMediaAssets.logoConcepts = parsedJson.coreMediaAssets.logoConcepts.map((logo: any) => {
            const logoId = crypto.randomUUID();
            return {
                ...logo,
                id: logoId,
                imageKey: `logo_${logoId}`
            };
        });
    }
    if (parsedJson.unifiedProfileAssets) {
        const profilePictureId = crypto.randomUUID();
        parsedJson.unifiedProfileAssets.profilePictureId = profilePictureId;
        parsedJson.unifiedProfileAssets.profilePictureImageKey = `profile_${profilePictureId}`;
        
        const coverPhotoId = crypto.randomUUID();
        parsedJson.unifiedProfileAssets.coverPhotoId = coverPhotoId;
        parsedJson.unifiedProfileAssets.coverPhotoImageKey = `cover_${coverPhotoId}`;
    }

    let mediaPlanGroup: MediaPlanGroup | null = null;
    if (parsedJson.mediaPlan) {
        const planWithIds: MediaPlan = (parsedJson.mediaPlan as any[]).map(week => ({
            ...week,
            posts: (week.posts || []).map((post: any) => {
                const postId = crypto.randomUUID();
                const { status, ...restOfPost } = post;
                return {
                    ...restOfPost,
                    id: postId,
                    imageKey: post.mediaPrompt ? `media_plan_post_${postId}` : undefined,
                    status: 'draft',
                } as MediaPlanPost;
            }),
        }));
        
        mediaPlanGroup = {
            id: crypto.randomUUID(),
            name: language === 'Việt Nam' ? 'Kế hoạch Ra mắt Thương hiệu' : 'Brand Launch Plan',
            prompt: language === 'Việt Nam' ? 'Kế hoạch ban đầu được tạo cho việc ra mắt thương hiệu.' : 'Initial plan generated for brand launch.',
            plan: planWithIds,
            source: 'brand-launch',
        };
    }
    
    const assets: Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'> = {
        brandFoundation: parsedJson.brandFoundation,
        coreMediaAssets: parsedJson.coreMediaAssets,
        unifiedProfileAssets: parsedJson.unifiedProfileAssets,
        mediaPlans: mediaPlanGroup ? [mediaPlanGroup] : [],
    };
    return assets;
};

export const generateMediaPlanGroup = async (
    brandFoundation: BrandFoundation,
    userPrompt: string,
    language: string,
    totalPosts: number,
    useSearch: boolean,
    selectedPlatforms: string[],
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    affiliateContentKitSystemInstruction: string,
    model: string,
    persona: Persona | null,
    selectedProduct: AffiliateLink | null
): Promise<MediaPlanGroup> => {
    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC. They are the face of this campaign.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description (for media generation):** ${persona.outfitDescription}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Media Prompts (VERY IMPORTANT):** For any post that requires an image, the 'mediaPrompt' MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona.outfitDescription}, [description of the scene]".
` : '';

    const prompt = `You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a 1-Month Media Plan IN ${language} based on the provided Brand Foundation and User Goal.
The output must be a single, valid JSON object that strictly adheres to the provided schema. Do not add any commentary or text outside of the JSON structure.

**Brand Foundation (Use this as your guide):**
- Brand Name: ${brandFoundation.brandName}
- Mission: ${brandFoundation.mission}
- USP: ${brandFoundation.usp}
- Values: ${(brandFoundation.values || []).join(', ')}
- Target Audience: ${brandFoundation.targetAudience}
- Personality: ${brandFoundation.personality}

${personaInstruction}

**User's Goal for the Plan:**
"${userPrompt}"

**Content Customization Instructions:**
- **Tone of Voice**
: Generate all content with a '${options.tone}' tone.
- **Writing Style**
: The primary style should be '${options.style}'.
- **Post Length**
: Adhere to a '${options.length}' post length. For example, 'Short' is suitable for Instagram captions (2-4 sentences), 'Medium' for Facebook (1-2 paragraphs), and 'Long' could be a detailed script or a mini-blog post.
- **Emojis**
: ${options.includeEmojis ? "Use emojis appropriately to enhance engagement and match the brand personality." : "Do not use any emojis."}

Based on the Brand Foundation, User's Goal, and Customization Instructions, generate a complete 4-week media plan group.
- **Name**
: First, create a short, descriptive title for this entire plan based on the User's Goal (e.g., "Q3 Product Launch", "Summer Eco-Friendly Campaign").
- **Plan Structure**
: The plan must have 4 weekly objects. Each week must have a clear 'theme' (e.g., "Week 1: Brand Introduction & Values").
- **Content**
: The entire 4-week plan must contain a total of approximately ${totalPosts} posts, distributed logically across the 4 weeks. The number of posts per week can vary if it makes thematic sense, but the total must be close to ${totalPosts}. The posts should be distributed *only* across the following selected platforms: ${selectedPlatforms.join(', ')}. Do not generate content for any other platform not in this list.
- **Post Details (CRITICAL):
    -   **contentType**: e.g., "Image Post", "Video Idea", "Story", "Carousel Post", "Shorts Idea".
    -   **content**: This is ALWAYS the user-facing text caption for the post.
    -   **script**: For video contentTypes ("Video Idea", "Shorts Idea", "Story"), this field MUST contain the video script, storyboard, or detailed scene-by-scene description. For non-video posts, this should be null.
    -   **mediaPrompt**: This is the prompt for the visual media. It MUST be in English.
        -   For "Image Post": A single, detailed DALL-E prompt to generate the image.
        -   For "Video Idea", "Shorts Idea", "Story": A concise, one-paragraph summary of the visual concept, suitable for a text-to-video model.
        -   For "Carousel Post": An array of detailed, English DALL-E prompts, one for each image in the carousel (2-5 prompts).
- **Consistency**
: The entire media plan must be thematically consistent with the Brand Foundation.
`;

    const config: any = {
        systemInstruction: affiliateContentKitSystemInstruction,
    };
    if (useSearch) {
        config.tools = [{googleSearch: {}}];
    } else {
        config.responseMimeType = "application/json";
        config.responseSchema = mediaPlanSchema;
    }

    const jsonText = await generateContentWithBff(model, prompt, config);
    
    let extractedJson = jsonText.trim();
    if (useSearch) {
        const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
        if (markdownMatch && markdownMatch[1]) {
            extractedJson = markdownMatch[1];
        } else {
            // Find the first valid JSON object.
            const startIndex = extractedJson.indexOf('{');
            if (startIndex !== -1) {
                let balance = 0;
                let endIndex = -1;
                for (let i = startIndex; i < extractedJson.length; i++) {
                    if (extractedJson[i] === '{') balance++;
                    else if (extractedJson[i] === '}') balance--;
                    if (balance === 0) {
                        endIndex = i;
                        break;
                    }
                }
                if (endIndex !== -1) {
                    extractedJson = extractedJson.substring(startIndex, endIndex + 1);
                }
            }
        }
    }

    const parsedResult = sanitizeAndParseJson(extractedJson);
    const { name: planName, plan: planWeeks } = normalizeMediaPlanGroupResponse(parsedResult);

    const planWithEnhancements = (planWeeks || []).map(week => ({
        ...week,
        posts: (week.posts || []).map((post: any) => {
            const { status, ...restOfPost } = post;
            return {
                ...restOfPost,
                id: crypto.randomUUID(),
                status: 'draft',
                promotedProductIds: selectedProduct ? [selectedProduct.id] : [],
            } as MediaPlanPost;
        }),
    }));

    return {
        id: crypto.randomUUID(),
        name: (planName && planName !== 'Untitled Plan') ? planName : (selectedProduct ? `Promotion Plan: ${selectedProduct.productName}` : userPrompt.substring(0, 30)),
        prompt: userPrompt,
        plan: planWithEnhancements,
        source: 'wizard',
        sources: [], // This would need to be implemented if grounding metadata is needed
        personaId: persona?.id,
    };
};


export const generateImage = async (
    prompt: string,
    promptSuffix: string,
    model: string,
    aspectRatio: "1:1" | "16:9" = "1:1",
    productImages: File[] = []
): Promise<string> => {
    // Use BFF for image generation to keep API keys secure
    const fullPrompt = `${prompt}${promptSuffix ? `, ${promptSuffix}` : ''}`;
    
    return await generateImageWithBff(model, fullPrompt, {
        numberOfImages: 1,
        outputMimeType: 'image/jpeg',
        aspectRatio: aspectRatio,
    });
};

export const generateMediaPromptForPost = async (
    postContent: { title: string; content: string, contentType: string },
    brandFoundation: BrandFoundation,
    language: string,
    model: string,
    persona: Persona | null,
    mediaPromptSuffix: string
): Promise<string | string[]> => {
    const personaInstruction = persona ? `
The media MUST feature the following persona:
- Nickname: ${persona.nickName}
- Main Style: ${persona.mainStyle}
- Field of Activity: ${persona.activityField}
- Detailed Description: ${persona.outfitDescription}

IMPORTANT: For image prompts, the prompt you generate MUST start with the exact "Detailed Description" provided above, followed by a comma, then the scene description. The structure must be: "${persona.outfitDescription}, [description of the scene]"
` : '';

    let prompt = `
You are a creative visual director for the brand "${brandFoundation.brandName}".
The brand's personality is: ${brandFoundation.personality}.
${personaInstruction}
Based on the following social media post content (in ${language}), generate a detailed and compelling media prompt.
The prompt MUST BE IN ENGLISH.
Do not add any explanations, labels, or extra text. Output ONLY the prompt.

Post Title: "${postContent.title}"
Post Content: "${postContent.content}"
`;

    switch (postContent.contentType) {
        case 'Image Post':
            prompt += `Generate a single, detailed DALL-E prompt to generate the image.`
            break
        case 'Video Idea':
        case 'Shorts Idea':
        case 'Story':
            prompt += `Generate a concise, one-paragraph summary of the visual concept, suitable for a text-to-video model.`
            break
        case 'Carousel Post':
            prompt += `Generate an array of detailed, English DALL-E prompts, one for each image in the carousel (2-5 prompts). The output should be a JSON array of strings.`
            break
        default:
            prompt += `Generate a single, detailed DALL-E prompt to generate the image.`
            break
    }

    const response = await generateContentWithBff(model, prompt);
    const textResponse = response;

    if (postContent.contentType === 'Carousel Post') {
        try {
            const parsedResponse = JSON.parse(textResponse);
            // For carousel posts, append suffix to each prompt in the array
            if (Array.isArray(parsedResponse)) {
                return parsedResponse.map((prompt: string) => prompt + mediaPromptSuffix);
            }
        } catch (e) {
            console.error("Failed to parse carousel prompts, returning as single string:", textResponse);
            return textResponse;
        }
    }

    // For single prompts, append the suffix
    return textResponse + mediaPromptSuffix;
};


// NgoSiLien - Enhanced Affiliate Comment Generation
// This function generates engaging comments for social media posts that promote affiliate products.
// It dynamically includes available product information like ratings, sales volume, and customer reviews
// to make the comments more appealing and encourage clicks on the affiliate links.
export const generateAffiliateComment = async (
    post: MediaPlanPost,
    products: AffiliateLink[],
    brandFoundation: BrandFoundation,
    language: string,
    model: string
): Promise<string> => {
     if (products.length === 0) {
        throw new Error("Cannot generate a comment without at least one affiliate product.");
    }
    
    const formatProductDetails = (p: AffiliateLink) => {
        const details = [`- Product Name: ${p.productName}`];
        
        // Add price
        details.push(`  - Price: ${p.price}`);
        
        // Add product rating if available
        if (p.product_rating !== undefined && p.product_rating !== null) {
            details.push(`  - Rating: ${p.product_rating}/5`);
        }
        
        // Add sales volume if available
        if (p.salesVolume > 0) {
            details.push(`  - Sales Volume: ${p.salesVolume}`);
        }
        
        // Add customer reviews if available
        if (p.customer_reviews && p.customer_reviews.trim() !== '') {
            // If customer_reviews contains multiple reviews, we'll extract the best one
            // For now, we'll just use the provided reviews as is
            details.push(`  - Customer Reviews: ${p.customer_reviews}`);
        }
        
        // Always add the promotion link (or product link as fallback)
        details.push(`  - Product Link: ${p.promotionLink || p.productLink}`);
        
        return details.join('\n');
    };

    const productDetails = products.map(formatProductDetails).join('\n');

    const prompt = `
You are the creator who wrote the social media post. Your task is to write a follow-up comment on your own post, from your perspective as the post author. This simulates you posting content and then engaging with your own post to promote affiliate products.

**Primary Goal:** Write a natural, human-like comment that subtly promotes one or more affiliate products related to your post. The comment must encourage clicks on the affiliate link while sounding like a genuine self-comment on your own post.

**Rules:**
1.  **Natural Tone:** The comment must sound like you're genuinely engaging with your own content. It should match the tone of the original post and sound like a real person talking to their audience. Avoid overly salesy language.
2.  **Two-Part Structure:** The comment MUST consist of two parts, separated by a blank line:
    *   **Part 1 (Caption):** A short, engaging caption. This caption must cleverly connect your original post's topic with the product(s) being promoted. It should add value, share a personal tip about how you use the product, or ask a question to spark conversation and make people curious about the link. If product details like ratings, sales volume, or customer reviews are provided, you should naturally incorporate these details to make the product more appealing.
    *   **Part 2 (Links):** The affiliate link(s) for the product(s). If there is more than one product, list each link on a new line. Do not add any text before or after the links in this part.
3.  **Language:** The entire comment MUST be in ${language}.

**Original Post Content:**
- Title: ${post.title}
- Content: ${post.content}

**Affiliate Product(s) to Promote:**
${productDetails}

**Example Output:**
Tôi vừa thử em này sau khi làm theo hướng dẫn trong bài và thấy hiệu quả bất ngờ! Bạn nào muốn thử thì xem link bên dưới nha.

https://your-affiliate-link.com

---
Now, generate the comment based on the provided post and product d...`;
    
    return await generateContentWithBff(model, prompt);
};

export const generateViralIdeas = async (
    trend: { topic: string; keywords: string[] },
    language: string,
    useSearch: boolean,
    model: string
): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    let prompt = `You are a viral marketing expert and a world-class creative strategist.
Your task is to generate 5 highly engaging and potentially viral content ideas based on a given topic and related keywords.
The ideas must be in ${language}.
Each idea must have:
1.  A catchy, curiosity-driven 'title'.
2.  A short but comprehensive 'description' of the idea.
3.  A specific 'targetAudience' that this idea would appeal to.

Topic: "${trend.topic}"
Keywords: ${trend.keywords.join(', ')}
`;
    const ideasSchema = {
        type: Type.ARRAY,
        items: {
            type: Type.OBJECT,
            properties: {
                title: { type: Type.STRING },
                description: { type: Type.STRING },
                targetAudience: { type: Type.STRING },
            },
            required: ['title', 'description', 'targetAudience'],
        },
    };

    const config: any = {};
    if (useSearch) {
        config.tools = [{googleSearch: {}}];
        prompt += '\n\nYour response MUST be a valid JSON array of objects. Do not include any text or markdown formatting before or after the JSON array.';
    } else {
        config.responseMimeType = "application/json";
        config.responseSchema = ideasSchema;
    }

    const jsonText = await generateContentWithBff(model, prompt, config);
    
    let extractedJson = jsonText.trim();
    if (useSearch) {
        const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
        if (markdownMatch && markdownMatch[1]) {
            extractedJson = markdownMatch[1];
        } else {
            const startIndex = extractedJson.indexOf('[');
            if (startIndex !== -1) {
                let balance = 0;
                let endIndex = -1;
                for (let i = startIndex; i < extractedJson.length; i++) {
                    if (extractedJson[i] === '[') balance++;
                    else if (extractedJson[i] === ']') balance--;
                    if (balance === 0) {
                        endIndex = i;
                        break;
                    }
                }
                if (endIndex !== -1) {
                    extractedJson = extractedJson.substring(startIndex, endIndex + 1);
                }
            }
        }
    }
    
    // Fix malformed JSON responses that are missing array brackets
    let fixedJsonText = extractedJson.trim();
    if (fixedJsonText.startsWith('{')) {
        fixedJsonText = `[${fixedJsonText}]`;
    }

    return sanitizeAndParseJson(fixedJsonText);
};

export const generateContentPackage = async (
    idea: Idea,
    brandFoundation: BrandFoundation,
    language: string,
    affiliateContentKit: string,
    model: string,
    persona: Persona | null,
    pillarPlatform: 'YouTube',
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    selectedProduct: AffiliateLink | null
): Promise<MediaPlanGroup> => {

    
    // Validate selectedProduct
    console.log('Selected product for content package:', selectedProduct);

    if (selectedProduct && !selectedProduct.id) {
        selectedProduct = null;
        console.log('Invalid selectedProduct provided. Resetting to null.');
    }
    
    // const pillarPlatform = 'YouTube';
    
    // Sanitize user inputs to prevent prompt injection
    const sanitizedIdeaTitle = idea.title.replace(/[\"\`\;]+/g, '') || 'N/A';
    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC.
- **Nickname:** ${persona.nickName.replace(/[\"\`\;]+/g, '') || 'N/A'}
- **Main Style:** ${persona.mainStyle.replace(/[\"\`\;]+/g, '') || 'N/A'}
- **Field of Activity:** ${persona.activityField.replace(/[\"\`\;]+/g, '') || 'N/A'}
- **Detailed Description (for image generation):** ${persona.outfitDescription.replace(/[\"\`\;]+/g, '') || 'N/A'}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Image Prompts (VERY IMPORTANT):** Every single 'mediaPrompt' value you generate MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona?.outfitDescription || 'N/A'}, [description of the scene]". For example: "${persona?.outfitDescription || 'N/A'}, unboxing a product in a minimalist apartment...".
` : '';

    const productInstruction = selectedProduct ? `
**Affiliate Product to Feature (Crucial):**
- **Product Name:** ${selectedProduct.productName || 'N/A'}
- **Product ID:** ${selectedProduct.id || 'N/A'}
- **Instruction:** This entire content package is designed to subtly promote this specific product. All generated posts (both pillar and repurposed) MUST be related to this product and its benefits. For every single post you generate, you MUST include a 'promotedProductIds' field in the JSON object, and its value MUST be an array containing the string "${selectedProduct.id || 'N/A'}".
` : '';

    const customizationInstruction = `
**Content Customization Instructions:**
- **Tone of Voice**: Generate all content with a '${options.tone}' tone.
- **Writing Style**: The primary style should be '${options.style}'.
- **Post Length**: Adhere to a '${options.length}' post length.
- **Include Emojis**: ${options.includeEmojis ? 'Yes' : 'No'}
`;

    // Get all platforms
    const allPlatforms: ('YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest')[] = ['YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest'];
    const repurposedPlatforms = allPlatforms.filter(p => p !== pillarPlatform);

    // Single comprehensive prompt with media prompt generation
    const combinedPrompt = `
    ${personaInstruction}
    ${productInstruction}
    ${customizationInstruction}
    Based on the idea "${sanitizedIdeaTitle}", create a comprehensive content package including:

    1. PILLAR CONTENT FOR ${pillarPlatform}:
    Create a detailed, authoritative piece for ${pillarPlatform} that provides significant value to the target audience: ${idea.targetAudience || 'N/A'}.
    - If ${pillarPlatform} is YouTube, provide a detailed video script and a separate, SEO-optimized 'description' for the YouTube description box.
    - If ${pillarPlatform} is Facebook, provide a long-form, engaging post like a mini-article.
    - If ${pillarPlatform} is Instagram, provide a detailed multi-slide carousel post concept, including content for each slide and a main caption.
    - If ${pillarPlatform} is Pinterest, provide a concept for a detailed infographic or a guide pin, including all text content needed.
    - If ${pillarPlatform} is TikTok, provide a script for a multi-part (2-3 videos) series.

    2. REPURPOSED CONTENT FOR OTHER PLATFORMS: ${repurposedPlatforms.join(', ')}
    Repurpose the core message into one smaller, standalone post for EACH of the following platforms: ${repurposedPlatforms.join(', ')}.
    Each new piece must be completely rewritten and tailored for its specific platform's format and audience.
    - For short-form video platforms (TikTok, Instagram), create a concise video script or reel idea.
    - For image-based platforms (Instagram, Pinterest), create a compelling caption for an image or carousel.
    - For text-based platforms (Facebook), create an engaging post that summarizes or expands on a key point from the pillar content.
    - If the pillar content is a long text post and you need to generate a YouTube idea, create a script outline for a short video based on the text.

    3. MEDIA PROMPTS
    For EACH generated post (both pillar and repurposed), generate a media prompt that:
    - MUST start with the persona's "Detailed Description": "${persona?.outfitDescription || 'N/A'},"
    - Followed by a comma and then a description of the scene
    - Be highly specific and visually descriptive
    - Match the content's theme and the platform's style
    - Align with the persona's style and tone

    The output MUST be a JSON object with:
    {
      "pillarContent": {
        "title": "string",
        "content": "string",
        "description"?: "string",  // Only for YouTube
        "hashtags": "string[]",
        "cta": "string",
        "mediaPrompt": "string"  // New field for media prompt
      },
      "repurposedContents": [
        {
          "platform": "string",  // Must be one of ${repurposedPlatforms.join(', ')}
          "contentType": "string",
          "title": "string",
          "content": "string",
          "hashtags": "string[]",
          "cta": "string",
          "mediaPrompt": "string"  // New field for media prompt
        }
      ]
    }
    Language: ${language}.
    `;

    try {
        // Single API call for all content and media prompt generation
        const response = await generateContentWithBff(
            model,
            combinedPrompt,
            { systemInstruction: affiliateContentKit, responseMimeType: 'application/json' }
        );

        const rawResponse = sanitizeAndParseJson(response);
        
        // Extract and validate pillar content with media prompt
        if (!rawResponse.pillarContent) {
            throw new Error('Missing pillar content in API response');
        }

        const pillarPost = {
            title: rawResponse.pillarContent.title || 'Untitled',
            content: rawResponse.pillarContent.content || '',
            ...(rawResponse.pillarContent.description && { description: rawResponse.pillarContent.description }),
            hashtags: Array.isArray(rawResponse.pillarContent.hashtags) ? 
                rawResponse.pillarContent.hashtags : 
                (typeof rawResponse.pillarContent.hashtags === 'string' ? [rawResponse.pillarContent.hashtags] : []),
            cta: rawResponse.pillarContent.cta || '',
            mediaPrompt: rawResponse.pillarContent.mediaPrompt || '',
            platform: pillarPlatform,
            isPillar: true,
        };

        // Extract and validate repurposed contents with media prompts
        if (!Array.isArray(rawResponse.repurposedContents)) {
            throw new Error('Missing repurposed contents in API response');
        }

        const repurposedPosts = rawResponse.repurposedContents
            .filter((content: any) => repurposedPlatforms.includes(content.platform))
            .map((content: any) => ({
                title: content.title || 'Untitled',
                content: content.content || '',
                contentType: content.contentType || 'text',
                hashtags: Array.isArray(content.hashtags) ? 
                    content.hashtags : 
                    (typeof content.hashtags === 'string' ? [content.hashtags] : []),
                cta: content.cta || '',
                mediaPrompt: content.mediaPrompt || '',
                platform: content.platform,
                isPillar: false,
            }));

        // Combine all posts
        const allPosts: Omit<MediaPlanPost, 'id'|'status'>[] = [
            pillarPost,
            ...repurposedPosts
        ];

        // Final posts with metadata
        const finalPosts = allPosts.map(p => ({
            ...p,
            id: crypto.randomUUID(),
            status: 'draft',
            promotedProductIds: (selectedProduct && selectedProduct.id) ? [selectedProduct.id] : [],
        } as MediaPlanPost));

        // Create plan structure
        const plan: MediaPlan = [{
            week: 1,
            theme: `Content Package: ${sanitizedIdeaTitle}`,
            posts: finalPosts
        }];

        // Return the media plan group
        return {
            id: crypto.randomUUID(),
            name: sanitizedIdeaTitle,
            prompt: idea.description || 'N/A',
            plan: plan,
            source: 'content-package',
            personaId: persona?.id || null,
        };

    } catch (error) {
        throw new Error(`Failed to generate content package: ${error.message}`);
    }
};

// --- NEW FACEBOOK STRATEGY FUNCTIONS ---

export const generateFacebookTrends = async (
    industry: string,
    language: string,
    model: string
): Promise<Omit<FacebookTrend, 'id'|'brandId'>[]> => {
    const prompt = `You are a Facebook marketing expert. Analyze Google Search results for the query "trending topics and content formats in ${industry} on Facebook for ${language}".
Identify 3-5 distinct, current trends. For each trend, provide:
1.  A concise 'topic'.
2.  An array of relevant 'keywords'.
3.  A brief 'analysis' explaining why it's trending for the target audience on Facebook and what content formats (e.g., Reels, Carousels, Long-form posts) are performing best.
4.  The top 3 most relevant 'links' from the search results that support your analysis. Each link must be an object with "uri" and "title" keys.

Your response must be a single, valid JSON array of objects. Each object should have the keys: "topic", "keywords", "analysis", and "links". Do not add any text or explanation before or after the JSON array.`;

    const jsonText = await generateContentWithBff(
        model,
        prompt,
        {
            tools: [{googleSearch: {}}],
        }
    );
    
    let extractedJson = jsonText.trim();
    const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
    if (markdownMatch && markdownMatch[1]) {
        extractedJson = markdownMatch[1];
    } else {
        const startIndex = extractedJson.indexOf('[');
        if (startIndex !== -1) {
            let balance = 0;
            let endIndex = -1;
            // A simple bracket counter. Not perfect for strings with brackets, but better than a greedy lastIndexOf.
            for (let i = startIndex; i < extractedJson.length; i++) {
                if (extractedJson[i] === '[') {
                    balance++;
                } else if (extractedJson[i] === ']') {
                    balance--;
                }
                if (balance === 0) {
                    endIndex = i;
                    break;
                }
            }
            if (endIndex !== -1) {
                extractedJson = extractedJson.substring(startIndex, endIndex + 1);
            }
        }
    }

    const trendsData = sanitizeAndParseJson(extractedJson);
    return (trendsData || []).map((trend: any) => ({ ...trend, createdAt: new Date().toISOString() }));
};

export const generatePostsForFacebookTrend = async (
    trend: FacebookTrend,
    language: string,
    model: string
): Promise<Omit<FacebookPostIdea, 'id' | 'trendId'>[]> => {
    const prompt = `You are a creative Facebook content strategist. Based on the following trend, generate 5 engaging Facebook post ideas in ${language}.
For each idea, provide:
1.  A catchy 'title'.
2.  The main 'content' for the post, optimized for Facebook's platform.
3.  A detailed English 'mediaPrompt' for an accompanying visual.
4.  A strong 'cta' (call to action).

Trend Topic: "${trend.topic}"
Trend Keywords: ${trend.keywords.join(', ')}
Trend Analysis: ${trend.analysis}
`;
    const postsSchema = {
        type: Type.ARRAY,
        items: {
            type: Type.OBJECT,
            properties: {
                title: { type: Type.STRING },
                content: { type: Type.STRING },
                mediaPrompt: { type: Type.STRING },
                cta: { type: Type.STRING },
            },
            required: ['title', 'content', 'mediaPrompt', 'cta'],
        },
    };

    const jsonText = await generateContentWithBff(
        model,
        prompt,
        {
            responseMimeType: "application/json",
            responseSchema: postsSchema,
        }
    );
    
    return sanitizeAndParseJson(jsonText);
};

// --- NEW FUNCTION FOR GENERATING CONTENT IDEAS FROM A PRODUCT ---

export const generateIdeasFromProduct = async (
    product: AffiliateLink,
    language: string,
    model: string
): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    // Build a detailed product description
    const productDetails = [
        `Product Name: ${product.productName}`,
        `Product ID: ${product.productId}`,
        `Price: ${product.price}`,
        `Provider: ${product.providerName}`,
        `Commission Rate: ${product.commissionRate}%`,
        `Commission Value: ${product.commissionValue}`,
        product.product_description ? `Description: ${product.product_description}` : '',
        product.features && product.features.length > 0 ? `Features: ${product.features.join(', ')}` : '',
        product.use_cases && product.use_cases.length > 0 ? `Use Cases: ${product.use_cases.join(', ')}` : '',
        product.customer_reviews ? `Customer Reviews: ${product.customer_reviews}` : '',
        product.product_rating ? `Product Rating: ${product.product_rating}/5` : ''
    ].filter(Boolean).join('\n');
    
    const prompt = `You are a creative marketing strategist. Based on the following affiliate product details, generate 5 unique and engaging content ideas in ${language} that can be used to promote this product effectively.

For each idea, provide:
1.  A catchy 'title' that would grab attention.
2.  A detailed 'description' explaining the concept and how it would showcase the product.
3.  A specific 'targetAudience' that this idea would appeal to.

Product Details:
${productDetails}

Make sure each idea is distinct and highlights different aspects of the product. Consider various content formats like tutorials, reviews, comparisons, lifestyle content, unboxings, etc.
`;

    const ideasSchema = {
        type: Type.ARRAY,
        items: {
            type: Type.OBJECT,
            properties: {
                title: { type: Type.STRING },
                description: { type: Type.STRING },
                targetAudience: { type: Type.STRING },
            },
            required: ['title', 'description', 'targetAudience'],
        },
    };

    const jsonText = await generateContentWithBff(
        model,
        prompt,
        {
            responseMimeType: "application/json",
            responseSchema: ideasSchema,
        }
    );
    
    if (!jsonText) {
        console.warn("Received empty response from AI when generating ideas from product. Returning empty array.");
        return [];
    }

    let ideas = sanitizeAndParseJson(jsonText);
    
    if (ideas && typeof ideas === 'object' && !Array.isArray(ideas) && ideas.ideas) {
        ideas = ideas.ideas;
    }
    
    if (ideas && typeof ideas === 'object' && !Array.isArray(ideas) && ideas.title) {
        ideas = [ideas];
    }
    
    if (!Array.isArray(ideas)) {
        throw new Error("Expected an array of ideas, but received: " + JSON.stringify(ideas));
    }
    
    for (let i = 0; i < ideas.length; i++) {
        const idea = ideas[i];
        if (!idea.title || !idea.description || !idea.targetAudience) {
            throw new Error(`Idea at index ${i} is missing required fields.`);
        }
    }
    
    return ideas.map((idea: any) => ({
        ...idea,
        productId: product.id
    }));
};

// Platform-specific purposes from user requirements
const facebookPurpose = "Leverage community and sharing features to create discussion and provide a direct path to your main video. Create compelling short clips, thought-provoking quote graphics, or key highlights that spark conversation in comments and encourage shares. Caption should act as a hook, introducing the problem/main idea and directing users to 'click the link to watch the full video'.";

const instagramPurpose = "Capture immediate visual attention and generate curiosity through aesthetically pleasing, bite-sized content. Create visually striking Reels with dynamic 60-90 second clips, trending audio, or informative carousel posts that break down key tips. Primary goal is to be a 'scroll-stopper' that provides instant value and directs users to the 'link in bio' for deeper content.";

const tiktokPurpose = "Hijack attention within the first three seconds with high-energy, trend-centric, easily digestible video clips. Extract the most surprising fact, controversial point, or quickest 'hack' to create an 'information gap' or emotional reaction that drives viewers to your profile to find the YouTube channel link for the complete breakdown.";

const pinterestPurpose = "Create long-lasting, searchable resources that funnel users seeking solutions or inspiration. Convert core message into vertical Idea Pins or infographics with keyword-rich titles (e.g., 'How to Achieve X in 5 Easy Steps'). Serve as a visual bookmark solving part of the user's problem, with a direct outbound link to the YouTube video.";
\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts.temp ---\n



import { GoogleGenAI, Type, GenerateContentResponse } from "@google/genai";
import type { BrandInfo, GeneratedAssets, MediaPlan, BrandFoundation, MediaPlanGroup, MediaPlanPost, AffiliateLink, Persona, Trend, Idea, FacebookTrend, FacebookPostIdea } from '../types';

export const sanitizeAndParseJson = (jsonText: string) => {
    // This function attempts to fix common JSON errors produced by AI models.
    if (!jsonText) {
        throw new Error("Received empty JSON string from AI.");
    }

    let sanitized = jsonText;

    // The single-line comment removal was removed because it was corrupting
    // base64 strings in image generation which can contain "//".
    // The AI models should be trusted to return valid JSON when requested.

    // 2. Fix for observed error: `... ,"=value" ...` which should be `... ,"value" ...`
    // This regex looks for a comma or opening bracket, optional whitespace,
    // then the erroneous `="` followed by a string, and a closing `"`.
    // It reconstructs it as a valid JSON string.
    sanitized = sanitized.replace(/([,\[])\s*=\s*"([^"]*)"/g, '$1"$2"');

    // 3. Fix for Pinterest posts generating "infographicContent" instead of "content".
    sanitized = sanitized.replace(/"infographicContent":/g, '"content":');
    
    // 4. Fix for hashtags missing an opening quote, e.g., [... , #tag"] or [#tag"]
    // This looks for a comma/bracket followed by whitespace, then a #, then captures the tag content, and the closing quote.
    // It then reconstructs it with the opening quote.
    sanitized = sanitized.replace(/([\[,]\s*)#([^"]+)(")/g, '$1"#$2$3');

    // 5. Removed risky unescaped quote sanitizer. Relying on responseMimeType: "application/json".
    // sanitized = sanitized.replace(/(?<![\[\{\s:,])"(?![\s,}\]:])/g, '\\"');

    // 6. Remove trailing commas, which are valid in JS but not in strict JSON.
    // e.g., `{"key":"value",}` or `["item1",]`
    sanitized = sanitized.replace(/,(\s*[}\]])/g, '$1');
    
    try {
        return JSON.parse(sanitized);
    } catch (e) {
        console.error("Failed to parse sanitized AI JSON response:", sanitized);
        console.error("Original text was:", jsonText);
        throw e; // rethrow the original error after logging
    }
};

export const normalizeMediaPlanGroupResponse = (data: any): { name: string; plan: MediaPlan } => {
    if (!data) throw new Error("Invalid or empty data provided to normalizeMediaPlanGroupResponse.");

    let name = data.name;
    let plan = data.plan;

    // Handle nested structures like { "plan": { "name": "...", "weeks": [...] } }
    if (data.plan && typeof data.plan === 'object' && !Array.isArray(data.plan)) {
        if (data.plan.name) name = data.plan.name;
        if (data.plan.weeks && Array.isArray(data.plan.weeks)) {
            plan = data.plan.weeks;
        }
    }

    if (!Array.isArray(plan)) {
        console.warn("Could not find a valid 'plan' or 'weeks' array in the AI response.", data);
        plan = [];
    }
    
    return { name: name || 'Untitled Plan', plan };
};

export const normalizePillarContent = (data: any): Omit<MediaPlanPost, 'id'|'platform'|'status'|'isPillar'> => {
    if (!data || typeof data !== 'object') {
        throw new Error("Invalid data for pillar content normalization.");
    }
    
    const pillarPost = { ...data };

    // Handle cases where the AI returns a structured array for 'content'.
    if (Array.isArray(pillarPost.content)) {
        pillarPost.content = (pillarPost.content as { section?: string, script?: string }[])
            .map(part => `${part.section ? `## ${part.section}\n\n` : ''}${part.script || ''}`)
            .join('\n\n');
    }

    // Handle cases where the AI returns a string for 'hashtags'.
    if (typeof pillarPost.hashtags === 'string') {
        pillarPost.hashtags = pillarPost.hashtags.split(/[, ]+/)
            .map((h: string) => h.trim())
            .filter(Boolean)
            .map((h: string) => h.startsWith('#') ? h : `#${h}`);
    } else if (!Array.isArray(pillarPost.hashtags)) {
        pillarPost.hashtags = [];
    }
    
    return pillarPost;
};

export const normalizeArrayResponse = <T>(data: any, keyHint: string): T[] => {
    if (!data) return [];
    if (Array.isArray(data)) return data as T[];

    if (typeof data === 'object' && data !== null) {
        // First try the specific hint
        if (data[keyHint] && Array.isArray(data[keyHint])) {
            return data[keyHint] as T[];
        }
        // Then try a generic hint
        const genericHint = `${keyHint}s`; // e.g., idea -> ideas, post -> posts
        if (data[genericHint] && Array.isArray(data[genericHint])) {
            return data[genericHint] as T[];
        }
        // Fallback: find the first key that holds an array
        const arrayKey = Object.keys(data).find(key => Array.isArray(data[key]));
        if (arrayKey) {
            return data[arrayKey] as T[];
        }

        // NEW FALLBACK: If all else fails and we have a non-array object, wrap it in an array.
        // This handles cases where the AI was supposed to return an array but returned a single object instead.
        if (Object.keys(data).length > 0) { // Ensure it's not an empty object {}
             return [data as T];
        }
    }
    
    console.warn(`Could not find a valid array in the response with hint "${keyHint}".`, data);
    return [];
};


export const geminiFetchWithRetry = async <T extends GenerateContentResponse>(apiCall: () => Promise<T>, retries = 3, initialDelay = 2000): Promise<T> => {
    let lastError: Error | null = null;
    let delay = initialDelay;

    for (let i = 0; i < retries; i++) {
        try {
            const result = await apiCall();
            window.dispatchEvent(new CustomEvent('rateLimitWaitClear'));
            return result;
        } catch (e: any) {
            lastError = e;
            if (e.message && (e.message.includes('RESOURCE_EXHAUSTED') || e.message.includes('429'))) {
                 console.warn(`Gemini API rate limit hit. Retrying in ${delay / 1000}s... (Attempt ${i + 1}/${retries})`);
                 window.dispatchEvent(new CustomEvent('rateLimitWait', { 
                     detail: { service: 'Gemini', seconds: delay / 1000, attempt: i + 1, total: retries } 
                 }));
                 await new Promise(res => setTimeout(res, delay));
                 delay *= 2;
                 continue;
            } else {
                throw e;
            }
        }
    }
    
    window.dispatchEvent(new CustomEvent('rateLimitWaitClear'));
    throw new Error(`Gemini API request failed after ${retries} attempts. Last error: ${lastError?.message}`);
};

const colorInfoSchema = {
    type: Type.OBJECT,
    properties: {
        name: { type: Type.STRING },
        hex: { type: Type.STRING },
    },
    required: ['name', 'hex']
};

const brandInfoSchema = {
    type: Type.OBJECT,
    properties: {
        name: { type: Type.STRING, description: "A creative and fitting brand name." },
        mission: { type: Type.STRING, description: "A powerful, one-sentence mission statement." },
        values: { type: Type.STRING, description: "A comma-separated string of 4-5 core brand values." },
        audience: { type: Type.STRING, description: "A brief description of the target audience." },
        personality: { type: Type.STRING, description: "3-4 keywords describing the brand's personality." },
    },
    required: ['name', 'mission', 'values', 'audience', 'personality']
};


const mediaPlanSchema = {
    type: Type.ARRAY,
    description: "A 4-week media plan.",
    items: {
        type: Type.OBJECT,
        properties: {
            week: { type: Type.INTEGER },
            theme: { type: Type.STRING },
            posts: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        platform: { type: Type.STRING, description: "Platform for the post. Must be one of: 'YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest'." },
                        contentType: { type: Type.STRING },
                        title: { type: Type.STRING },
                        content: { type: Type.STRING },
                        hashtags: { type: Type.ARRAY, items: { type: Type.STRING } },
                        cta: { type: Type.STRING },
                        imagePrompt: { type: Type.STRING, description: "A detailed prompt in English for an image generation model." }
                    },
                    required: ['platform', 'contentType', 'title', 'content', 'hashtags', 'cta', 'imagePrompt']
                }
            }
        },
        required: ['week', 'theme', 'posts']
    }
};

const brandKitResponseSchema = {
  type: Type.OBJECT,
  properties: {
    brandFoundation: {
      type: Type.OBJECT,
      properties: {
        brandName: { type: Type.STRING },
        mission: { type: Type.STRING },
        values: { type: Type.ARRAY, items: { type: Type.STRING } },
        targetAudience: { type: Type.STRING },
        personality: { type: Type.STRING },
        keyMessaging: { type: Type.ARRAY, items: { type: Type.STRING } },
        usp: { type: Type.STRING },
      },
      required: ['brandName', 'mission', 'values', 'targetAudience', 'personality', 'keyMessaging', 'usp']
    },
    coreMediaAssets: {
      type: Type.OBJECT,
      properties: {
        logoConcepts: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              style: { type: Type.STRING },
              prompt: { type: Type.STRING },
            },
            required: ['style', 'prompt']
          },
        },
        colorPalette: {
          type: Type.OBJECT,
          properties: {
            primary: colorInfoSchema,
            secondary: colorInfoSchema,
            accent: colorInfoSchema,
            text: colorInfoSchema,
          },
          required: ['primary', 'secondary', 'accent', 'text']
        },
        fontRecommendations: {
          type: Type.OBJECT,
          properties: {
            headlines: { type: Type.OBJECT, properties: { name: { type: Type.STRING }, weight: { type: Type.STRING } } },
            body: { type: Type.OBJECT, properties: { name: { type: Type.STRING }, weight: { type: Type.STRING } } },
          },
          required: ['headlines', 'body']
        },
      },
      required: ['logoConcepts', 'colorPalette', 'fontRecommendations']
    },
    unifiedProfileAssets: {
      type: Type.OBJECT,
      properties: {
        accountName: { type: Type.STRING },
        username: { type: Type.STRING },
        profilePicturePrompt: { type: Type.STRING },
        coverPhoto: {
          type: Type.OBJECT,
          properties: {
            prompt: { type: Type.STRING },
            designConcept: { type: Type.STRING },
          },
          required: ['prompt', 'designConcept']
        },
      },
      required: ['accountName', 'username', 'profilePicturePrompt', 'coverPhoto']
    },
    mediaPlan: mediaPlanSchema,
  },
  required: ['brandFoundation', 'coreMediaAssets', 'unifiedProfileAssets', 'mediaPlan']
};

export const refinePostContentWithGemini = async (postText: string, model: string): Promise<string> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const prompt = `You are a world-class social media copywriter. Refine the following post content to maximize engagement and impact, while preserving its core message. The output should ONLY be the refined text, without any introductory phrases, explanations, or quotes.

Original content:
"""${postText}"""`;

    const response = await ai.models.generateContent({
        model: model,
        contents: prompt,
    });
    return response.text;
};

export const generateBrandProfile = async (idea: string, language: string, model: string): Promise<BrandInfo> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const prompt = `
You are an expert brand strategist. Based on the user's business idea, generate a concise and compelling brand profile IN ${language}.
Business Idea:
"${idea}"

Generate a JSON object with the following fields in ${language}:
- name: A creative and fitting brand name.
- mission: A powerful, one-sentence mission statement.
- values: A comma-separated string of 4-5 core brand values.
- audience: A brief description of the target audience.
- personality: 3-4 keywords describing the brand's personality.
`;
    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: brandInfoSchema }
        })
    );
    const jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI.");
    return sanitizeAndParseJson(jsonText) as BrandInfo;
};

export const generateBrandKit = async (brandInfo: BrandInfo, language: string, model: string): Promise<Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'>> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
     const prompt = `
You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a complete and professional set of branding and social media assets IN ${language}, based on the user's input.

Brand Input (in ${language}):
- Brand Name: ${brandInfo.name}
- Brand Mission: ${brandInfo.mission}
- Brand Values: ${brandInfo.values}
- Target Audience: ${brandInfo.audience}
- Brand Personality: ${brandInfo.personality}

Generate the following assets IN ${language}:
1.  **Brand Foundation**: Summarize the core identity. All subsequent generations must be perfectly aligned with this foundation.
2.  **Core Media Assets**: Create logo concepts (prompts for an image generation model), a 4-color palette, and font recommendations. Logo prompts must be in English.
3.  **Unified Profile Assets**: Create a single set of assets for use across all platforms (account name, username, profile picture prompt, cover photo prompt). Image prompts must be in English.
4.  **Initial 1-Month Media Plan**: Generate a 4-week media plan designed for a brand launch. It should have a clear theme for each week. Create 4 posts per week, distributed across YouTube, Facebook, Instagram, TikTok, and Pinterest. Ensure every post includes a detailed, English image prompt.
`;
    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: brandKitResponseSchema }
        })
    );
    const jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI.");
    const parsedJson = sanitizeAndParseJson(jsonText);

    if (!parsedJson.brandFoundation || !parsedJson.coreMediaAssets || !parsedJson.unifiedProfileAssets || !parsedJson.mediaPlan) {
        console.error("AI response is missing one or more root keys. Parsed JSON:", parsedJson);
        throw new Error("The AI returned a JSON object with a missing or incorrect structure. Please try again.");
    }
    
    if (parsedJson.coreMediaAssets?.logoConcepts) {
        parsedJson.coreMediaAssets.logoConcepts = parsedJson.coreMediaAssets.logoConcepts.map((logo: any) => {
            const logoId = crypto.randomUUID();
            return {
                ...logo,
                id: logoId,
                imageKey: `logo_${logoId}`
            };
        });
    }
    if (parsedJson.unifiedProfileAssets) {
        const profilePictureId = crypto.randomUUID();
        parsedJson.unifiedProfileAssets.profilePictureId = profilePictureId;
        parsedJson.unifiedProfileAssets.profilePictureImageKey = `profile_${profilePictureId}`;
        
        const coverPhotoId = crypto.randomUUID();
        parsedJson.unifiedProfileAssets.coverPhotoId = coverPhotoId;
        parsedJson.unifiedProfileAssets.coverPhotoImageKey = `cover_${coverPhotoId}`;
    }

    let mediaPlanGroup: MediaPlanGroup | null = null;
    if (parsedJson.mediaPlan) {
        const planWithIds: MediaPlan = (parsedJson.mediaPlan as any[]).map(week => ({
            ...week,
            posts: (week.posts || []).map((post: any) => {
                const postId = crypto.randomUUID();
                const { status, ...restOfPost } = post;
                return {
                    ...restOfPost,
                    id: postId,
                    imageKey: post.imagePrompt ? `media_plan_post_${postId}` : undefined,
                    status: 'draft',
                } as MediaPlanPost;
            }),
        }));
        
        mediaPlanGroup = {
            id: crypto.randomUUID(),
            name: language === 'Việt Nam' ? 'Kế hoạch Ra mắt Thương hiệu' : 'Brand Launch Plan',
            prompt: language === 'Việt Nam' ? 'Kế hoạch ban đầu được tạo cho việc ra mắt thương hiệu.' : 'Initial plan generated for brand launch.',
            plan: planWithIds,
            source: 'brand-launch',
        };
    }
    
    const assets: Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'> = {
        brandFoundation: parsedJson.brandFoundation,
        coreMediaAssets: parsedJson.coreMediaAssets,
        unifiedProfileAssets: parsedJson.unifiedProfileAssets,
        mediaPlans: mediaPlanGroup ? [mediaPlanGroup] : [],
    };
    return assets;
};

export const generateMediaPlanGroup = async (
    brandFoundation: BrandFoundation,
    userPrompt: string,
    language: string,
    totalPosts: number,
    useSearch: boolean,
    selectedPlatforms: string[],
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    affiliateContentKitSystemInstruction: string,
    model: string,
    persona: Persona | null
): Promise<MediaPlanGroup> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC. They are the face of this campaign.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description (for image generation):** ${persona.outfitDescription}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Image Prompts (VERY IMPORTANT):** Every single 'imagePrompt' value you generate MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona.outfitDescription}, [description of the scene]". For example: "${persona.outfitDescription}, unboxing a product in a minimalist apartment...".
` : '';

    const prompt = `You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a 1-Month Media Plan IN ${language} based on the provided Brand Foundation and User Goal.
The output must be a single, valid JSON object that strictly adheres to the provided schema. Do not add any commentary or text outside of the JSON structure.

**Brand Foundation (Use this as your guide):**
- Brand Name: ${brandFoundation.brandName}
- Mission: ${brandFoundation.mission}
- USP: ${brandFoundation.usp}
- Values: ${(brandFoundation.values || []).join(', ')}
- Target Audience: ${brandFoundation.targetAudience}
- Personality: ${brandFoundation.personality}

${personaInstruction}

**User's Goal for the Plan:**
"${userPrompt}"

**Content Customization Instructions:**
- **Tone of Voice**: Generate all content with a '${options.tone}' tone.
- **Writing Style**: The primary style should be '${options.style}'.
- **Post Length**: Adhere to a '${options.length}' post length. For example, 'Short' is suitable for Instagram captions (2-4 sentences), 'Medium' for Facebook (1-2 paragraphs), and 'Long' could be a detailed script or a mini-blog post.
- **Emojis**: ${options.includeEmojis ? "Use emojis appropriately to enhance engagement and match the brand personality." : "Do not use any emojis."}

Based on the Brand Foundation, User's Goal, and Customization Instructions, generate a complete 4-week media plan group.
- **Name**: First, create a short, descriptive title for this entire plan based on the User's Goal (e.g., "Q3 Product Launch", "Summer Eco-Friendly Campaign").
- **Plan Structure**: The plan must have 4 weekly objects. Each week must have a clear 'theme' (e.g., "Week 1: Brand Introduction & Values").
- **Content**: The entire 4-week plan must contain a total of approximately ${totalPosts} posts, distributed logically across the 4 weeks. The number of posts per week can vary if it makes thematic sense, but the total must be close to ${totalPosts}. The posts should be distributed *only* across the following selected platforms: ${selectedPlatforms.join(', ')}. Do not generate content for any other platform not in this list.
- **Post Details**: Each post object must be complete and ready-to-use, containing:
    -   platform: The target platform. It MUST be one of the selected platforms: ${selectedPlatforms.map(p => `'${p}'`).join(', ')}.
    -   contentType: e.g., "Image Post", "Video Idea", "Story", "Carousel Post".
    -   title: An SEO-friendly title or headline.
    -   content: The full caption, description, or script. This must be engaging and reflect the brand personality and customization instructions.
    -   hashtags: An array of relevant and trending hashtags.
    -   cta: A clear call-to-action (e.g., "Shop Now", "Learn More", "Comment below").
    -   imagePrompt: A detailed, English-language prompt for an image generation model.
- **Important Content Formatting Rules**:
    - The 'content' field for any post must be the final, user-facing text (e.g., a caption, script, or description).
    - For Instagram 'Carousel Post' types, the 'content' field should be a single, cohesive caption for the entire carousel. It must NOT include markers like "Slide 1:", "Slide 2:", etc. The caption should introduce the carousel and encourage users to swipe.
    - The 'content' field must be clean and ready for publishing. It must NOT contain any extraneous data, especially numerical arrays or references like "[3, 6, 8]".
- **Consistency**: The entire media plan must be thematically consistent with the Brand Foundation.
`;

    const config: any = {
        systemInstruction: affiliateContentKitSystemInstruction,
    };
    if (useSearch) {
        config.tools = [{googleSearch: {}}];
    } else {
        config.responseMimeType = "application/json";
    }

    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config,
        })
    );
    let jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI.");

    if (useSearch) {
        let extractedJson = jsonText.trim();
        const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
        if (markdownMatch && markdownMatch[1]) {
            extractedJson = markdownMatch[1];
        } else {
            // Find the first valid JSON object.
            const startIndex = extractedJson.indexOf('{');
            if (startIndex !== -1) {
                let balance = 0;
                let endIndex = -1;
                for (let i = startIndex; i < extractedJson.length; i++) {
                    if (extractedJson[i] === '{') balance++;
                    else if (extractedJson[i] === '}') balance--;
                    if (balance === 0) {
                        endIndex = i;
                        break;
                    }
                }
                if (endIndex !== -1) {
                    extractedJson = extractedJson.substring(startIndex, endIndex + 1);
                }
            }
        }
        jsonText = extractedJson;
    }

    const parsedResult = sanitizeAndParseJson(jsonText);
    const { name: planName, plan: planWeeks } = normalizeMediaPlanGroupResponse(parsedResult);

    const planWithEnhancements = (planWeeks || []).map(week => ({
        ...week,
        posts: (week.posts || []).map((post: any) => {
            const { status, ...restOfPost } = post;
            return {
                ...restOfPost,
                id: crypto.randomUUID(),
                status: 'draft',
            } as MediaPlanPost;
        }),
    }));

    return {
        id: crypto.randomUUID(),
        name: planName || userPrompt.substring(0, 30),
        prompt: userPrompt,
        plan: planWithEnhancements,
        source: 'wizard',
        sources: response.candidates?.[0]?.groundingMetadata?.groundingChunks?.map((c: any) => c.web).filter(Boolean) || [],
        personaId: persona?.id,
    };
};

export const generateImage = async (
    prompt: string,
    promptSuffix: string,
    model: string,
    aspectRatio: "1:1" | "16:9" = "1:1",
    productImages: File[] = []
): Promise<string> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const fullPrompt = `${prompt}${promptSuffix ? `, ${promptSuffix}` : ''}`;
    
    const response = await ai.models.generateImages({
        model: 'imagen-3.0-generate-002',
        prompt: fullPrompt,
        config: {
            numberOfImages: 1,
            outputMimeType: 'image/jpeg',
            aspectRatio: aspectRatio,
        },
    });

    const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
    return `data:image/jpeg;base64,${base64ImageBytes}`;
};

export const generateImagePromptForPost = async (
    postContent: { title: string; content: string },
    brandFoundation: BrandFoundation,
    language: string,
    model: string,
    persona: Persona | null
): Promise<string> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

    const personaInstruction = persona ? `
The image MUST feature the following persona:
- Nickname: ${persona.nickName}
- Main Style: ${persona.mainStyle}
- Field of Activity: ${persona.activityField}
- Detailed Description: ${persona.outfitDescription}

IMPORTANT: The prompt you generate MUST start with the exact "Detailed Description" above, followed by a comma, then the scene description. The structure must be: "${persona.outfitDescription}, [description of the scene]".
` : '';

    const prompt = `
You are a creative visual director for the brand "${brandFoundation.brandName}".
The brand's personality is: ${brandFoundation.personality}.
${personaInstruction}
Based on the following social media post content (in ${language}), generate a single, detailed, and compelling image generation prompt.
The prompt MUST BE IN ENGLISH.
The prompt should be a single paragraph describing a visual scene that captures the essence of the post.
Do not add any explanations, labels, or extra text. Output ONLY the prompt.

Post Title: "${postContent.title}"
Post Content: "${postContent.content}"
`;
    const response = await ai.models.generateContent({
        model: model,
        contents: prompt,
    });
    return response.text;
};

export const generateAffiliateComment = async (
    post: MediaPlanPost,
    products: AffiliateLink[],
    brandFoundation: BrandFoundation,
    language: string,
    model: string
): Promise<string> => {
     if (products.length === 0) {
        throw new Error("Cannot generate a comment without at least one affiliate product.");
    }
    
    const productDetails = products.map(p => 
        `- Product Name: ${p.productName}\n  - Price: ${p.price}\n  - Promotion Link: ${p.promotionLink || p.productLink}`
    ).join('\n');

    const prompt = `
You are the social media manager for the brand "${brandFoundation.brandName}", which has a "${brandFoundation.personality}" personality. Your task is to write a comment for a social media post, from the perspective of the page admin.

**Primary Goal:** Write a natural, human-like comment that subtly promotes one or more affiliate products related to the post. The comment must encourage clicks on the affiliate link.

**Rules:**
1.  **Natural Tone:** The comment must sound like a real person, not an ad. It should match the tone of the original post. Avoid overly salesy language.
2.  **Two-Part Structure:** The comment MUST consist of two parts, separated by a blank line:
    *   **Part 1 (Caption):** A short, engaging caption. This caption must cleverly connect the original post's topic with the product(s) being promoted. It should add value, share a personal tip, or ask a question to spark conversation and make people curious about the link.
    *   **Part 2 (Links):** The affiliate link(s) for the product(s). If there is more than one product, list each link on a new line. Do not add any text before or after the links in this part.
3.  **Language:** The entire comment MUST be in ${language}.

**Original Post Content:**
- Title: ${post.title}
- Content: ${post.content}

**Affiliate Product(s) to Promote:**
${productDetails}

**Example Output:**
Mình thấy nhiều bạn hỏi về [related_topic], em này đúng là chân ái luôn, giải quyết được đúng vấn đề đó. Dùng cực thích!

https://your-affiliate-link.com

---
Now, generate the comment based on the provided post and product details. Output ONLY the comment text.
`;
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const response = await ai.models.generateContent({
        model: model,
        contents: prompt,
    });
    return response.text;
};

export const generateViralIdeas = async (
    trend: { topic: string; keywords: string[] },
    language: string,
    useSearch: boolean,
    model: string
): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    let prompt = `You are a viral marketing expert and a world-class creative strategist.
Your task is to generate 5 highly engaging and potentially viral content ideas based on a given topic and related keywords.
The ideas must be in ${language}.
Each idea must have:
1.  A catchy, curiosity-driven 'title'.
2.  A short but comprehensive 'description' of the idea.
3.  A specific 'targetAudience' that this idea would appeal to.

Topic: "${trend.topic}"
Keywords: ${trend.keywords.join(', ')}
`;
    const ideasSchema = {
        type: Type.ARRAY,
        items: {
            type: Type.OBJECT,
            properties: {
                title: { type: Type.STRING },
                description: { type: Type.STRING },
                targetAudience: { type: Type.STRING },
            },
            required: ['title', 'description', 'targetAudience'],
        },
    };

    const config: any = {};
    if (useSearch) {
        config.tools = [{googleSearch: {}}];
        prompt += '\n\nYour response MUST be a valid JSON array of objects. Do not include any text or markdown formatting before or after the JSON array.';
    } else {
        config.responseMimeType = "application/json";
        config.responseSchema = ideasSchema;
    }

    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config,
        })
    );
    let jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI for viral ideas.");

    if (useSearch) {
        let extractedJson = jsonText.trim();
        const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
        if (markdownMatch && markdownMatch[1]) {
            extractedJson = markdownMatch[1];
        } else {
            const startIndex = extractedJson.indexOf('[');
            if (startIndex !== -1) {
                let balance = 0;
                let endIndex = -1;
                for (let i = startIndex; i < extractedJson.length; i++) {
                    if (extractedJson[i] === '[') balance++;
                    else if (extractedJson[i] === ']') balance--;
                    if (balance === 0) {
                        endIndex = i;
                        break;
                    }
                }
                if (endIndex !== -1) {
                    extractedJson = extractedJson.substring(startIndex, endIndex + 1);
                }
            }
        }
        jsonText = extractedJson;
    }
    
    return sanitizeAndParseJson(jsonText);
};

export const generateContentPackage = async (
    idea: Idea,
    brandFoundation: BrandFoundation,
    language: string,
    affiliateContentKit: string,
    model: string,
    persona: Persona | null,
    pillarPlatform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest',
    options: { tone: string; style: string; length: string; }
): Promise<MediaPlanGroup> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Tone:** The content's tone must perfectly match this persona's style.
` : '';

    const customizationInstruction = `
**Content Customization Instructions:**
- **Tone of Voice**: Generate all content with a '${options.tone}' tone.
- **Writing Style**: The primary style should be '${options.style}'.
- **Post Length**: Adhere to a '${options.length}' post length.
`;

    // 1. Generate Pillar Content
    const pillarPrompt = `
    ${personaInstruction}
    ${customizationInstruction}
    Based on the idea "${idea.title}", create a comprehensive, 'pillar' content piece for ${pillarPlatform}.
    This should be a detailed, authoritative piece that provides significant value to the target audience: ${idea.targetAudience}.
    - If ${pillarPlatform} is YouTube, provide a detailed video script and a separate, SEO-optimized 'description' for the YouTube description box.
    - If ${pillarPlatform} is Facebook, provide a long-form, engaging post like a mini-article.
    - If ${pillarPlatform} is Instagram, provide a detailed multi-slide carousel post concept, including content for each slide and a main caption.
    - If ${pillarPlatform} is Pinterest, provide a concept for a detailed infographic or a guide pin, including all text content needed.
    - If ${pillarPlatform} is TikTok, provide a script for a multi-part (2-3 videos) series.
    The output must be a single JSON object with: title, content, ${pillarPlatform === 'YouTube' ? 'description, ' : ''}hashtags, and cta.
    Language: ${language}.
    `;
    const pillarResponse = await ai.models.generateContent({
        model, contents: pillarPrompt,
        config: { systemInstruction: affiliateContentKit, responseMimeType: 'application/json' }
    });
    const rawPillarPost = sanitizeAndParseJson(pillarResponse.text);
    const pillarPost = normalizePillarContent(rawPillarPost);


    // 2. Generate Repurposed Content
    const allPlatforms: ('YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest')[] = ['YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest'];
    const repurposedPlatforms = allPlatforms.filter(p => p !== pillarPlatform);

    const repurposedPrompt = `
    ${personaInstruction}
    ${customizationInstruction}
    **Context:** The following is a large "pillar" content piece about "${idea.title}" created for ${pillarPlatform}.
    Pillar Content: "${pillarPost.content}"
    **Your Task:** Repurpose the core message of the pillar content into one smaller, standalone post for EACH of the following platforms: ${repurposedPlatforms.join(', ')}.
    Each new piece must be completely rewritten and tailored for its specific platform's format and audience. They must be relevant to the original pillar content.
    - For short-form video platforms (TikTok, Instagram), create a concise video script or reel idea.
    - For image-based platforms (Instagram, Pinterest), create a compelling caption for an image or carousel.
    - For text-based platforms (Facebook), create an engaging post that summarizes or expands on a key point from the pillar content.
    - If the pillar content is a long text post and you need to generate a YouTube idea, create a script outline for a short video based on the text.
    The output must be an array of ${repurposedPlatforms.length} JSON objects, each with: platform (must be one of ${repurposedPlatforms.join(', ')}), contentType, title, content, hashtags, and cta.
    Language: ${language}.
    `;
    const repurposedResponse = await ai.models.generateContent({
        model, contents: repurposedPrompt,
        config: { systemInstruction: affiliateContentKit, responseMimeType: 'application/json' }
    });
    const rawRepurposed = sanitizeAndParseJson(repurposedResponse.text);
    let repurposedPosts: Omit<MediaPlanPost, 'id'|'status'>[] = normalizeArrayResponse(rawRepurposed, 'post');

    // Normalize hashtags for each repurposed post
    repurposedPosts = repurposedPosts.map(post => {
        const p = { ...post };
        if (typeof p.hashtags === 'string') {
            p.hashtags = (p.hashtags as any).split(/[, ]+/)
                .map((h: string) => h.trim())
                .filter(Boolean)
                .map((h: string) => h.startsWith('#') ? h : `#${h}`);
        } else if (!Array.isArray(p.hashtags)) {
            p.hashtags = [];
        }
        return p;
    });


    // 3. Assemble the package into a MediaPlanGroup
    const allPosts: Omit<MediaPlanPost, 'id'|'status'>[] = [
        {
            ...(pillarPost as any),
            platform: pillarPlatform,
            isPillar: true,
        },
        ...repurposedPosts.map(p => ({
            ...p,
            isPillar: false,
        }))
    ];

    // 4. Generate image prompts for all posts
    const postsWithPrompts = await Promise.all(
        allPosts.map(async (post) => {
            try {
                const newPrompt = await generateImagePromptForPost(
                    { title: post.title, content: post.content },
                    brandFoundation,
                    language,
                    model,
                    persona
                );
                return { ...post, imagePrompt: newPrompt };
            } catch (e) {
                console.error(`Failed to generate image prompt for post: ${post.title}`, e);
                return post; // Return original post on error
            }
        })
    );


    const finalPosts = postsWithPrompts.map(p => ({
        ...p,
        id: crypto.randomUUID(),
        status: 'draft',
    } as MediaPlanPost));


    const plan: MediaPlan = [{
        week: 1,
        theme: `Content Package: ${idea.title}`,
        posts: finalPosts
    }];

    return {
        id: crypto.randomUUID(),
        name: idea.title,
        prompt: idea.description,
        plan: plan,
        source: 'content-package',
        personaId: persona?.id,
    };
};

// --- NEW FACEBOOK STRATEGY FUNCTIONS ---

export const generateFacebookTrends = async (
    industry: string,
    language: string,
    model: string
): Promise<Omit<FacebookTrend, 'id'|'brandId'>[]> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const prompt = `You are a Facebook marketing expert. Analyze Google Search results for the query "trending topics and content formats in ${industry} on Facebook for ${language}".
Identify 3-5 distinct, current trends. For each trend, provide:
1.  A concise 'topic'.
2.  An array of relevant 'keywords'.
3.  A brief 'analysis' explaining why it's trending for the target audience on Facebook and what content formats (e.g., Reels, Carousels, Long-form posts) are performing best.
4.  The top 3 most relevant 'links' from the search results that support your analysis. Each link must be an object with "uri" and "title" keys.

Your response must be a single, valid JSON array of objects. Each object should have the keys: "topic", "keywords", "analysis", and "links". Do not add any text or explanation before or after the JSON array.`;

    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config: {
                tools: [{ googleSearch: {} }],
            }
        })
    );
    let jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI for Facebook trends.");

    let extractedJson = jsonText.trim();
    const markdownMatch = extractedJson.match(/```json\s*([\s\S]*?)\s*```/);
    if (markdownMatch && markdownMatch[1]) {
        extractedJson = markdownMatch[1];
    } else {
        const startIndex = extractedJson.indexOf('[');
        if (startIndex !== -1) {
            let balance = 0;
            let endIndex = -1;
            // A simple bracket counter. Not perfect for strings with brackets, but better than a greedy lastIndexOf.
            for (let i = startIndex; i < extractedJson.length; i++) {
                if (extractedJson[i] === '[') {
                    balance++;
                } else if (extractedJson[i] === ']') {
                    balance--;
                }
                if (balance === 0) {
                    endIndex = i;
                    break;
                }
            }
            if (endIndex !== -1) {
                extractedJson = extractedJson.substring(startIndex, endIndex + 1);
            }
        }
    }
    jsonText = extractedJson;

    const trendsData = sanitizeAndParseJson(jsonText);
    return (trendsData || []).map((trend: any) => ({ ...trend, createdAt: new Date().toISOString() }));
};

export const generatePostsForFacebookTrend = async (
    trend: FacebookTrend,
    language: string,
    model: string
): Promise<Omit<FacebookPostIdea, 'id' | 'trendId'>[]> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const prompt = `You are a creative Facebook content strategist. Based on the following trend, generate 5 engaging Facebook post ideas in ${language}.
For each idea, provide:
1.  A catchy 'title'.
2.  The main 'content' for the post, optimized for Facebook's platform.
3.  A detailed English 'imagePrompt' for an accompanying visual.
4.  A strong 'cta' (call to action).

Trend Topic: "${trend.topic}"
Trend Keywords: ${trend.keywords.join(', ')}
Trend Analysis: ${trend.analysis}
`;
    const postsSchema = {
        type: Type.ARRAY,
        items: {
            type: Type.OBJECT,
            properties: {
                title: { type: Type.STRING },
                content: { type: Type.STRING },
                imagePrompt: { type: Type.STRING },
                cta: { type: Type.STRING },
            },
            required: ['title', 'content', 'imagePrompt', 'cta'],
        },
    };

    const response = await geminiFetchWithRetry(() =>
        ai.models.generateContent({
            model: model,
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: postsSchema,
            }
        })
    );
    const jsonText = response.text;
    if (!jsonText) throw new Error("Received empty response from AI for Facebook post ideas.");
    return sanitizeAndParseJson(jsonText);
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\geminiService.ts.temp ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\khongminhService.ts ---\n



import { generateEmbeddingsWithBff } from './bffService';
import type { MediaPlanPost, AffiliateLink } from '../types';


/**
 * Calculates the cosine similarity between two vectors.
 * @param vecA The first vector.
 * @param vecB The second vector.
 * @returns The cosine similarity score (between -1 and 1).
 */
export function cosineSimilarity(vecA: number[], vecB: number[]): number {
    if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0) {
        return 0;
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
        dotProduct += vecA[i] * vecB[i];
        normA += vecA[i] * vecA[i];
        normB += vecB[i] * vecB[i];
    }

    if (normA === 0 || normB === 0) {
        return 0;
    }

    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

/**
 * Suggests relevant affiliate products for a given social media post using vector similarity search.
 * This function implements the on-demand matching workflow (Workflow B) described in the KhongMinh module specification.
 * It generates embeddings for the post and available products in a single batch call, then calculates cosine similarity to find the best matches.
 */
export const suggestProductsForPost = async (
    post: MediaPlanPost,
    availableAffiliateLinks: AffiliateLink[],
    count: number
): Promise<AffiliateLink[]> => {
    if (!availableAffiliateLinks || availableAffiliateLinks.length === 0 || count <= 0) {
        return [];
    }

    try {
        // Workflow B, Step 2: Construct Post Text
        const postText = `${post.title} | ${post.content} | ${(post.hashtags || []).join(' ')}`;

        // This simulates part of Workflow A on the fly: Construct Product Text
        const productTexts = availableAffiliateLinks.map(link => 
            `${link.productName} | ${link.providerName} | ${link.product_description || ''} | ${(link.features || []).join(' ')} | ${(link.use_cases || []).join(' ')} | ${link.customer_reviews || ''} | ${link.product_rating || ''}`
        );
        
        // Workflow B, Step 3: Generate Post and Product embeddings
        const allTexts = [postText, ...productTexts];
        const allTaskTypes = [
            "RETRIEVAL_QUERY", 
            ...productTexts.map(() => "RETRIEVAL_DOCUMENT")
        ];

        const embeddings = await generateEmbeddingsWithBff(allTexts, allTaskTypes);
        
        if (!embeddings || embeddings.length < 2) {
             console.error("Not enough embeddings returned from API.");
             return [];
        }

        const postEmbedding = embeddings[0];
        const productEmbeddings = embeddings.slice(1);

        // Workflow B, Step 4: Perform Similarity Search
        const scoredLinks = availableAffiliateLinks.map((link, index) => {
            const productEmbeddingValues = productEmbeddings[index];
            if (!productEmbeddingValues) {
                return { link, similarity: -1 };
            }
            const similarity = cosineSimilarity(postEmbedding, productEmbeddingValues);
            return { link, similarity };
        });

        // Acceptance Criteria: Retrieve Top Matches with score > 0.75
        const SIMILARITY_THRESHOLD = 0.75;
        const sortedAndFilteredLinks = scoredLinks
            .filter(item => item.similarity >= SIMILARITY_THRESHOLD)
            .sort((a, b) => {
                if (b.similarity !== a.similarity) {
                    return b.similarity - a.similarity;
                }
                // Prioritize by salesVolume (highest first)
                if (b.link.salesVolume !== a.link.salesVolume) {
                    return b.link.salesVolume - a.link.salesVolume;
                }
                // Then by product_rating (highest first)
                return (b.link.product_rating || 0) - (a.link.product_rating || 0);
            });
        
        // Workflow B, Step 5 & 7: Return ranked list of top N products
        return sortedAndFilteredLinks.slice(0, count).map(item => item.link);

    } catch (error) {
        console.error("KhongMinh suggestion using vector search failed:", error);
        // Gracefully fail by returning an empty array.
        return [];
    }
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\khongminhService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\lazyLoadService.ts ---\nimport { 
  loadInitialProjectData, 
  loadMediaPlanGroupsList, 
  loadStrategyHubData, 
  loadAffiliateVaultData, 
  loadPersonasData, 
  loadMediaPlanPostsWithPagination 
} from './databaseService';

/**
 * Service for lazy loading data to improve initial load times
 */

// Cache for loaded data to prevent unnecessary reloads
const dataCache: Record<string, any> = {};

/**
 * Load initial project data for fast rendering of the BrandKitView
 */
export const loadInitialData = async (brandId: string): Promise<{
  brandSummary: { id: string; name: string; logoUrl?: string };
  brandKitData: {
    brandFoundation: BrandFoundation;
    coreMediaAssets: CoreMediaAssets;
    unifiedProfileAssets: UnifiedProfileAssets;
  };
}> => {
  const cacheKey = `initial-${brandId}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadInitialProjectData(brandId);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Load media plan groups list for the MediaPlanView
 */
export const loadMediaPlanGroups = async (brandId: string): Promise<{
  id: string;
  name: string;
  prompt: string;
  source?: MediaPlanGroup['source'];
  productImages?: { name: string, type: string, data: string }[];
  personaId?: string;
}[]> => {
  const cacheKey = `media-plan-groups-${brandId}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadMediaPlanGroupsList(brandId);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Load strategy hub data (trends and ideas)
 */
export const loadStrategyHub = async (brandId: string): Promise<{
  trends: Trend[];
  ideas: Idea[];
}> => {
  const cacheKey = `strategy-hub-${brandId}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadStrategyHubData(brandId);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Load affiliate vault data
 */
export const loadAffiliateVault = async (brandId: string): Promise<AffiliateLink[]> => {
  const cacheKey = `affiliate-vault-${brandId}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadAffiliateVaultData(brandId);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Load personas data
 */
export const loadPersonas = async (brandId: string): Promise<Persona[]> => {
  const cacheKey = `personas-${brandId}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadPersonasData(brandId);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Load media plan posts with pagination
 */
export const loadMediaPlanPosts = async (
  planId: string,
  page: number = 1,
  limit: number = 30
): Promise<{
  posts: MediaPlanPost[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalPosts: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}> => {
  const cacheKey = `media-plan-posts-${planId}-${page}-${limit}`;
  if (dataCache[cacheKey]) {
    return dataCache[cacheKey];
  }
  
  const data = await loadMediaPlanPostsWithPagination(planId, page, limit);
  dataCache[cacheKey] = data;
  return data;
};

/**
 * Clear cache for a specific brand
 */
export const clearCacheForBrand = (brandId: string): void => {
  Object.keys(dataCache).forEach(key => {
    if (key.includes(brandId)) {
      delete dataCache[key];
    }
  });
};

/**
 * Clear all cache
 */
export const clearAllCache = (): void => {
  Object.keys(dataCache).forEach(key => delete dataCache[key]);
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\lazyLoadService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\openrouterService.ts ---\nimport { sanitizeAndParseJson, normalizeMediaPlanGroupResponse, normalizePillarContent, normalizeArrayResponse } from './geminiService';
import { generateContentWithOpenRouterBff, generateImageWithOpenRouterBff } from './bffService';
import type { BrandInfo, GeneratedAssets, MediaPlan, BrandFoundation, MediaPlanGroup, MediaPlanPost, AffiliateLink, Persona, Idea, PostStatus } from '../types';

// Remove the openrouterFetch function and all direct API calls
// All OpenRouter requests will now go through the BFF

export const refinePostContentWithOpenRouter = async (postText: string, model: string): Promise<string> => {
    const prompt = `You are a world-class social media copywriter. Refine the following post content to maximize engagement and impact, while preserving its core message. The output should ONLY be the refined text, without any introductory phrases, explanations, or quotes.

Original content:
"""${postText}"""`;

    const response = await generateContentWithOpenRouterBff(
        model,
        [
            { role: "user", content: prompt }
        ]
    );

    return response;
};

export const generateBrandProfileWithOpenRouter = async (idea: string, language: string, model: string): Promise<BrandInfo> => {
    const prompt = `
You are an expert brand strategist. Based on the user's business idea, generate a concise and compelling brand profile IN ${language}.
The output must be a single, valid JSON object. Do not add any commentary or text outside of the JSON structure.

Business Idea:
"${idea}"

Generate the following brand profile fields in ${language}:
- **name**: A creative and fitting brand name.
- **mission**: A powerful, one-sentence mission statement.
- **values**: A comma-separated string of 4-5 core brand values.
- **audience**: A brief description of the target audience.
- **personality**: 3-4 keywords describing the brand's personality.
`;

    const openRouterPrompt = `${prompt}

You MUST respond with a single, valid JSON object. Do not add any text or explanation before or after the JSON object.`;
    
    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: openRouterPrompt }],
        { "type": "json_object" }
    );
    
    const jsonText = response;

    // Fix malformed JSON responses that are missing array brackets
    let fixedJsonText = jsonText.trim();
    if (fixedJsonText.startsWith('{') && fixedJsonText.includes('title') && fixedJsonText.includes('description') && fixedJsonText.includes('targetAudience')) {
        // This looks like individual idea objects separated by commas
        // Wrap them in an array
        fixedJsonText = '[' + fixedJsonText + ']';
    } else if (fixedJsonText.startsWith('"') && fixedJsonText.endsWith('"')) {
        // This might be a JSON string that needs to be parsed twice
        try {
            fixedJsonText = JSON.parse(fixedJsonText);
        } catch (e) {
            // If parsing fails, continue with original text
        }
    }
    
    if (!fixedJsonText) {
        throw new Error("Received an empty response from the AI. This could be due to content filtering or an internal error. Please try adjusting your prompt.");
    }

    try {
        return sanitizeAndParseJson(fixedJsonText) as BrandInfo;
    } catch (e) {
        console.error("Failed to parse AI JSON response:", fixedJsonText || "Empty response");
        throw new Error("The AI returned a malformed or unexpected response. Please try again.");
    }
};

export const generateBrandKitWithOpenRouter = async (brandInfo: BrandInfo, language: string, model: string): Promise<Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'>> => {
    const prompt = `
You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a complete and professional set of branding and social media assets IN ${language}, based on the user's input.
The output must be a single, valid JSON object that strictly adheres to the provided schema. Do not add any commentary or text outside of the JSON structure.

Brand Input (in ${language}):
- Brand Name: ${brandInfo.name}
- Brand Mission: ${brandInfo.mission}
- Brand Values: ${brandInfo.values}
- Target Audience: ${brandInfo.audience}
- Brand Personality: ${brandInfo.personality}

Generate the following assets IN ${language}:
1.  **Brand Foundation**: Summarize the core identity. All subsequent generations must be perfectly aligned with this foundation.
2.  **Core Media Assets**: Create logo concepts (prompts for an image generation model), a 4-color palette, and font recommendations. Logo prompts must be in English.
3.  **Unified Profile Assets**: Create a single set of assets for use across all platforms (account name, username, profile picture prompt, cover photo prompt). Image prompts must be in English.
4.  **Initial 1-Month Media Plan**: Generate a 4-week media plan designed for a brand launch. It should have a clear theme for each week. Create 4 posts per week, distributed across YouTube, Facebook, Instagram, TikTok, and Pinterest. Ensure every post includes a detailed, English image prompt.
`;
    const openRouterPrompt = `${prompt}

You MUST respond with a single, valid JSON object. Do not add any text or explanation before or after the JSON object.`;
    
    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: openRouterPrompt }],
        { "type": "json_object" }
    );
    
    const jsonText = response;
    
    if (!jsonText) {
        throw new Error("Received an empty response from the AI. This could be due to content filtering or an internal error. Please try adjusting your prompt.");
    }

    try {
        // Fix malformed JSON responses that are missing array brackets
        let fixedJsonText = jsonText.trim();
        if (fixedJsonText.startsWith('{') && fixedJsonText.includes('title') && fixedJsonText.includes('description') && fixedJsonText.includes('targetAudience')) {
            // This looks like individual idea objects separated by commas
            // Wrap them in an array
            fixedJsonText = '[' + fixedJsonText + ']';
        } else if (fixedJsonText.startsWith('"') && fixedJsonText.endsWith('"')) {
            // This might be a JSON string that needs to be parsed twice
            try {
                fixedJsonText = JSON.parse(fixedJsonText);
            } catch (e) {
                // If parsing fails, continue with original text
            }
        }

        console.log("Fixed OpenRouter response for brand kit:", fixedJsonText);

        const parsedJson = sanitizeAndParseJson(fixedJsonText);

        // Handle different possible response structures from AI
        // Some models might return snake_case keys instead of camelCase
        const brandFoundation = parsedJson.brandFoundation || parsedJson.brand_foundation;
        const coreMediaAssets = parsedJson.coreMediaAssets || parsedJson.core_media_assets;
        const unifiedProfileAssets = parsedJson.unifiedProfileAssets || parsedJson.unified_profile_assets;
        const mediaPlan = parsedJson.mediaPlan || parsedJson.initial_1_month_media_plan || parsedJson.media_plan || parsedJson.initial1MonthMediaPlan;

        if (!brandFoundation || !coreMediaAssets || !unifiedProfileAssets || !mediaPlan) {
            console.error("AI response from OpenRouter is missing one or more root keys. Parsed JSON:", parsedJson);
            throw new Error("The AI returned a JSON object with a missing or incorrect structure. Please try again.");
        }

        // Create a normalized response object with the correct structure
        const normalizedResponse = {
            brandFoundation,
            coreMediaAssets,
            unifiedProfileAssets,
            mediaPlan
        };

        if (normalizedResponse.coreMediaAssets?.logoConcepts) {
            normalizedResponse.coreMediaAssets.logoConcepts = normalizedResponse.coreMediaAssets.logoConcepts.map((logo: any) => {
                const logoId = crypto.randomUUID();
                return {
                    ...logo,
                    id: logoId,
                    imageKey: `logo_${logoId}`
                } as any;
            });
        }
        if(normalizedResponse.unifiedProfileAssets){
            const profilePictureId = crypto.randomUUID();
            normalizedResponse.unifiedProfileAssets.profilePictureId = profilePictureId;
            normalizedResponse.unifiedProfileAssets.profilePictureImageKey = `profile_${profilePictureId}`;
            
            const coverPhotoId = crypto.randomUUID();
            normalizedResponse.unifiedProfileAssets.coverPhotoId = coverPhotoId;
            normalizedResponse.unifiedProfileAssets.coverPhotoImageKey = `cover_${coverPhotoId}`;
        }

        let mediaPlanGroup: MediaPlanGroup | null = null;
        if (normalizedResponse.mediaPlan) {
            const planWithIds: MediaPlan = (normalizedResponse.mediaPlan as any[]).map(week => ({
                ...week,
                posts: (week.posts || []).map((post: any) => {
                    const postId = crypto.randomUUID();
                    const { status, ...restOfPost } = post;
                    return {
                        ...restOfPost,
                        id: postId,
                        imageKey: post.mediaPrompt ? `media_plan_post_${postId}` : undefined,
                        status: 'draft',
                    } as MediaPlanPost;
                }),
            }));
            
            mediaPlanGroup = {
                id: crypto.randomUUID(),
                name: language === 'Việt Nam' ? 'Kế hoạch Ra mắt Thương hiệu' : 'Brand Launch Plan',
                prompt: language === 'Việt Nam' ? 'Kế hoạch ban đầu được tạo cho việc ra mắt thương hiệu.' : 'Initial plan generated for brand launch.',
                plan: planWithIds,
            };
        }
        
        const assets: Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'> = {
            brandFoundation: normalizedResponse.brandFoundation,
            coreMediaAssets: normalizedResponse.coreMediaAssets,
            unifiedProfileAssets: normalizedResponse.unifiedProfileAssets,
            mediaPlans: mediaPlanGroup ? [mediaPlanGroup] : [],
        };
        return assets;
    } catch (e) {
        console.error("Failed to parse AI JSON response:", jsonText || "Empty response");
        throw new Error("The AI returned a malformed or unexpected response. Please try again.");
    }
};

export const generateMediaPlanGroupWithOpenRouter = async (
    brandFoundation: BrandFoundation,
    userPrompt: string,
    language: string,
    totalPosts: number,
    selectedPlatforms: string[],
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    affiliateContentKitSystemInstruction: string,
    model: string,
    persona: Persona | null,
    selectedProduct: AffiliateLink | null // Added this line
): Promise<MediaPlanGroup> => {
    
    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC. They are the face of this campaign.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description (for media generation):** ${persona.outfitDescription}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Media Prompts (VERY IMPORTANT):** For any post that requires an image, the 'mediaPrompt' MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona.outfitDescription}, [description of the scene]".
` : '';

    const openRouterPrompt = `You are SocialSync Pro, an AI-powered brand launch assistant. Your task is to generate a 1-Month Media Plan IN ${language} based on the provided Brand Foundation and User Goal.
You MUST strictly follow the rules provided in the system instruction.
The output must be a single, valid JSON object that strictly adheres to the provided schema. Do not add any commentary or text outside of the JSON structure.

**Brand Foundation (Use this as your guide):**
- Brand Name: ${brandFoundation.brandName}
- Mission: ${brandFoundation.mission}
- USP: ${brandFoundation.usp}
- Values: ${(brandFoundation.values || []).join(', ')}
- Target Audience: ${brandFoundation.targetAudience}
- Personality: ${brandFoundation.personality}

${personaInstruction}

**User's Goal for the Plan:**
"${userPrompt}"

**Content Customization Instructions:**
- **Tone of Voice**: Generate all content with a '${options.tone}' tone.
- **Writing Style**: The primary style should be '${options.style}'.
- **Post Length**: Adhere to a '${options.length}' post length. For example, 'Short' is suitable for Instagram captions (2-4 sentences), 'Medium' for Facebook (1-2 paragraphs), and 'Long' could be a detailed script or a mini-blog post.
            - **Emojis**: ${options.includeEmojis ? "Use emojis appropriately to enhance engagement and match the brand personality." : "Do not use any emojis."} 

Based on the Brand Foundation, User's Goal, and Customization Instructions, generate a complete 4-week media plan group.
- **Name**: First, create a short, descriptive title for this entire plan based on the User's Goal (e.g., "Q3 Product Launch", "Summer Eco-Friendly Campaign").
- **Plan Structure**: The plan must have 4 weekly objects. Each week must have a clear 'theme' (e.g., "Week 1: Brand Introduction & Values").
- **Content**: The entire 4-week plan must contain a total of approximately ${totalPosts} posts, distributed logically across the 4 weeks. The number of posts per week can vary if it makes thematic sense, but the total must be close to ${totalPosts}. The posts should be distributed *only* across the following selected platforms: ${selectedPlatforms.join(', ')}. Do not generate content for any other platform not in this list.
- **Post Details (CRITICAL):
    -   **contentType**: e.g., "Image Post", "Video Idea", "Story", "Carousel Post", "Shorts Idea".
    -   **content**: This is ALWAYS the user-facing text caption for the post.
    -   **script**: For video contentTypes ("Video Idea", "Shorts Idea", "Story"), this field MUST contain the video script, storyboard, or detailed scene-by-scene description. For non-video posts, this should be null.
    -   **mediaPrompt**: This is the prompt for the visual media. It MUST be in English.
        -   For "Image Post": A single, detailed DALL-E prompt to generate the image.
        -   For "Video Idea", "Shorts Idea", "Story": A concise, one-paragraph summary of the visual concept, suitable for a text-to-video model.
        -   For "Carousel Post": An array of detailed, English DALL-E prompts, one for each image in the carousel (2-5 prompts).
- **Consistency**: The entire media plan must be thematically consistent with the Brand Foundation.

**JSON Schema for Media Plan Group (Strictly Adhere to This:)**
\`\`\`json
{
  "type": "object",
  "properties": {
    "name": { "type": "string", "description": "A short, descriptive title for the media plan." },
    "plan": {
      "type": "array",
      "description": "An array of weekly media plan objects.",
      "items": {
        "type": "object",
        "properties": {
          "week": { "type": "integer", "description": "The week number (1-4)." },
          "theme": { "type": "string", "description": "The thematic focus for the week." },
          "posts": {
            "type": "array",
            "description": "An array of social media posts for the week.",
            "items": {
              "type": "object",
              "properties": {
                "platform": { "type": "string", "enum": ["YouTube", "Facebook", "Instagram", "TikTok", "Pinterest"] },
                "contentType": { "type": "string" },
                "title": { "type": "string" },
                "content": { "type": "string" },
                "hashtags": { "type": "array", "items": { "type": "string" } },
                "cta": { "type": "string" },
                "mediaPrompt": { "type": ["string", "array"], "items": { "type": "string" }, "description": "A detailed prompt for the media content. Can be a string or an array of strings for carousels." },
                "script": { "type": "string", "description": "A detailed script for video content." }
              },
              "required": ["platform", "contentType", "title", "content", "hashtags", "cta", "mediaPrompt"]
            }
          }
        },
        "required": ["week", "theme", "posts"]
      }
    }
  },
  "required": ["name", "plan"]
}
\`\`\`

**KOL/KOC Persona (Crucial):
All content MUST be generated from the perspective of the following KOL/KOC. They are the face of this campaign.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description:** ${persona.outfitDescription}

IMPORTANT: For image prompts, the prompt you generate MUST start with the exact "Detailed Description" above, followed by a comma, then the scene description. The structure must be: "${persona.outfitDescription}, [description of the scene]" 
- **Tone:** The content's tone must perfectly match this persona's style.
`;

    const response = await generateContentWithOpenRouterBff(
        model,
        [
            { role: 'system', content: affiliateContentKitSystemInstruction },
            { role: 'user', content: openRouterPrompt }
        ],
        { "type": "json_object" }
    );
    
    const jsonText = response;
    if (!jsonText) throw new Error("Received empty response from OpenRouter.");
    
    const parsedResult = sanitizeAndParseJson(jsonText);
    const { name: planName, plan: planWeeks } = normalizeMediaPlanGroupResponse(parsedResult);

    const planWithEnhancements = (planWeeks || []).map(week => ({
        ...week,
        posts: (week.posts || []).map((post: any) => {
            const { status, ...restOfPost } = post;
            return {
                ...restOfPost,
                id: crypto.randomUUID(),
                status: 'draft',
                promotedProductIds: selectedProduct ? [selectedProduct.id] : [],
            } as MediaPlanPost;
        }),
    }));

    return {
        id: crypto.randomUUID(),
        name: (planName && planName !== 'Untitled Plan') ? planName : (selectedProduct ? `Promotion Plan: ${selectedProduct.productName}` : userPrompt.substring(0, 30)),
        prompt: userPrompt,
        plan: planWithEnhancements,
        source: 'wizard',
        sources: [], // groundedContent is not defined, using empty array
        personaId: persona?.id,
    };
};

export const generateMediaPromptForPostWithOpenRouter = async (
    postContent: { title: string; content: string; contentType: string },
    brandFoundation: BrandFoundation,
    language: string,
    model: string,
    persona: Persona | null,
    mediaPromptSuffix: string
): Promise<string | string[]> => {
    
    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description (for image generation):** ${persona.outfitDescription}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Image Prompts (VERY IMPORTANT):** Every single 'imagePrompt' value you generate MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona.outfitDescription}, [description of the scene]".
` : '';

    let prompt = `
You are a creative visual director for the brand "${brandFoundation.brandName}".
The brand's personality is: ${brandFoundation.personality}.
${personaInstruction}
Based on the following social media post content (in ${language}), generate a detailed and compelling media prompt.
The prompt MUST BE IN ENGLISH.
Do not add any explanations, labels, or extra text. Output ONLY the prompt.

Post Title: "${postContent.title}"
Post Content: "${postContent.content}"
`;

    switch (postContent.contentType) {
        case 'Image Post':
            prompt += `Generate a single, detailed DALL-E prompt to generate the image.`;
            break;
        case 'Video Idea':
        case 'Shorts Idea':
        case 'Story':
            prompt += `Generate a concise, one-paragraph summary of the visual concept, suitable for a text-to-video model.`;
            break;
        case 'Carousel Post':
            prompt += `Generate an array of detailed, English DALL-E prompts, one for each image in the carousel (2-5 prompts). The output should be a JSON array of strings.`;
            break;
        default:
            prompt += `Generate a single, detailed DALL-E prompt to generate the image.`;
            break;
    }

    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: prompt }]
    );
    
    const text = response;
    
    if (!text) {
        return `A visually appealing image representing the concept of "${postContent.title}" in a style that is ${brandFoundation.personality}.`;
    }

    if (postContent.contentType === 'Carousel Post') {
        try {
            const parsedResponse = JSON.parse(text);
            // For carousel posts, append suffix to each prompt in the array
            if (Array.isArray(parsedResponse)) {
                return parsedResponse.map((prompt: string) => prompt + mediaPromptSuffix);
            } else {
                return parsedResponse;
            }
        } catch (e) {
            console.error("Failed to parse carousel prompts, returning as single string:", text);
            return text;
        }
    }

    // For single prompts, append the suffix
    return text + mediaPromptSuffix;
};

// NgoSiLien - Enhanced Affiliate Comment Generation
// This function generates engaging comments for social media posts that promote affiliate products.
// It dynamically includes available product information like ratings, sales volume, and customer reviews
// to make the comments more appealing and encourage clicks on the affiliate links.
export const generateAffiliateCommentWithOpenRouter = async (
    post: MediaPlanPost,
    products: AffiliateLink[],
    brandFoundation: BrandFoundation,
    language: string,
    model: string
): Promise<string> => {
     if (products.length === 0) {
        throw new Error("Cannot generate a comment without at least one affiliate product.");
    }
    
    const formatProductDetails = (p: AffiliateLink) => {
        const details = [`- Product Name: ${p.productName}`];
        
        // Add price
        details.push(`  - Price: ${p.price}`);
        
        // Add product rating if available
        if (p.product_rating !== undefined && p.product_rating !== null) {
            details.push(`  - Rating: ${p.product_rating}/5`);
        }
        
        // Add sales volume if available
        if (p.salesVolume > 0) {
            details.push(`  - Sales Volume: ${p.salesVolume}`);
        }
        
        // Add customer reviews if available
        if (p.customer_reviews && p.customer_reviews.trim() !== '') {
            // If customer_reviews contains multiple reviews, we'll extract the best one
            // For now, we'll just use the provided reviews as is
            details.push(`  - Customer Reviews: ${p.customer_reviews}`);
        }
        
        // Always add the promotion link (or product link as fallback)
        details.push(`  - Product Link: ${p.promotionLink || p.productLink}`);
        
        return details.join('\n');
    };

    const productDetails = products.map(formatProductDetails).join('\n');

    const prompt = `
You are the creator who wrote the social media post. Your task is to write a follow-up comment on your own post, from your perspective as the post author. This simulates you posting content and then engaging with your own post to promote affiliate products.

**Primary Goal:** Write a natural, human-like comment that subtly promotes one or more affiliate products related to your post. The comment must encourage clicks on the affiliate link while sounding like a genuine self-comment on your own post.

**Rules:**
1.  **Natural Tone:** The comment must sound like you're genuinely engaging with your own content. It should match the tone of the original post and sound like a real person talking to their audience. Avoid overly salesy language.
2.  **Two-Part Structure:** The comment MUST consist of two parts, separated by a blank line:
    *   **Part 1 (Caption):** A short, engaging caption. This caption must cleverly connect your original post's topic with the product(s) being promoted. It should add value, share a personal tip about how you use the product, or ask a question to spark conversation and make people curious about the link. If product details like ratings, sales volume, or customer reviews are provided, you should naturally incorporate these details to make the product more appealing.
    *   **Part 2 (Links):** The affiliate link(s) for the product(s). If there is more than one product, list each link on a new line. Do not add any text before or after the links in this part.
3.  **Language:** The entire comment MUST be in ${language}.

**Original Post Content:**
- Title: ${post.title}
- Content: ${post.content}

**Affiliate Product(s) to Promote:**
${productDetails}

**Example Output:**
Tôi vừa thử em này sau khi làm theo hướng dẫn trong bài và thấy hiệu quả bất ngờ! Bạn nào muốn thử thì xem link bên dưới nha.

https://your-affiliate-link.com

---
Now, generate the comment based on the provided post and product details. Output ONLY the comment text.
`;

    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: prompt }]
    );
    
    const text = response;
    
    if (!text) {
        throw new Error("AI failed to generate a comment.");
    }
    return text;
};

const fileToDataUrl = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = error => reject(error);
    });
};

export const generateImageWithOpenRouter = async (
    prompt: string, 
    promptSuffix: string,
    model: string,
    aspectRatio: "1:1" | "16:9" = "1:1",
    productImages: File[] = []
): Promise<string> => {
    if (!prompt || prompt.trim() === '') {
        throw new Error("Prompt cannot be empty for OpenRouter image generation.");
    }
    
    const messages: any[] = [];
    const userContent: any[] = [];
    
    const NEGATIVE_PROMPT = ', no text, text-free, no typography, no writing, no letters, no words, text overlay';
    const instructionText = `Generate a single, high-quality image based on the following description. The response must be a valid JSON object containing one key: "b64_json", which holds the base64 encoded string of the generated JPEG image.

Description (aspect ratio ${aspectRatio}): "${prompt}${promptSuffix ? `, ${promptSuffix}` : ''}${NEGATIVE_PROMPT}"`;
    
    userContent.push({ type: 'text', text: instructionText });
    
    if (productImages.length > 0) {
        const imagePromises = productImages.map(async (file) => {
            const dataUrl = await fileToDataUrl(file);
            return { type: 'image_url', image_url: { url: dataUrl } };
        });
        const imageContentParts = await Promise.all(imagePromises);
        userContent.push(...imageContentParts);
    }

    messages.push({ role: 'user', content: userContent });
    
    const response = await generateImageWithOpenRouterBff(
        model,
        messages,
        { "type": "json_object" }
    );
    
    // The BFF should already return a data URL, so we can return it directly
    return response;
};

export const generateViralIdeasWithOpenRouter = async (
    trend: { topic: string; keywords: string[] },
    language: string,
    model: string
): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    if (!model || typeof model !== 'string' || model.trim() === '') {
        throw new Error("Cannot generate viral ideas with OpenRouter: No valid model was provided.");
    }
    const prompt = `You are a viral marketing expert and a world-class creative strategist.
Your task is to generate 5 highly engaging and potentially viral content ideas based on a given topic and related keywords.
The ideas must be in ${language}.
Your response MUST be a valid JSON array of objects. Each object must have the following keys:
- "title": A catchy, curiosity-driven 'title'.
- "description": A short but comprehensive 'description' of the idea.
- "targetAudience": A specific 'targetAudience' that this idea would appeal to.

Topic: "${trend.topic}"
Keywords: ${trend.keywords.join(', ')}
`;
    
    const openRouterPrompt = `${prompt}

You MUST respond with a single, valid JSON array, containing 5 idea objects. Do not add any text or explanation before or after the JSON object. The root of your response must be an array, like this: [ { "title": ... }, ... ]`;
    
    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: openRouterPrompt }],
        { "type": "json_object" }
    );
    
    const jsonText = response;
    
    if (!jsonText) {
        throw new Error("Received an empty response from OpenRouter for viral ideas.");
    }

    try {
        let fixedJsonText = jsonText.trim();
        if (fixedJsonText.startsWith('{')) {
            fixedJsonText = `[${fixedJsonText}]`;
        }
        const parsedJson = sanitizeAndParseJson(fixedJsonText);
        const validatedIdeas = normalizeArrayResponse<Omit<Idea, 'id'|'trendId'>>(parsedJson, 'idea');
        
        if (validatedIdeas.length === 0) {
            console.error("Failed to extract a valid array of ideas from OpenRouter response:", parsedJson);
            throw new Error("The AI from OpenRouter returned data in an unexpected structure.");
        }
        
        return validatedIdeas.slice(0, 5);
    } catch (e) {
        console.error("Failed to parse AI JSON response for viral ideas:", jsonText);
        throw new Error("The AI returned a malformed or unexpected response. This may be a temporary issue with the model. Please try again later or configure a different model in Settings.");
    }
};


export const generateContentPackageWithOpenRouter = async (
    idea: Idea,
    brandFoundation: BrandFoundation,
    language: string,
    affiliateContentKit: string,
    model: string,
    persona: Persona | null,
    pillarPlatform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest',
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    selectedProduct: AffiliateLink | null
): Promise<MediaPlanGroup> => {

    const personaInstruction = persona ? `
**KOL/KOC Persona (Crucial):**
All content MUST be generated from the perspective of the following KOL/KOC.
- **Nickname:** ${persona.nickName}
- **Main Style:** ${persona.mainStyle}
- **Field of Activity:** ${persona.activityField}
- **Detailed Description (for image generation):** ${persona.outfitDescription}
- **Tone:** The content's tone must perfectly match this persona's style.
- **Image Prompts (VERY IMPORTANT):** Every single 'imagePrompt' value you generate MUST start with the exact "Detailed Description" provided above, followed by a comma and then a description of the scene. The structure must be: "${persona.outfitDescription}, [description of the scene]". For example: "${persona.outfitDescription}, unboxing a product in a minimalist apartment...".
` : '';

    const productInstruction = selectedProduct ? `
**Affiliate Product to Feature (Crucial):**
- **Product Name:** ${selectedProduct.productName}
- **Product ID:** ${selectedProduct.id}
- **Instruction:** This entire content package is designed to subtly promote this specific product. All generated posts (both pillar and repurposed) MUST be related to this product and its benefits. For every single post you generate, you MUST include a 'promotedProductIds' field in the JSON object, and its value MUST be an array containing the string "${selectedProduct.id}".
` : '';

    const customizationInstruction = `
**Content Customization Instructions:**
- **Tone of Voice**: Generate all content with a '${options.tone}' tone.
- **Writing Style**: The primary style should be '${options.style}'.
- **Post Length**: Adhere to a '${options.length}' post length.
`;

    // 1. Generate Pillar Content
    const pillarPrompt = `
    ${personaInstruction}
    ${productInstruction}
    ${customizationInstruction}
    Based on the idea "${idea.title}", create a comprehensive, long-form 'pillar' content piece for ${pillarPlatform}.
    This should be a detailed, authoritative piece that provides significant value to the target audience: ${idea.targetAudience}.
    - If ${pillarPlatform} is YouTube, provide a detailed video script and a separate, SEO-optimized 'description' for the YouTube description box.
    - If ${pillarPlatform} is Facebook, provide a long-form, engaging post like a mini-article.
    - If ${pillarPlatform} is Instagram, provide a detailed multi-slide carousel post concept, including content for each slide and a main caption.
    - If ${pillarPlatform} is Pinterest, provide a concept for a detailed infographic or a guide pin, including all text content needed.
    - If ${pillarPlatform} is TikTok, provide a script for a multi-part (2-3 videos) series.
    The output must be a single JSON object with: title, content, ${pillarPlatform === 'YouTube' ? 'description, ' : ''}hashtags, and cta. Do NOT include an imagePrompt.
    Language: ${language}.
    You MUST respond with a single, valid JSON object.
    `;
    
    const pillarResponse = await generateContentWithOpenRouterBff(
        model, 
        [
            { role: 'system', content: affiliateContentKit }, 
            { role: 'user', content: pillarPrompt }
        ],
        { "type": "json_object" }
    );
    
    const rawPillar = sanitizeAndParseJson(pillarResponse);
    const pillarPost = normalizePillarContent(rawPillar);

    // 2. Generate Repurposed Content
    const allPlatforms: ('YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest')[] = ['YouTube', 'Facebook', 'Instagram', 'TikTok', 'Pinterest'];
    const repurposedPlatforms = allPlatforms.filter(p => p !== pillarPlatform);

    const repurposedPrompt = `
    ${personaInstruction}
    ${productInstruction}
    ${customizationInstruction}
    **Context:** The following is a large "pillar" content piece about "${idea.title}" created for ${pillarPlatform}.
    Pillar Content: "${pillarPost.content}"
    **Your Task:** Repurpose the core message of the pillar content into one smaller, standalone post for EACH of the following platforms: ${repurposedPlatforms.join(', ')}.
    Each new piece must be completely rewritten and tailored for its specific platform's format and audience. They must be relevant to the original pillar content.
    - For short-form video platforms (TikTok, Instagram), create a concise video script or reel idea.
    - For image-based platforms (Instagram, Pinterest), create a compelling caption for an image or carousel.
    - For text-based platforms (Facebook), create an engaging post that summarizes or expands on a key point from the pillar content.
    - If the pillar content is a long text post and you need to generate a YouTube idea, create a script outline for a short video based on the text.
    Language: ${language}.

    **Output Format (Strictly Enforced):**
    Your response MUST be a single, valid JSON object. The root of this object must be a key named "posts", which contains an array of ${repurposedPlatforms.length} JSON objects.
    Each object in the "posts" array must have these keys: "platform" (must be one of ${repurposedPlatforms.join(', ')}), "contentType", "title", "content", "hashtags", and "cta". Do NOT include an "imagePrompt" key.
    
    Example structure:
    {
      "posts": [
        {
          "platform": "YouTube",
          "contentType": "Shorts Idea",
          "title": "...",
          "content": "...",
          "hashtags": ["...", "..."],
          "cta": "..."
        },
        {
          "platform": "Instagram",
          ...
        }
      ]
    }

    **Crucial Instructions:**
    - Do NOT respond with just a JSON array.
    - Do NOT respond with just a single post object.
    - The root of your response MUST be an object with a "posts" key.
    `;
    
    const repurposedResponse = await generateContentWithOpenRouterBff(
        model, 
        [
            { role: 'system', content: affiliateContentKit }, 
            { role: 'user', content: repurposedPrompt }
        ],
        { "type": "json_object" }
    );
    
    const rawRepurposed = sanitizeAndParseJson(repurposedResponse);
    let repurposedPosts: Omit<MediaPlanPost, 'id'|'status'>[] = normalizeArrayResponse(rawRepurposed, 'post');

    // Normalize hashtags for each repurposed post
    repurposedPosts = repurposedPosts.map(post => {
        const p = { ...post };
        if (typeof p.hashtags === 'string') {
            p.hashtags = (p.hashtags as any).split(/[, ]+/) 
                .map((h: string) => h.trim())
                .filter(Boolean)
                .map((h: string) => h.startsWith('#') ? h : `#${h}`);
        } else if (!Array.isArray(p.hashtags)) {
            p.hashtags = [];
        }
        return p;
    });

    // 3. Assemble the package
    const allPosts: Omit<MediaPlanPost, 'id' | 'status'>[] = [
        {
            ...(pillarPost as any),
            platform: pillarPlatform,
            isPillar: true,
        },
        ...repurposedPosts.map(p => ({
            ...p,
            isPillar: false,
        }))
    ];

    // 4. Generate media prompts for all posts
    const postsWithPrompts = await Promise.all(
        allPosts.map(async (post) => {
            try {
                const newPrompt = await generateMediaPromptForPostWithOpenRouter(
                    { title: post.title, content: post.content, contentType: post.contentType },
                    brandFoundation,
                    language,
                    model,
                    persona
                );
                return { ...post, mediaPrompt: newPrompt };
            } catch (e) {
                console.error(`Failed to generate media prompt for post: ${post.title}`, e);
                return post; // Return original post on error
            }
        })
    );

    const finalPosts = postsWithPrompts.map(p => ({
        ...p,
        id: crypto.randomUUID(),
        status: 'draft',
        promotedProductIds: selectedProduct ? [selectedProduct.id] : [],
    } as MediaPlanPost));


    const plan: MediaPlan = [{
        week: 1,
        theme: `Content Package: ${idea.title}`,
        posts: finalPosts
    }];

    return {
        id: crypto.randomUUID(),
        name: idea.title,
        prompt: idea.description,
        plan: plan,
        source: 'content-package',
        personaId: persona?.id,
    };
};

// --- NEW FUNCTION FOR GENERATING CONTENT IDEAS FROM A PRODUCT ---

export const generateIdeasFromProductWithOpenRouter = async (
    product: AffiliateLink,
    language: string,
    model: string
): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    if (!model || typeof model !== 'string' || model.trim() === '') {
        throw new Error("Cannot generate ideas from product with OpenRouter: No valid model was provided.");
    }
    
    // Build a detailed product description
    const productDetails = [
        `Product Name: ${product.productName}`,
        `Product ID: ${product.productId}`,
        `Price: ${product.price}`,
        `Provider: ${product.providerName}`,
        `Commission Rate: ${product.commissionRate}%`,
        `Commission Value: ${product.commissionValue}`,
        product.product_description ? `Description: ${product.product_description}` : '',
        product.features && product.features.length > 0 ? `Features: ${product.features.join(', ')}` : '',
        product.use_cases && product.use_cases.length > 0 ? `Use Cases: ${product.use_cases.join(', ')}` : '',
        product.customer_reviews ? `Customer Reviews: ${product.customer_reviews}` : '',
        product.product_rating ? `Product Rating: ${product.product_rating}/5` : ''
    ].filter(Boolean).join('\n');
    
    const openRouterPrompt = `You are a creative marketing strategist. Based on the following affiliate product details, generate 5 unique and engaging content ideas in ${language} that can be used to promote this product effectively.

For each idea, provide:
1.  A catchy 'title' that would grab attention.
2.  A detailed 'description' explaining the concept and how it would showcase the product.
3.  A specific 'targetAudience' that this idea would appeal to.

Product Details:
${productDetails}

Make sure each idea is distinct and highlights different aspects of the product. Consider various content formats like tutorials, reviews, comparisons, lifestyle content, unboxings, etc.

You MUST respond with a single, valid JSON array containing 5 idea objects. Do not add any text or explanation before or after the JSON array.`;
    
    const response = await generateContentWithOpenRouterBff(
        model,
        [{ role: 'user', content: openRouterPrompt }],
        { "type": "json_object" }
    );
    
    const jsonText = response;
    if (!jsonText) throw new Error("Received empty response from OpenRouter for product-based ideas.");
    
    // Log the raw response for debugging
    console.log("Raw OpenRouter response for product ideas:", jsonText);
    
    // Fix malformed JSON responses that are missing array brackets
    let fixedJsonText = jsonText.trim();
    if (fixedJsonText.startsWith('{') && fixedJsonText.includes('title') && fixedJsonText.includes('description') && fixedJsonText.includes('targetAudience')) {
        // This looks like individual idea objects separated by commas
        // Wrap them in an array
        fixedJsonText = '[' + fixedJsonText + ']';
    } else if (fixedJsonText.startsWith('"') && fixedJsonText.endsWith('"')) {
        // This might be a JSON string that needs to be parsed twice
        try {
            fixedJsonText = JSON.parse(fixedJsonText);
        } catch (e) {
            // If parsing fails, continue with original text
        }
    }

    // Log the raw response for debugging
    console.log("Fixed OpenRouter response for product ideas:", fixedJsonText);
    
    try {
        let ideas = sanitizeAndParseJson(fixedJsonText);
        
        // Handle case where ideas might be wrapped in an object with an "ideas" property
        if (ideas && typeof ideas === 'object' && !Array.isArray(ideas) && ideas.ideas) {
            ideas = ideas.ideas;
        }
        
        // Special handling for malformed responses that are missing the opening bracket
        if (ideas && typeof ideas === 'object' && !Array.isArray(ideas) && ideas.title) {
            // This looks like a single idea object instead of an array
            ideas = [ideas];
        }
        
        // Ensure we have an array of ideas
        if (!Array.isArray(ideas)) {
            console.error("Invalid ideas format received from OpenRouter:", ideas);
            throw new Error("Expected an array of ideas, but received: " + JSON.stringify(ideas));
        }
        
        // Validate each idea has the required fields
        for (let i = 0; i < ideas.length; i++) {
            const idea = ideas[i];
            if (!idea.title || !idea.description || !idea.targetAudience) {
                console.error("Invalid idea structure at index", i, ":", idea);
                throw new Error(`Idea at index ${i} is missing required fields. Title: ${!!idea.title}, Description: ${!!idea.description}, TargetAudience: ${!!idea.targetAudience}`);
            }
        }
        
        // Add the productId to each idea
        return ideas.map((idea: any) => ({
            ...idea,
            productId: product.id
        }));
    } catch (e) {
        console.error("Failed to parse AI JSON response for product-based ideas:", jsonText);
        throw new Error("The AI returned a malformed or unexpected response. This may be a temporary issue with the model. Please try again later or configure a different model in Settings.");
    }
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\openrouterService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialAccountService.ts ---\nimport { Persona, SocialAccount, FacebookPage } from '../types';
import { connectAndGetPageToken, publishToFacebookPage } from './facebookService';

// This is a placeholder for a more robust credential storage mechanism.
// In a real application, these would be securely stored server-side.
export const getPersonaSocialAccounts = (personaId: string): SocialAccount[] => {
    try {
        const storedAccounts = localStorage.getItem(`persona_social_accounts_${personaId}`);
        return storedAccounts ? JSON.parse(storedAccounts) : [];
    } catch (e) {
        console.error("Error reading social accounts from localStorage:", e);
        return [];
    }
};

const setPersonaSocialAccounts = (personaId: string, accounts: SocialAccount[]) => {
    localStorage.setItem(`persona_social_accounts_${personaId}`, JSON.stringify(accounts));
};

export const connectSocialAccountToPersona = async (
    persona: Persona,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest'
): Promise<Persona | { pages: FacebookPage[]; userAccessToken: string; }> => {
    let credentials: Record<string, string> = {};
    let displayName: string = platform;
    let profileUrl: string = '#';

    switch (platform) {
        case 'Facebook':
            try {
                const fbAppId = import.meta.env.VITE_FACEBOOK_APP_ID;
                if (!fbAppId) {
                    throw new Error("Facebook App ID is not configured. Please set the App ID in your .env.local file.");
                }
                const fbLoginResponse = await connectAndGetPageToken();

                if (fbLoginResponse.pages.length === 0) {
                    // Return pages (even if empty) for user to select or retry
                    return { pages: fbLoginResponse.pages, userAccessToken: fbLoginResponse.userAccessToken };
                }

                if (fbLoginResponse.pages.length > 1) {
                    // Return pages for user to select
                    return { pages: fbLoginResponse.pages, userAccessToken: fbLoginResponse.userAccessToken };
                } else {
                    // Auto-select the only available page
                    const page = fbLoginResponse.pages[0];
                    credentials = { pageId: page.id, pageAccessToken: page.access_token };
                    displayName = page.name;
                    profileUrl = `https://www.facebook.com/${page.id}`;
                }
            } catch (error) {
                console.error('Facebook connection failed:', error);
                throw error;
            }
            break;
        case 'Instagram':
        case 'TikTok':
        case 'YouTube':
        case 'Pinterest':
            // Simulate connection for other platforms
            await new Promise(resolve => setTimeout(resolve, 1500));
            credentials = { accessToken: `simulated_token_${platform.toLowerCase()}_${Date.now()}` };
            displayName = `My ${platform} Profile`;
            profileUrl = `https://www.simulated.com/${platform.toLowerCase()}/myprofile`;
            console.log(`Simulated connection for ${platform}.`);
            break;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }

    const existingAccounts = getPersonaSocialAccounts(persona.id);
    const newAccount: SocialAccount = { platform, credentials, displayName, profileUrl };

    // Check if an account for this platform already exists for the persona
    const accountIndex = existingAccounts.findIndex(acc => acc.platform === platform);
    if (accountIndex > -1) {
        existingAccounts[accountIndex] = newAccount; // Update existing account
    } else {
        existingAccounts.push(newAccount); // Add new account
    }

    setPersonaSocialAccounts(persona.id, existingAccounts);
    
    // Update the persona object with the new social accounts
    const updatedPersona = { ...persona, socialAccounts: existingAccounts };
    return updatedPersona;
};

export const handleConnectFacebookPage = (
    personaId: string,
    page: FacebookPage
): Persona => {
    const existingAccounts = getPersonaSocialAccounts(personaId);
    const newAccount: SocialAccount = {
        platform: 'Facebook',
        credentials: { pageId: page.id, pageAccessToken: page.access_token },
        displayName: page.name,
        profileUrl: `https://www.facebook.com/${page.id}`
    };

    const accountIndex = existingAccounts.findIndex(acc => acc.platform === 'Facebook');
    if (accountIndex > -1) {
        existingAccounts[accountIndex] = newAccount;
    } else {
        existingAccounts.push(newAccount);
    }
    setPersonaSocialAccounts(personaId, existingAccounts);
    const persona = { id: personaId, socialAccounts: existingAccounts } as Persona;
    // This is a bit of a hack, we need to get the full persona object from the state
    // to avoid overwriting other properties. This should be improved with a proper state management solution.
    const storedPersonasString = localStorage.getItem('personas');
    if (storedPersonasString) {
        const storedPersonas = JSON.parse(storedPersonasString);
        const fullPersona = storedPersonas.find((p: Persona) => p.id === personaId);
        if (fullPersona) {
            return { ...fullPersona, socialAccounts: existingAccounts };
        }
    }
    return persona;
};

export const getSocialAccountForPersona = (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest'
): SocialAccount | undefined => {
    const accounts = getPersonaSocialAccounts(personaId);
    return accounts.find(account => account.platform === platform);
};

export const disconnectSocialAccountFromPersona = (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest'
): Persona => {
    const existingAccounts = getPersonaSocialAccounts(personaId);
    const updatedAccounts = existingAccounts.filter(account => account.platform !== platform);
    setPersonaSocialAccounts(personaId, updatedAccounts);
    
    // In a real app, you might also revoke tokens with the platform's API here.
    console.log(`Disconnected ${platform} from persona ${personaId}.`);

    // This function would ideally return the updated persona from a central state management
    // For now, it returns a partial persona with updated social accounts
    const persona = { id: personaId, socialAccounts: updatedAccounts } as Persona;
    // This is a bit of a hack, we need to get the full persona object from the state
    // to avoid overwriting other properties. This should be improved with a proper state management solution.
    const storedPersonasString = localStorage.getItem('personas');
    if (storedPersonasString) {
        const storedPersonas = JSON.parse(storedPersonasString);
        const fullPersona = storedPersonas.find((p: Persona) => p.id === personaId);
        if (fullPersona) {
            return { ...fullPersona, socialAccounts: updatedAccounts };
        }
    }
    return persona;
};

// Placeholder for direct posting (will be expanded)
export const directPost = async (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest',
    postContent: any, // This will be a more specific type later
    imageUrl?: string,
    videoUrl?: string
): Promise<{ publishedUrl: string }> => {
    const socialAccount = getSocialAccountForPersona(personaId, platform);
    if (!socialAccount) {
        throw new Error(`No ${platform} account connected for this persona.`);
    }

    switch (platform) {
        case 'Facebook':
            const fbPageId = socialAccount.credentials.pageId;
            const fbAccessToken = socialAccount.credentials.pageAccessToken;
            console.log("Facebook credentials for publishing:", { fbPageId, fbAccessToken: fbAccessToken ? '[REDACTED]' : '[MISSING]' });
            if (!fbPageId || !fbAccessToken) {
                throw new Error('Facebook credentials missing.');
            }
            // Assuming postContent has title, content, hashtags, cta for MediaPlanPost
            console.log("Calling publishToFacebookPage with args:", postContent, imageUrl, fbPageId, fbAccessToken, videoUrl);
            return publishToFacebookPage(postContent, imageUrl, fbPageId, fbAccessToken, videoUrl);
        case 'Instagram':
        case 'TikTok':
        case 'YouTube':
        case 'Pinterest':
            // Simulate direct post for other platforms
            console.log(`Simulating direct post to ${platform} for persona ${personaId}:`, postContent);
            await new Promise(resolve => setTimeout(resolve, 2000));
            return { publishedUrl: `https://simulated.social/${platform}/${Date.now()}` };
        default:
            throw new Error(`Unsupported platform for direct posting: ${platform}`);
    }
};

// Placeholder for scheduled posting (will be expanded)
export const schedulePost = async (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest',
    postContent: any, // This will be a more specific type later
    scheduleDate: string,
    imageUrl?: string,
    videoUrl?: string
): Promise<void> => {
    const socialAccount = getSocialAccountForPersona(personaId, platform);
    if (!socialAccount) {
        throw new Error(`No ${platform} account connected for this persona.`);
    }

    console.log(`Simulating scheduling post to ${platform} for persona ${personaId} on ${scheduleDate}:`, postContent);
    await new Promise(resolve => setTimeout(resolve, 2000));
    // In a real scenario, this would interact with the platform's scheduling API or an internal scheduler.
    console.log(`Post successfully scheduled for ${platform}.`);
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialAccountService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialApiService.ts ---\nimport { getSocialAccountForPersona } from './socialAccountService';
import { loadMediaPlan } from './databaseService';
import type { MediaPlanPost } from '../types';

export class SocialAccountNotConnectedError extends Error {
    platform: string;
    personaId: string;

    constructor(message: string, platform: string, personaId: string) {
        super(message);
        this.name = "SocialAccountNotConnectedError";
        this.platform = platform;
        this.personaId = personaId;
    }
}

// Placeholder for direct posting (will be expanded)
export const directPost = async (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest',
    postContent: any, // This will be a more specific type later
    imageUrl?: string,
    videoUrl?: string
): Promise<{ publishedUrl: string }> => {
    const socialAccount = getSocialAccountForPersona(personaId, platform);
    if (!socialAccount) {
        throw new SocialAccountNotConnectedError(`No ${platform} account connected for this persona.`, platform, personaId);
    }

    switch (platform) {
        case 'Facebook':
            const fbPageId = socialAccount.credentials.pageId;
            const fbAccessToken = socialAccount.credentials.pageAccessToken;
            console.log("Facebook credentials for publishing:", { fbPageId, fbAccessToken: fbAccessToken ? '[REDACTED]' : '[MISSING]' });
            if (!fbPageId || !fbAccessToken) {
                throw new Error('Facebook credentials missing.');
            }
            // Assuming postContent has title, content, hashtags, cta for MediaPlanPost
            console.log("Calling publishToFacebookPage with args:", postContent, imageUrl, fbPageId, fbAccessToken, videoUrl);
            return publishToFacebookPage(postContent, imageUrl, fbPageId, fbAccessToken, videoUrl);
        case 'Instagram':
        case 'TikTok':
        case 'YouTube':
        case 'Pinterest':
            // Simulate direct post for other platforms
            console.log(`Simulating direct post to ${platform} for persona ${personaId}:`, postContent);
            await new Promise(resolve => setTimeout(resolve, 2000));
            return { publishedUrl: `https://simulated.social/${platform}/${Date.now()}` };
        default:
            throw new Error(`Unsupported platform for direct posting: ${platform}`);
    }
};

// Placeholder for scheduled posting (will be expanded)
export const schedulePost = async (
    personaId: string,
    platform: 'Facebook' | 'Instagram' | 'TikTok' | 'YouTube' | 'Pinterest',
    postContent: any, // This will be a more specific type later
    scheduleDate: string,
    imageUrl?: string,
    videoUrl?: string
): Promise<void> => {
    const socialAccount = getSocialAccountForPersona(personaId, platform);
    if (!socialAccount) {
        throw new Error(`No ${platform} account connected for this persona.`);
    }

    console.log(`Simulating scheduling post to ${platform} for persona ${personaId} on ${scheduleDate}:`, postContent);
    await new Promise(resolve => setTimeout(resolve, 2000));
    // In a real scenario, this would interact with the platform's scheduling API or an internal scheduler.
    console.log(`Post successfully scheduled for ${platform}.`);
};

export const getPostsByMediaPlan = async (planId: string, brandFoundation: any, language: string): Promise<MediaPlanPost[]> => {
    const { plan } = await loadMediaPlan(planId, brandFoundation, language);
    return plan.flatMap(week => week.posts);
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\socialApiService.ts ---\n\n--- File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\textGenerationService.ts ---\nimport { 
  refinePostContentWithGemini, 
  generateBrandProfile, 
  generateBrandKit, 
  generateMediaPlanGroup, 
  generateMediaPromptForPost, 
  generateAffiliateComment, 
  generateViralIdeas, 
  generateContentPackage,
  generateFacebookTrends,
  generatePostsForFacebookTrend,
  generateIdeasFromProduct
} from './geminiService';
import { 
  refinePostContentWithOpenRouter, 
  generateBrandProfileWithOpenRouter, 
  generateBrandKitWithOpenRouter, 
  generateMediaPlanGroupWithOpenRouter, 
  generateMediaPromptForPostWithOpenRouter, 
  generateAffiliateCommentWithOpenRouter, 
  generateViralIdeasWithOpenRouter, 
  generateContentPackageWithOpenRouter,
  generateIdeasFromProductWithOpenRouter
} from './openrouterService';
import type { 
  BrandInfo, 
  GeneratedAssets, 
  MediaPlanGroup, 
  MediaPlanPost, 
  AffiliateLink, 
  Persona, 
  Idea, 
  BrandFoundation, 
  FacebookTrend, 
  FacebookPostIdea 
} from '../types';

// Unified interface for all text generation functions
export interface TextGenerationService {
  refinePostContent: (postText: string, model: string) => Promise<string>;
  generateBrandProfile: (idea: string, language: string, model: string) => Promise<BrandInfo>;
  generateBrandKit: (brandInfo: BrandInfo, language: string, model: string) => Promise<Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'>>;
  generateMediaPlanGroup: (
    brandFoundation: BrandFoundation,
    userPrompt: string,
    language: string,
    totalPosts: number,
    useSearch: boolean,
    selectedPlatforms: string[],
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    affiliateContentKitSystemInstruction: string,
    model: string,
    persona: Persona | null,
    selectedProduct: AffiliateLink | null
  ) => Promise<MediaPlanGroup>;
  generateMediaPromptForPost: (
    postContent: { title: string; content: string; contentType: string },
    brandFoundation: BrandFoundation,
    language: string,
    model: string,
    persona: Persona | null,
    mediaPromptSuffix: string
  ) => Promise<string | string[]>;
  generateAffiliateComment: (
    post: MediaPlanPost,
    products: AffiliateLink[],
    brandFoundation: BrandFoundation,
    language: string,
    model: string
  ) => Promise<string>;
  generateViralIdeas: (
    trend: { topic: string; keywords: string[] },
    language: string,
    useSearch: boolean,
    model: string
  ) => Promise<Omit<Idea, 'id' | 'trendId'>[]>;
  generateContentPackage: (
    idea: Idea,
    brandFoundation: BrandFoundation,
    language: string,
    affiliateContentKit: string,
    model: string,
    persona: Persona | null,
    pillarPlatform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest',
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    selectedProduct: AffiliateLink | null
  ) => Promise<MediaPlanGroup>;
  generateFacebookTrends: (
    industry: string,
    language: string,
    model: string
  ) => Promise<Omit<FacebookTrend, 'id'|'brandId'>[]>;
  generatePostsForFacebookTrend: (
    trend: FacebookTrend,
    language: string,
    model: string
  ) => Promise<Omit<FacebookPostIdea, 'id' | 'trendId'>[]>;
  generateIdeasFromProduct: (
    product: AffiliateLink,
    language: string,
    model: string
  ) => Promise<Omit<Idea, 'id' | 'trendId'>[]>;
}

// Determine if a model is a Google model
const isGoogleModel = (model: string): boolean => {
  return model.startsWith('gemini-') && !model.includes('free');
};

// Create service instances
const googleService: TextGenerationService = {
  refinePostContent: refinePostContentWithGemini,
  generateBrandProfile,
  generateBrandKit,
  generateMediaPlanGroup,
  generateMediaPromptForPost,
  generateAffiliateComment,
  generateViralIdeas,
  generateContentPackage,
  generateFacebookTrends,
  generatePostsForFacebookTrend,
  generateIdeasFromProduct
};

const openRouterService: TextGenerationService = {
  refinePostContent: refinePostContentWithOpenRouter,
  generateBrandProfile: generateBrandProfileWithOpenRouter,
  generateBrandKit: generateBrandKitWithOpenRouter,
  generateMediaPlanGroup: (brandFoundation, userPrompt, language, totalPosts, useSearch, selectedPlatforms, options, affiliateContentKitSystemInstruction, model, persona, selectedProduct) => {
    // OpenRouter doesn't use the useSearch parameter, so we ignore it
    // Add type checking to ensure selectedPlatforms is an array
    if (!Array.isArray(selectedPlatforms)) {
      throw new Error(`selectedPlatforms must be an array, got ${typeof selectedPlatforms}: ${JSON.stringify(selectedPlatforms)}`);
    }
    return generateMediaPlanGroupWithOpenRouter(
      brandFoundation,
      userPrompt,
      language,
      totalPosts,
      selectedPlatforms,
      options,
      affiliateContentKitSystemInstruction,
      model,
      persona,
      selectedProduct
    );
  },
  generateMediaPromptForPost: generateMediaPromptForPostWithOpenRouter,
  generateAffiliateComment,
  generateViralIdeas: (trend, language, useSearch, model) => {
    // OpenRouter doesn't use the useSearch parameter, so we ignore it
    return generateViralIdeasWithOpenRouter(trend, language, model);
  },
  generateContentPackage: async () => {
    throw new Error('Content package generation is not supported with OpenRouter models');
  },
  generateFacebookTrends: async () => {
    throw new Error('Facebook trend generation is not supported with OpenRouter models');
  },
  generatePostsForFacebookTrend: async () => {
    throw new Error('Facebook post generation is not supported with OpenRouter models');
  },
  generateIdeasFromProduct: generateIdeasFromProductWithOpenRouter
};

// Unified service that selects the appropriate implementation based on the model
export const textGenerationService: TextGenerationService = {
  refinePostContent: async (postText: string, model: string): Promise<string> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.refinePostContent(postText, model);
  },
  
  generateBrandProfile: async (idea: string, language: string, model: string): Promise<BrandInfo> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.generateBrandProfile(idea, language, model);
  },
  
  generateBrandKit: async (brandInfo: BrandInfo, language: string, model: string): Promise<Omit<GeneratedAssets, 'affiliateLinks' | 'personas' | 'trends' | 'ideas' | 'facebookTrends' | 'facebookPostIdeas'>> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.generateBrandKit(brandInfo, language, model);
  },
  
  generateMediaPlanGroup: async (
    brandFoundation: BrandFoundation,
    userPrompt: string,
    language: string,
    totalPosts: number,
    useSearch: boolean,
    selectedPlatforms: string[],
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    affiliateContentKitSystemInstruction: string,
    model: string,
    persona: Persona | null,
    selectedProduct: AffiliateLink | null
  ): Promise<MediaPlanGroup> => {
    // Google models can use search functionality, OpenRouter models cannot
    const service = isGoogleModel(model) ? googleService : openRouterService;
    const actualUseSearch = isGoogleModel(model) ? useSearch : false;
    
    // Add type checking to ensure selectedPlatforms is an array
    if (!Array.isArray(selectedPlatforms)) {
      throw new Error(`selectedPlatforms must be an array, got ${typeof selectedPlatforms}: ${JSON.stringify(selectedPlatforms)}`);
    }
    
    if (isGoogleModel(model)) {
      return service.generateMediaPlanGroup(
        brandFoundation,
        userPrompt,
        language,
        totalPosts,
        actualUseSearch,
        selectedPlatforms,
        options,
        affiliateContentKitSystemInstruction,
        model,
        persona,
        selectedProduct
      );
    } else {
      // For OpenRouter, we need to include the useSearch parameter (even though it's not used)
      return (service as any).generateMediaPlanGroup(
        brandFoundation,
        userPrompt,
        language,
        totalPosts,
        false, // useSearch - OpenRouter doesn't use this parameter
        selectedPlatforms,
        options,
        affiliateContentKitSystemInstruction,
        model,
        persona,
        selectedProduct
      );
    }
  },
  
  generateMediaPromptForPost: async (
    postContent: { title: string; content: string; contentType: string },
    brandFoundation: BrandFoundation,
    language: string,
    model: string,
    persona: Persona | null,
    mediaPromptSuffix: string
  ): Promise<string | string[]> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.generateMediaPromptForPost(postContent, brandFoundation, language, model, persona, mediaPromptSuffix);
  },
  
  generateAffiliateComment: async (
    post: MediaPlanPost,
    products: AffiliateLink[],
    brandFoundation: BrandFoundation,
    language: string,
    model: string
  ): Promise<string> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.generateAffiliateComment(post, products, brandFoundation, language, model);
  },
  
  generateViralIdeas: async (
    trend: { topic: string; keywords: string[] },
    language: string,
    useSearch: boolean,
    model: string
  ): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    // Google models can use search functionality, OpenRouter models cannot
    const service = isGoogleModel(model) ? googleService : openRouterService;
    const actualUseSearch = isGoogleModel(model) ? useSearch : false;
    
    if (isGoogleModel(model)) {
      return service.generateViralIdeas(trend, language, actualUseSearch, model);
    } else {
      // For OpenRouter, we need to pass all arguments, but useSearch is ignored.
      return service.generateViralIdeas(trend, language, false, model);
    }
  },
  
  generateContentPackage: async (
    idea: Idea,
    brandFoundation: BrandFoundation,
    language: string,
    affiliateContentKit: string,
    model: string,
    persona: Persona | null,
    pillarPlatform: 'YouTube' | 'Facebook' | 'Instagram' | 'TikTok' | 'Pinterest',
    options: { tone: string; style: string; length: string; includeEmojis: boolean; },
    selectedProduct: AffiliateLink | null
  ): Promise<MediaPlanGroup> => {
    // Use BFF for content generation to keep API keys secure
    return googleService.generateContentPackage(
        idea,
        brandFoundation,
        language,
        affiliateContentKit,
        model,
        persona,
        pillarPlatform,
        options,
        selectedProduct
    );
  },
  
  generateFacebookTrends: async (
    industry: string,
    language: string,
    model: string
  ): Promise<Omit<FacebookTrend, 'id'|'brandId'>[]> => {
    // Only Google models support Facebook trend generation
    if (!isGoogleModel(model)) {
      throw new Error('Facebook trend generation is not supported with OpenRouter models');
    }
    return googleService.generateFacebookTrends(industry, language, model);
  },
  
  generatePostsForFacebookTrend: async (
    trend: FacebookTrend,
    language: string,
    model: string
  ): Promise<Omit<FacebookPostIdea, 'id' | 'trendId'>[]> => {
    // Only Google models support Facebook post generation
    if (!isGoogleModel(model)) {
      throw new Error('Facebook post generation is not supported with OpenRouter models');
    }
    return googleService.generatePostsForFacebookTrend(trend, language, model);
  },
  
  generateIdeasFromProduct: async (
    product: AffiliateLink,
    language: string,
    model: string
  ): Promise<Omit<Idea, 'id' | 'trendId'>[]> => {
    const service = isGoogleModel(model) ? googleService : openRouterService;
    return service.generateIdeasFromProduct(product, language, model);
  }
};\n--- End of File: C:\Users\trltr\Downloads\personal_projects\socialsync-pro-2.1\src\services\textGenerationService.ts ---\n\n=== End of Project Analysis File ===\nUpload this file to Grok. If sensitive data (e.g., API keys) appears, edit it out before uploading.\n
