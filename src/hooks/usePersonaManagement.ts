import { useState, useCallback, Dispatch, SetStateAction } from 'react';
import type { Persona, Settings, GeneratedAssets } from '../../types';
import { textGenerationService } from '../services/textGenerationService';
import { savePersonaToDatabase, deletePersonaFromDatabase } from '../services/databaseService';
import { uploadMediaToCloudinary } from '../services/cloudinaryService';
import { AiModelConfig } from '../services/configService';
import { loadPersonas } from '../services/lazyLoadService';

interface UsePersonaManagementProps {
    mongoBrandId: string | null;
    settings: Settings;
    aiModelConfig: AiModelConfig | null;
    dispatchAssets: Dispatch<any>;
    updateAutoSaveStatus: (status: 'saving' | 'saved' | 'error' | 'idle') => void;
    setGeneratedImages: Dispatch<SetStateAction<Record<string, string>>>;
    setError: (error: string | null) => void;
    setLoaderContent: (content: { title: string; steps: string[]; } | null) => void;
    ensureMongoProject: () => Promise<string | null>;
    generatedAssets: GeneratedAssets | null;
    setSuccessMessage: (message: string | null) => void;
}

export const usePersonaManagement = ({
    mongoBrandId,
    settings,
    aiModelConfig,
    dispatchAssets,
    updateAutoSaveStatus,
    setGeneratedImages,
    setError,
    setLoaderContent,
    ensureMongoProject,
    generatedAssets,
    setSuccessMessage
}: UsePersonaManagementProps) => {
    const [isAutoPersonasModalOpen, setIsAutoPersonasModalOpen] = useState(false);
    const [autoGeneratedPersonas, setAutoGeneratedPersonas] = useState<Partial<Persona>[] | null>(null);

    const handleLoadPersonasData = useCallback(async () => {
        if (!mongoBrandId) return;
        try {
            const personas = await loadPersonas(mongoBrandId);
            dispatchAssets({ type: 'SET_PERSONAS', payload: personas });
        } catch (error) {
            setError(error instanceof Error ? error.message : "Could not load personas data.");
            throw error;
        }
    }, [mongoBrandId, dispatchAssets, setError]);

    const handleSavePersona = useCallback(async (persona: Partial<Persona>) => {
        updateAutoSaveStatus('saving');
        try {
            if (!mongoBrandId) throw new Error("Cannot save persona: No brand selected.");

            let personaToSave = { ...persona };

            if (personaToSave.imageUrl && personaToSave.imageUrl.startsWith('data:') && personaToSave.imageKey) {
                const publicUrls = await uploadMediaToCloudinary({ [personaToSave.imageKey]: personaToSave.imageUrl }, settings);
                const publicUrl = publicUrls[personaToSave.imageKey];
                if (publicUrl) {
                    personaToSave.imageUrl = publicUrl;
                    setGeneratedImages(prev => ({ ...prev, [personaToSave.imageKey!]: publicUrl }));
                }
            }
            
            const savedId = await savePersonaToDatabase(personaToSave, mongoBrandId, settings);
            
            const finalPersona: Persona = {
                ...personaToSave,
                id: savedId,
                brandId: mongoBrandId,
                nickName: personaToSave.nickName || 'Unnamed Persona',
                fullName: personaToSave.fullName || '',
                background: personaToSave.background || '',
                outfitDescription: personaToSave.outfitDescription || '',
            };
    
            dispatchAssets({ type: 'SAVE_PERSONA', payload: finalPersona });
            updateAutoSaveStatus('saved');
        } catch(e: any) {
            setError(e.message);
            updateAutoSaveStatus('error');
        }
    }, [mongoBrandId, settings, updateAutoSaveStatus, dispatchAssets, setGeneratedImages, setError]);

    const handleUpdatePersona = useCallback(async (persona: Persona) => {
        await handleSavePersona(persona);
    }, [handleSavePersona]);

    const handleDeletePersona = useCallback((personaId: string) => {
        dispatchAssets({ type: 'DELETE_PERSONA', payload: personaId });
        if (mongoBrandId) {
            updateAutoSaveStatus('saving');
            deletePersonaFromDatabase(personaId, mongoBrandId, settings)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
        }
    }, [mongoBrandId, settings, updateAutoSaveStatus, dispatchAssets, setError]);

    const handleAutoGeneratePersona = useCallback(async () => {
        if (!generatedAssets?.brandFoundation) {
            setError("Brand Foundation is not available. Please generate a brand kit first.");
            return;
        }
        const { mission, usp } = generatedAssets.brandFoundation;
        if (!mission || !usp) {
            setError("Brand mission and USP must be defined in the Brand Kit to generate a persona.");
            return;
        }

        setLoaderContent({ title: "AI is Generating Personas...", steps: ["Analyzing brand identity...", "Crafting diverse persona profiles...", "Finalizing results..."] });
        setError(null);
        try {
            if (!aiModelConfig) {
                throw new Error("AI Model configuration not loaded.");
            }
            
            const personaDataArray = await textGenerationService.autoGeneratePersonaProfile(
                {
                    mission: mission,
                    usp: usp,
                    settings: settings
                },
                aiModelConfig
            );
            setAutoGeneratedPersonas(personaDataArray);
            setIsAutoPersonasModalOpen(true);
        } catch (err) {
            setError(err instanceof Error ? err.message : "An unknown error occurred during persona generation.");
        } finally {
            setLoaderContent(null);
        }
    }, [generatedAssets?.brandFoundation, settings, aiModelConfig, setError, setLoaderContent]);

    const handleSaveSelectedPersonas = useCallback(async (selectedPersonas: Partial<Persona>[]) => {
        if (!selectedPersonas || selectedPersonas.length === 0) {
            setIsAutoPersonasModalOpen(false);
            return;
        }
        setLoaderContent({ title: "Saving Personas...", steps: [`Saving ${selectedPersonas.length} persona(s)...`] });

        try {
            for (const p of selectedPersonas) {
                await handleSavePersona(p);
            }
            setSuccessMessage(`${selectedPersonas.length} new persona(s) saved successfully!`);
        } catch (e) {
            setError(e instanceof Error ? e.message : "An error occurred while saving personas.");
        } finally {
            setIsAutoPersonasModalOpen(false);
            setAutoGeneratedPersonas(null);
            setLoaderContent(null);
            setTimeout(() => setSuccessMessage(null), 3000);
        }
    }, [handleSavePersona, setLoaderContent, setError, setSuccessMessage]);
    
    const handleSetPersonaImage = useCallback(async (personaId: string, photoId: string, dataUrl: string): Promise<string | undefined> => {
        const randomSuffix = Math.random().toString(36).substring(2, 10);
        const newImageKey = `persona_${personaId}_photo_${photoId}_${randomSuffix}`;
    
        setGeneratedImages(prev => ({ ...prev, [newImageKey]: dataUrl }));
        
        return newImageKey;
    }, [setGeneratedImages]);

    return {
        isAutoPersonasModalOpen,
        autoGeneratedPersonas,
        setIsAutoPersonasModalOpen,
        setAutoGeneratedPersonas,
        handleLoadPersonasData,
        handleSavePersona,
        handleUpdatePersona,
        handleDeletePersona,
        handleAutoGeneratePersona,
        handleSaveSelectedPersonas,
        handleSetPersonaImage,
    };
};