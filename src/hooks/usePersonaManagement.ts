import { useState, useCallback, Dispatch, SetStateAction } from 'react';
import type { Persona, Settings, GeneratedAssets } from '../../types';

import { savePersonaToDatabase, deletePersonaFromDatabase, updatePersonaState } from '../services/databaseService';
import { uploadMediaToCloudinary } from '../services/cloudinaryService';
import { AiModelConfig } from '../services/configService';
import { loadPersonas } from '../services/lazyLoadService';
import { dataCache } from '../services/databaseService';
import { taskService } from '../services/taskService';

interface UsePersonaManagementProps {
    mongoBrandId: string | null;
    settings: Settings;
    aiModelConfig: AiModelConfig | null;
    dispatchAssets: Dispatch<any>;
    updateAutoSaveStatus: (status: 'saving' | 'saved' | 'error' | 'idle') => void;
    setGeneratedImages: Dispatch<SetStateAction<Record<string, string>>>;
    setError: (error: string | null) => void;
    setLoaderContent: (content: { title: string; steps: string[]; } | null) => void;
    ensureMongoProject: () => Promise<string | null>;
    generatedAssets: GeneratedAssets | null;
    setSuccessMessage: (message: string | null) => void;
    onTaskCreated?: () => void;
}

export const usePersonaManagement = ({
    mongoBrandId,
    settings,
    aiModelConfig,
    dispatchAssets,
    updateAutoSaveStatus,
    setGeneratedImages,
    setError,
    setLoaderContent,
    ensureMongoProject,
    generatedAssets,
    setSuccessMessage,
    onTaskCreated
}: UsePersonaManagementProps) => {
    const [isAutoPersonasModalOpen, setIsAutoPersonasModalOpen] = useState(false);
    const [autoGeneratedPersonas, setAutoGeneratedPersonas] = useState<Partial<Persona>[] | null>(null);
    const [isPersonasLoading, setIsPersonasLoading] = useState(false);

    const handleLoadPersonasData = useCallback(async () => {
        if (!mongoBrandId || isPersonasLoading) return;
        setIsPersonasLoading(true);
        try {
            const personas = await loadPersonas(mongoBrandId);
            dispatchAssets({ type: 'SET_PERSONAS', payload: personas });
        } catch (error) {
            setError(error instanceof Error ? error.message : "Could not load personas data.");
            throw error;
        } finally {
            setIsPersonasLoading(false);
        }
    }, [mongoBrandId, isPersonasLoading, dispatchAssets, setError]);
    
    const handleRefreshPersonasData = useCallback(async () => {
        if (!mongoBrandId || isPersonasLoading) return;
        setIsPersonasLoading(true);
        try {
            // Clear cache to force a fresh database fetch
            const cacheKey = `personas-${mongoBrandId}`;
            delete dataCache[cacheKey];
            
            const personas = await loadPersonas(mongoBrandId);
            dispatchAssets({ type: 'SET_PERSONAS', payload: personas });
        } catch (error) {
            setError(error instanceof Error ? error.message : "Could not load personas data.");
            throw error;
        } finally {
            setIsPersonasLoading(false);
        }
    }, [mongoBrandId, isPersonasLoading, dispatchAssets, setError]);

    const handleSavePersona = useCallback(async (persona: Partial<Persona>) => {
        updateAutoSaveStatus('saving');
        try {
            if (!mongoBrandId) throw new Error("Cannot save persona: No brand selected.");

            let personaToSave = { ...persona };

            if (personaToSave.imageUrl && personaToSave.imageUrl.startsWith('data:') && personaToSave.imageKey) {
                const publicUrls = await uploadMediaToCloudinary({ [personaToSave.imageKey]: personaToSave.imageUrl }, settings);
                const publicUrl = publicUrls[personaToSave.imageKey];
                if (publicUrl) {
                    personaToSave.imageUrl = publicUrl;
                    setGeneratedImages(prev => ({ ...prev, [personaToSave.imageKey!]: publicUrl }));
                }
            }
            
            const savedId = await savePersonaToDatabase(personaToSave, mongoBrandId, settings);
            
            const finalPersona: Persona = {
                ...personaToSave,
                id: savedId,
                brandId: mongoBrandId,
                nickName: personaToSave.nickName || 'Unnamed Persona',
                fullName: personaToSave.fullName || '',
                background: personaToSave.background || '',
                outfitDescription: personaToSave.outfitDescription || '',
            };
    
            dispatchAssets({ type: 'SAVE_PERSONA', payload: finalPersona });
            updateAutoSaveStatus('saved');
        } catch(e: any) {
            setError(e.message);
            updateAutoSaveStatus('error');
        }
    }, [mongoBrandId, settings, updateAutoSaveStatus, dispatchAssets, setGeneratedImages, setError]);

    const handleUpdatePersona = useCallback(async (persona: Persona) => {
        await handleSavePersona(persona);
    }, [handleSavePersona]);

    const handleDeletePersona = useCallback((personaId: string) => {
        dispatchAssets({ type: 'DELETE_PERSONA', payload: personaId });
        if (mongoBrandId) {
            updateAutoSaveStatus('saving');
            deletePersonaFromDatabase(personaId, mongoBrandId, settings)
                .then(() => updateAutoSaveStatus('saved'))
                .catch(e => { setError(e.message); updateAutoSaveStatus('error'); });
        }
    }, [mongoBrandId, settings, updateAutoSaveStatus, dispatchAssets, setError]);

    const handleAutoGeneratePersona = useCallback(async () => {
        if (!generatedAssets?.brandFoundation) {
            setError("Brand Foundation is not available. Please generate a brand kit first.");
            return;
        }
        const { mission, usp } = generatedAssets.brandFoundation;
        if (!mission || !usp) {
            setError("Brand mission and USP must be defined in the Brand Kit to generate a persona.");
            return;
        }

        setError(null);
        try {
            if (!aiModelConfig || !mongoBrandId) {
                throw new Error("AI Model configuration not loaded or no brand selected.");
            }
            
            // Create a background task for persona generation
            const taskPayload = {
                mission: mission,
                usp: usp,
                modelUsed: settings.textGenerationModel, // Include the model used
                settings: {
                    language: settings.language,
                    totalPostsPerMonth: settings.totalPostsPerMonth,
                    mediaPromptSuffix: settings.mediaPromptSuffix,
                    affiliateContentKit: settings.affiliateContentKit,
                    textGenerationModel: settings.textGenerationModel,
                    imageGenerationModel: settings.imageGenerationModel,
                    textModelFallbackOrder: settings.textModelFallbackOrder,
                    visionModels: settings.visionModels,
                    contentPillars: settings.contentPillars,
                    prompts: settings.prompts,
                }
            };

            const { taskId } = await taskService.createBackgroundTask(
                'AUTO_GENERATE_PERSONAS',
                taskPayload,
                mongoBrandId,
                'normal'
            );

            // Notify user that the task has been started
            setSuccessMessage(settings.language === 'Việt Nam' 
                ? "Đang tự động tạo Persona trong nền..." 
                : "Auto-generating personas in the background...");
            onTaskCreated?.();
        } catch (err) {
            setError(err instanceof Error ? err.message : "An unknown error occurred during persona generation.");
        }
    }, [generatedAssets?.brandFoundation, settings, aiModelConfig, mongoBrandId, setError, setSuccessMessage, onTaskCreated]);

    const handleSaveSelectedPersonas = useCallback(async (selectedPersonas: Partial<Persona>[]) => {
        if (!selectedPersonas || selectedPersonas.length === 0) {
            setIsAutoPersonasModalOpen(false);
            return;
        }
        setLoaderContent({ title: "Saving Personas...", steps: [`Saving ${selectedPersonas.length} persona(s)...`] });

        try {
            for (const p of selectedPersonas) {
                await handleSavePersona(p);
            }
            setSuccessMessage(`${selectedPersonas.length} new persona(s) saved successfully!`);
        } catch (e) {
            setError(e instanceof Error ? e.message : "An error occurred while saving personas.");
        } finally {
            setIsAutoPersonasModalOpen(false);
            setAutoGeneratedPersonas(null);
            setLoaderContent(null);
            setTimeout(() => setSuccessMessage(null), 3000);
        }
    }, [handleSavePersona, setLoaderContent, setError, setSuccessMessage]);
    
    const handleSetPersonaImage = useCallback(async (personaId: string, photoId: string, dataUrl: string): Promise<string | undefined> => {
        const randomSuffix = Math.random().toString(36).substring(2, 10);
        const newImageKey = `persona_${personaId}_photo_${photoId}_${randomSuffix}`;
    
        setGeneratedImages(prev => ({ ...prev, [newImageKey]: dataUrl }));
        
        return newImageKey;
    }, [setGeneratedImages]);

    const handleTogglePersonaState = useCallback(async (personaId: string, isActive: boolean) => {
        if (!mongoBrandId) return;
        updateAutoSaveStatus('saving');
        try {
            await updatePersonaState(personaId, isActive, mongoBrandId);
            dispatchAssets({ type: 'UPDATE_PERSONA', payload: { id: personaId, isActive } });
            updateAutoSaveStatus('saved');
        } catch (e: any) {
            setError(e.message);
            updateAutoSaveStatus('error');
        }
    }, [mongoBrandId, dispatchAssets, updateAutoSaveStatus, setError]);

    return {
        isAutoPersonasModalOpen,
        autoGeneratedPersonas,
        setIsAutoPersonasModalOpen,
        setAutoGeneratedPersonas,
        handleLoadPersonasData,
        handleRefreshPersonasData,
        handleSavePersona,
        handleUpdatePersona,
        handleDeletePersona,
        handleAutoGeneratePersona,
        handleSaveSelectedPersonas,
        handleSetPersonaImage,
        handleTogglePersonaState,
        isPersonasLoading,
    };
};